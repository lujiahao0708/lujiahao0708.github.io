<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>分类: Java - 后端小哥博客</title><meta description="一个 Java 程序猿"><meta property="og:type" content="blog"><meta property="og:title" content="后端小哥博客"><meta property="og:url" content="http://lujiahao0708.github.io/"><meta property="og:site_name" content="后端小哥博客"><meta property="og:description" content="一个 Java 程序猿"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="后端小哥"><meta property="article:tag" content="博客"><meta property="article:tag" content="技术博客"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://lujiahao0708.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://lujiahao0708.github.io"},"headline":"后端小哥博客","image":["http://lujiahao0708.github.io/img/og_image.png"],"author":{"@type":"Person","name":"后端小哥"},"description":"一个 Java 程序猿"}</script><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="/css/default.css"><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cdef3b7efc8748063e32969cc0b8dedc";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="后端小哥博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories/Redis">Redis</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/lujiahao0708"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">Java</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-04-17T11:34:52.000Z" title="2019-04-17T11:34:52.000Z">2019-04-17</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">5 分钟 读完 (大约 778 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/2d0ec2ca.html">《Elasticsearch技术解析与实战》Chapter 2.1 Elasticsearch索引增删改查</a></h1><div class="content"><h1 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1. 创建索引"></a>1. 创建索引</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;lujiahao123</span><br><span class="line">&#123;</span><br><span class="line">  &quot;acknowledged&quot;: true,</span><br><span class="line">  &quot;shards_acknowledged&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">索引默认的主分片数量是5，每个主分片的副本数量是1。</span><br></pre></td></tr></table></figure></div><a class="article-more button is-small size-small" href="/p/2d0ec2ca.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-04-16T11:34:52.000Z" title="2019-04-16T11:34:52.000Z">2019-04-16</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">4 分钟 读完 (大约 583 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/19f71057.html">《Elasticsearch技术解析与实战》Chapter 1.4 Spring Boot整合Elasticsearch</a></h1><div class="content"><h1 id="1-spring-boot-starter-data-elasticsearch"><a href="#1-spring-boot-starter-data-elasticsearch" class="headerlink" title="1. spring-boot-starter-data-elasticsearch"></a>1. spring-boot-starter-data-elasticsearch</h1><h2 id="1-1-pom-xml和application-yml"><a href="#1-1-pom-xml和application-yml" class="headerlink" title="1.1 pom.xml和application.yml"></a>1.1 pom.xml和application.yml</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Spring Boot Elasticsearch 依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">spring:</span><br><span class="line">  data:</span><br><span class="line">    elasticsearch:</span><br><span class="line">      repositories:</span><br><span class="line">        enabled: <span class="keyword">true</span></span><br><span class="line">      cluster-name: docker-cluster</span><br><span class="line">      cluster-nodes: lujiahao.ml:<span class="number">9300</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-创建Repository"><a href="#1-2-创建Repository" class="headerlink" title="1.2 创建Repository"></a>1.2 创建Repository</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonEsRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Person</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">findPersonByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-文档实体类"><a href="#1-3-文档实体类" class="headerlink" title="1.3 文档实体类"></a>1.3 文档实体类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"person"</span>, type = <span class="string">"chinese"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6804453833406105286L</span>;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-增删改查"><a href="#1-4-增删改查" class="headerlink" title="1.4 增删改查"></a>1.4 增删改查</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EsStarterService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PersonEsRepository repository;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">save</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.save(person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        repository.delete(person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">update</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.save(person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Person&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-单元测试"><a href="#1-5-单元测试" class="headerlink" title="1.5 单元测试"></a>1.5 单元测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">EsStarterServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EsStarterService esStarterService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.setId(<span class="keyword">new</span> Random().nextLong());</span><br><span class="line">        person.setName(<span class="string">"lujiahao"</span>);</span><br><span class="line">        esStarterService.save(person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.setId(-<span class="number">5264182431891613084L</span>);</span><br><span class="line">        person.setName(<span class="string">"lujiahao123456"</span>);</span><br><span class="line">        esStarterService.delete(person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.setId(<span class="number">542136934419565287L</span>);</span><br><span class="line">        person.setName(<span class="string">"lujiahao123456"</span>);</span><br><span class="line">        esStarterService.update(person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterable&lt;Person&gt; all = esStarterService.findAll();</span><br><span class="line">        all.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-ElasticsearchTemplate"><a href="#2-ElasticsearchTemplate" class="headerlink" title="2. ElasticsearchTemplate"></a>2. ElasticsearchTemplate</h1><h2 id="2-1-pom-xml和application-ym"><a href="#2-1-pom-xml和application-ym" class="headerlink" title="2.1 pom.xml和application.ym"></a>2.1 pom.xml和application.ym</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--elasticsearch--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">spring:</span><br><span class="line">  data:</span><br><span class="line">    elasticsearch:</span><br><span class="line">      repositories:</span><br><span class="line">        enabled: <span class="keyword">true</span></span><br><span class="line">      cluster-name: docker-cluster</span><br><span class="line">      cluster-nodes: lujiahao.ml:<span class="number">9300</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-文档实体类"><a href="#2-2-文档实体类" class="headerlink" title="2.2 文档实体类"></a>2.2 文档实体类</h2><p>同上</p>
<h2 id="2-3-增删改查"><a href="#2-3-增删改查" class="headerlink" title="2.3 增删改查"></a>2.3 增删改查</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchTemplateService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> ElasticsearchTemplate elasticsearchTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INDEX_NAME = <span class="string">"person"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_NAME = <span class="string">"chinese"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        IndexQuery indexQuery = <span class="keyword">new</span> IndexQueryBuilder()</span><br><span class="line">                .withIndexName(INDEX_NAME)</span><br><span class="line">                .withType(TYPE_NAME)</span><br><span class="line">                .withId(String.valueOf(person.getId()))</span><br><span class="line">                .withObject(person)</span><br><span class="line">                .build();</span><br><span class="line">        String index = elasticsearchTemplate.index(indexQuery);</span><br><span class="line">        System.out.println(<span class="string">"xxxxxxxxxxxx "</span> + index);</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        DeleteQuery deleteQuery = <span class="keyword">new</span> DeleteQuery();</span><br><span class="line">        deleteQuery.setQuery(QueryBuilders.matchQuery(<span class="string">"name"</span>, name));</span><br><span class="line">        deleteQuery.setIndex(INDEX_NAME);</span><br><span class="line">        deleteQuery.setType(TYPE_NAME);</span><br><span class="line">        elasticsearchTemplate.delete(deleteQuery);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UpdateResponse <span class="title">update</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UpdateRequest updateRequest = <span class="keyword">new</span> UpdateRequest()</span><br><span class="line">                    .index(INDEX_NAME)</span><br><span class="line">                    .type(TYPE_NAME)</span><br><span class="line">                    .id(String.valueOf(person.getId()))</span><br><span class="line">                    .doc(XContentFactory.jsonBuilder()</span><br><span class="line">                            .startObject()</span><br><span class="line">                            .field(<span class="string">"name"</span>, person.getName())</span><br><span class="line">                            .endObject());</span><br><span class="line">            UpdateQuery updateQuery = <span class="keyword">new</span> UpdateQueryBuilder()</span><br><span class="line">                    .withIndexName(INDEX_NAME)</span><br><span class="line">                    .withType(TYPE_NAME)</span><br><span class="line">                    .withId(String.valueOf(person.getId()))</span><br><span class="line">                    .withClass(Person<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">withUpdateRequest</span>(<span class="title">updateRequest</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">build</span>()</span>;</span><br><span class="line">            UpdateResponse update = elasticsearchTemplate.update(updateQuery);</span><br><span class="line">            <span class="keyword">return</span> update;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SearchQuery searchQuery = <span class="keyword">new</span> NativeSearchQueryBuilder()</span><br><span class="line">                .withQuery(QueryBuilders.matchAllQuery())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> elasticsearchTemplate.queryForList(searchQuery, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-单元测试"><a href="#2-4-单元测试" class="headerlink" title="2.4 单元测试"></a>2.4 单元测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ElasticsearchTemplateServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ElasticsearchTemplateService elasticsearchTemplateService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.setId(<span class="keyword">new</span> Random().nextLong());</span><br><span class="line">        person.setName(<span class="string">"haha"</span>);</span><br><span class="line">        String save = elasticsearchTemplateService.save(person);</span><br><span class="line">        System.out.println(save);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteByName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elasticsearchTemplateService.deleteByName(<span class="string">"lujiahao"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.setId(-<span class="number">5264182431891613084L</span>);</span><br><span class="line">        person.setName(<span class="string">"hahaaaaaaaaa"</span>);</span><br><span class="line">        UpdateResponse update = elasticsearchTemplateService.update(person);</span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; all = elasticsearchTemplateService.getAll();</span><br><span class="line">        System.out.println(all);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/lujiahao0708/LearnSeries/tree/master/LearnElasticSerach</span></span><br></pre></td></tr></table></figure>


<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>本文同步发表在公众号，欢迎大家关注！😁<br>后续笔记欢迎关注获取第一时间更新！<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-04-15T11:34:52.000Z" title="2019-04-15T11:34:52.000Z">2019-04-15</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">3 分钟 读完 (大约 462 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/763a1549.html">《Elasticsearch技术解析与实战》Chapter 1.3 Elasticsearch增删改查</a></h1><div class="content"><h1 id="1-新增文档，建立索引"><a href="#1-新增文档，建立索引" class="headerlink" title="1. 新增文档，建立索引"></a>1. 新增文档，建立索引</h1><p>语法格式:</p>
<pre><code>PUT /index/type/id
{
  &quot;json数据&quot;
}</code></pre><p>输入:</p>
<pre><code>PUT /person/chinese/1
{
  &quot;id&quot;:12345,
  &quot;name&quot;:&quot;lujiahao&quot;,
  &quot;age&quot;:18
}</code></pre><p>输出:</p>
<pre><code>{
  &quot;_index&quot;: &quot;person&quot;,
  &quot;_type&quot;: &quot;chinese&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 1,
  &quot;result&quot;: &quot;created&quot;,
  &quot;_shards&quot;: {
    &quot;total&quot;: 2,
    &quot;successful&quot;: 1,
    &quot;failed&quot;: 0
  },
  &quot;created&quot;: true
}</code></pre><blockquote>
<p>es会自动建立index和type，不需要提前创建，而且es默认会对document每个field都建立倒排索引，让其可以被搜索。</p>
</blockquote>
<h1 id="2-检索文档"><a href="#2-检索文档" class="headerlink" title="2. 检索文档"></a>2. 检索文档</h1><p>格式:</p>
<pre><code>GET /index/type/id</code></pre><p>输入:</p>
<pre><code>GET /person/chinese/1</code></pre><p>输出:</p>
<pre><code>{
  &quot;_index&quot;: &quot;person&quot;,
  &quot;_type&quot;: &quot;chinese&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 1,
  &quot;found&quot;: true,
  &quot;_source&quot;: {
    &quot;id&quot;: 12345,
    &quot;name&quot;: &quot;lujiahao&quot;,
    &quot;age&quot;: 18
  }
}</code></pre><h1 id="3-更新文档"><a href="#3-更新文档" class="headerlink" title="3. 更新文档"></a>3. 更新文档</h1><h2 id="3-1-替换方式"><a href="#3-1-替换方式" class="headerlink" title="3.1 替换方式"></a>3.1 替换方式</h2><p>格式:</p>
<pre><code>PUT /index/type/id
{
    &quot;json数据&quot;
}</code></pre><p>输入:</p>
<pre><code>PUT /person/chinese/1
{
  &quot;name&quot;:&quot;lujiahao123&quot;
}</code></pre><p>输出:</p>
<pre><code>{
  &quot;_index&quot;: &quot;person&quot;,
  &quot;_type&quot;: &quot;chinese&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 2,
  &quot;result&quot;: &quot;updated&quot;,
  &quot;_shards&quot;: {
    &quot;total&quot;: 2,
    &quot;successful&quot;: 1,
    &quot;failed&quot;: 0
  },
  &quot;created&quot;: false
}</code></pre><p>查询:</p>
<pre><code>{
  &quot;_index&quot;: &quot;person&quot;,
  &quot;_type&quot;: &quot;chinese&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 2,
  &quot;found&quot;: true,
  &quot;_source&quot;: {
    &quot;name&quot;: &quot;lujiahao123&quot;
  }
}</code></pre><blockquote>
<p>替换方式更新文档时，必须带上所有的field，才能去进行信息的修改；如果缺少field就会丢失部分数据。其原理时替换，因此需要全部字段。不推荐此种方式更新文档。</p>
</blockquote>
<h2 id="3-1-更新方式"><a href="#3-1-更新方式" class="headerlink" title="3.1 更新方式"></a>3.1 更新方式</h2><p>格式:</p>
<pre><code>POST /index/type/id/_update
{
    &quot;doc&quot;:{
        &quot;json数据&quot;
    }
}</code></pre><p>输入:</p>
<pre><code>POST /person/chinese/1/_update
{
  &quot;doc&quot;:{
    &quot;name&quot;:&quot;lujiahao10010&quot;
  }
}</code></pre><p>输出:</p>
<pre><code>{
  &quot;_index&quot;: &quot;person&quot;,
  &quot;_type&quot;: &quot;chinese&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 4,
  &quot;result&quot;: &quot;updated&quot;,
  &quot;_shards&quot;: {
    &quot;total&quot;: 2,
    &quot;successful&quot;: 1,
    &quot;failed&quot;: 0
  },
  &quot;created&quot;: false
}</code></pre><p>再次查询：</p>
<pre><code>{
  &quot;_index&quot;: &quot;person&quot;,
  &quot;_type&quot;: &quot;chinese&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 6,
  &quot;found&quot;: true,
  &quot;_source&quot;: {
    &quot;id&quot;: 12345,
    &quot;name&quot;: &quot;lujiahao10010&quot;,
    &quot;age&quot;: 18
  }
}</code></pre><h1 id="4-删除文档"><a href="#4-删除文档" class="headerlink" title="4. 删除文档"></a>4. 删除文档</h1><p>格式:</p>
<pre><code>DELETE /index/type/id/_update
{
    &quot;doc&quot;:{
        &quot;json数据&quot;
    }
}</code></pre><p>输入:</p>
<pre><code>DELETE /person/chinese/1</code></pre><p>输出:</p>
<pre><code>{
  &quot;found&quot;: true,
  &quot;_index&quot;: &quot;person&quot;,
  &quot;_type&quot;: &quot;chinese&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 7,
  &quot;result&quot;: &quot;deleted&quot;,
  &quot;_shards&quot;: {
    &quot;total&quot;: 2,
    &quot;successful&quot;: 1,
    &quot;failed&quot;: 0
  }
}</code></pre><p>再次查询:</p>
<pre><code>{
  &quot;_index&quot;: &quot;person&quot;,
  &quot;_type&quot;: &quot;chinese&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;found&quot;: false
}</code></pre><h1 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h1><p>本文所有操作都是在kibana的Dev tools中进行的，相较于Elasticsearch-Heade插件，kibana中更加方便与美观（个人观点），推荐大家使用。</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>本文同步发表在公众号，欢迎大家关注！😁<br>后续笔记欢迎关注获取第一时间更新！<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-04-14T11:34:52.000Z" title="2019-04-14T11:34:52.000Z">2019-04-14</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">2 分钟 读完 (大约 320 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/7251e71b.html">《Elasticsearch技术解析与实战》Chapter 1.2 Elasticsearch安装</a></h1><div class="content"><h1 id="1-下载安装"><a href="#1-下载安装" class="headerlink" title="1. 下载安装"></a>1. 下载安装</h1><h2 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.elastic.co/downloads/elasticsearch</span><br><span class="line">下载 https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.7.0.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2 解压"></a>1.2 解压</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf elasticsearch-6.7.0.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="1-3-运行"><a href="#1-3-运行" class="headerlink" title="1.3 运行"></a>1.3 运行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd elasticsearch-6.7.0</span><br><span class="line">bin/elasticsearch</span><br></pre></td></tr></table></figure>

<h2 id="1-4-检验"><a href="#1-4-检验" class="headerlink" title="1.4 检验"></a>1.4 检验</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9200  或者浏览器访问</span><br><span class="line">&#123;</span><br><span class="line">    "name": "q9sdES9",</span><br><span class="line">    "cluster_name": "docker-cluster",</span><br><span class="line">    "cluster_uuid": "6klEi4d0Q6y0LC3YNYVXTQ",</span><br><span class="line">    "version": &#123;</span><br><span class="line">        "number": "5.5.0",</span><br><span class="line">        "build_hash": "260387d",</span><br><span class="line">        "build_date": "2017-06-30T23:16:05.735Z",</span><br><span class="line">        "build_snapshot": false,</span><br><span class="line">        "lucene_version": "6.6.0"</span><br><span class="line">    &#125;,</span><br><span class="line">    "tagline": "You Know, for Search"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-Docker部署"><a href="#2-Docker部署" class="headerlink" title="2. Docker部署"></a>2. Docker部署</h1><blockquote>
<p>官方文档 : <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html</a></p>
</blockquote>
<h2 id="2-1-拉取镜像"><a href="#2-1-拉取镜像" class="headerlink" title="2.1 拉取镜像"></a>2.1 拉取镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.elastic.co/elasticsearch/elasticsearch:5.5.1</span><br></pre></td></tr></table></figure>

<h2 id="2-2-启动容器"><a href="#2-2-启动容器" class="headerlink" title="2.2 启动容器"></a>2.2 启动容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9200:9200 9300:9300 -e "http.host=0.0.0.0" -e “transport.host=0.0.0.0" --name elasticsearch_5.5.0 -d docker.elastic.co/elasticsearch/elasticsearch:5.5.0</span><br></pre></td></tr></table></figure>

<h2 id="2-3-修改配置"><a href="#2-3-修改配置" class="headerlink" title="2.3 修改配置"></a>2.3 修改配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进入到容器中 : docker exec -it elasticsearch_5.5.0 /bin/bash</span><br><span class="line">修改jvm配置 : vi /config/jvm.options</span><br><span class="line">            -Xms2g  —&gt;  -Xms512m</span><br><span class="line">            -Xmx2g  —&gt;  -Xmx512m</span><br><span class="line">    修改小一些,服务器内存有限😂</span><br></pre></td></tr></table></figure>

<h2 id="2-4-重启容器-查看是否成功"><a href="#2-4-重启容器-查看是否成功" class="headerlink" title="2.4 重启容器,查看是否成功"></a>2.4 重启容器,查看是否成功</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http://服务器ip:9200</span><br><span class="line">&#123;</span><br><span class="line">    "name": "q9sdES9",</span><br><span class="line">    "cluster_name": "docker-cluster",</span><br><span class="line">    "cluster_uuid": "6klEi4d0Q6y0LC3YNYVXTQ",</span><br><span class="line">    "version": &#123;</span><br><span class="line">        "number": "5.5.0",</span><br><span class="line">        "build_hash": "260387d",</span><br><span class="line">        "build_date": "2017-06-30T23:16:05.735Z",</span><br><span class="line">        "build_snapshot": false,</span><br><span class="line">        "lucene_version": "6.6.0"</span><br><span class="line">    &#125;,</span><br><span class="line">    "tagline": "You Know, for Search"</span><br><span class="line">&#125;</span><br><span class="line">此处集群的名称为 docker-cluster, 可以自行修改 : vi /config/elasticsearch.yml</span><br></pre></td></tr></table></figure>

<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>本文同步发表在公众号，欢迎大家关注！😁<br>后续笔记欢迎关注获取第一时间更新！<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-04-12T11:34:52.000Z" title="2019-04-12T11:34:52.000Z">2019-04-12</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">19 分钟 读完 (大约 2874 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/864b09eb.html">《Elasticsearch技术解析与实战》Chapter 1.1：Elasticsearch入门和倒排索引</a></h1><div class="content"><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Elasticsearch是一个机遇Lucene构建的开源、分布式、RESTful接口全文搜索引擎。同时，Elasticsearch还是一个分布式文档数据库，能够扩展至数百个服务器存储以处理PB级数据，通常作为复杂搜索场景的首选利器。</p>
<p>Elasticsearch的优点：</p>
<ol>
<li>横向可扩展性：只需要增加一台服务器，配置完毕即可加入集群。</li>
<li>分片机制提供更好的分布性：同一个索引分成多个分片，类似于HDFS的块机制，分而治之的方式提升处理效率。</li>
<li>高可用：提供复制机制，一个分片可以设置多个副本，在某台服务器宕机情况下，集群依旧可以工作，并在宕机服务器重启后恢复数据。</li>
<li>使用简单：开箱即用，快速搭建搜索服务。</li>
</ol>
<p><a href="https://zh.wikipedia.org/wiki/Elasticsearch">Elasticsearch wiki:https://zh.wikipedia.org/wiki/Elasticsearch</a></p>
<h1 id="2-数据库搜索"><a href="#2-数据库搜索" class="headerlink" title="2. 数据库搜索"></a>2. 数据库搜索</h1><p>在数据量少的情况下可以当做搜索服务来使用，然而数据库归根结底是做持久化存储。如果数据量大就需要做搜索服务，底层数据还是关系数据库。我司老系统中有一个订单表，数据量已经高达两亿，客服等后台系统通常带有范围或批量条件等查询，这时数据库基本上就无法响应了，报警根本停不下来。因此，用数据库来实现搜索，性能差，可用性不高。</p>
<h1 id="3-Lucene"><a href="#3-Lucene" class="headerlink" title="3. Lucene"></a>3. Lucene</h1><p>Lucene是一个开源的全文搜索引擎工具包，其目的是为开发者提供一个简单工具包，以快速实现全文检索的功能。</p>
<p><a href="https://zh.wikipedia.org/wiki/Lucene">Lucene wiki:https://zh.wikipedia.org/wiki/Lucene</a></p>
<h1 id="4-倒排索引"><a href="#4-倒排索引" class="headerlink" title="4. 倒排索引"></a>4. 倒排索引</h1><p>倒排索引中的索引对象是文档或者文档集合中的单词等，用来存储这些单词在一个文档或者一组文档中的存储位置，是对文档或者文档集合的一种最常用的索引机制。搜索引擎的关键步骤就是建立倒排索引，下面介绍Lucene是如何建立倒排索引和相应的生成算法。</p>
<blockquote>
<p>假设有两篇文章：<br>文章1：Tom lives in Guangzhou, I live in Guangzhou too.<br>文章2：He once lived in Shanghai.</p>
</blockquote>
<h2 id="4-1-取得关键词"><a href="#4-1-取得关键词" class="headerlink" title="4.1 取得关键词"></a>4.1 取得关键词</h2><p>Lucene是基于关键词索引和查询的，首先要进行关键词提取：</p>
<ul>
<li><p>分词：英文单词由空格分隔，较好处理；中文词语由于是连在一起的，需要进行特殊的分词处理（后面会介绍分词器相关知识）。</p>
</li>
<li><p>过滤无概念词语：英文中“in”“once”“too”等词没有实际意义；中文中“的”“是”等也无实际意义，这些无概念词语可以过滤掉。</p>
</li>
<li><p>统一大小写：“he”和“HE”表示的含义一样，所以单词需要统一大小写。</p>
</li>
<li><p>语义还原：通常用户查询“live”时希望能将“lives”和“lived”也查询出来，所以需要将“lives”和“lived”还原成“live”。</p>
</li>
<li><p>过滤标点符号</p>
<p>  经过以上过滤，得到如下结果：<br>  文章1关键词：tom live guangzhou i live guangzhou<br>  文章2关键词：he live shanghai</p>
</li>
</ul>
<h2 id="4-2-建立倒排索引"><a href="#4-2-建立倒排索引" class="headerlink" title="4.2 建立倒排索引"></a>4.2 建立倒排索引</h2><p>关键词建立完成后，就可以进行倒排索引建立了。过滤后的关系是：“文章号“对”文章中所有关键词“，倒排索引把这个关系倒过来变成：”关键词“对”拥有关键词的所有文章号“。</p>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/%E3%80%8AElasticsearch%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B/Chapter%201%EF%BC%9AElasticsearch%E5%85%A5%E9%97%A8/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%951.png" alt=""></p>
<p>通常仅知道关键词在哪些文章中出现还不够，还需要知道关键词在文章中出现的次数和位置，通常有两种位置：</p>
<ol>
<li>字符位置，即记录该词是文章中第几个字符（优点是显示并定位关键词快）。</li>
<li>关键词位置，即记录该词是文章中的第几个关键词（优点是节约索引空间、词组查询快），Lucene中记录的就是这种位置。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/%E3%80%8AElasticsearch%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B/Chapter%201%EF%BC%9AElasticsearch%E5%85%A5%E9%97%A8/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%952.png" alt=""></p>
<p>以上就是Lucene索引结构中最核心的部分，关键字是按字符顺序排列的（Lucene没有使用B树结构），因此Lucene可以使用二元搜索算法快速定位关键词。</p>
<h2 id="4-3-实现"><a href="#4-3-实现" class="headerlink" title="4.3 实现"></a>4.3 实现</h2><p>Lucene将上面三列分别作为词典文件（Term Dictionary）、频率文件（frequencies）、位置文件（positions）保存。其中词典文件不仅保存了每个关键词，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息。</p>
<p>Lucene中使用了field的概念，用于表达信息所在的位置（如标题中、文章中、url中），在建索引中，该field信息也记录在词典文件中，每个关键词都有一个field信息，因为每个关键字一定属于一个或多个field。</p>
<h2 id="4-4-压缩算法"><a href="#4-4-压缩算法" class="headerlink" title="4.4 压缩算法"></a>4.4 压缩算法</h2><p>为了减小索引文件的大小，Lucene对索引还是用了压缩技术。<br>首先，对词典文件中的关键词进行压缩，关键词压缩为&lt;前缀长度,后缀&gt;，例如：当前词为”阿拉伯语“，上一个词为”阿拉伯“,那么”阿拉伯语“压缩为&lt;3,语&gt;。<br>其次大量用到的是对数字的压缩，数字只保存与上一个值的差值（这样可以减少数字的长度，进而减少保存该数字需要的字节数）。例如当前文章号是16389（不压缩要用3个字节），上一文章号是16382，压缩后保存7（只用一个字节）。</p>
<p><a href="https://www.cnblogs.com/dreamroute/p/8484457.html">压缩算法推荐阅读:https://www.cnblogs.com/dreamroute/p/8484457.html</a></p>
<h2 id="4-5-实战"><a href="#4-5-实战" class="headerlink" title="4.5 实战"></a>4.5 实战</h2><p>查询单词”live“，Lucene先对词典二元查找，找到该词，通过指向频率文件的指针读出所有文章号，然后返回结果。词典通常非常小，可以达到毫秒级返回。而用普通的顺序匹配算法，不建立索引，而是对所有文章的内容进行字符串匹配，过程是很缓慢的，当数据量很大时，耗时更加严重。</p>
<h1 id="5-基础概念"><a href="#5-基础概念" class="headerlink" title="5. 基础概念"></a>5. 基础概念</h1><h2 id="5-1-索引词（term）"><a href="#5-1-索引词（term）" class="headerlink" title="5.1 索引词（term）"></a>5.1 索引词（term）</h2><p>Elasticsearch中能够被索引的精确值。foo、Foo、FOO几个单词是不同的索引词。索引词可以通过term查询进行准确的搜索。</p>
<h2 id="5-2-文本（text）"><a href="#5-2-文本（text）" class="headerlink" title="5.2 文本（text）"></a>5.2 文本（text）</h2><p>文本会被拆分成一个个索引词存储在索引库中，为后续搜索提供支持。</p>
<h2 id="5-3-分析（analysis）"><a href="#5-3-分析（analysis）" class="headerlink" title="5.3 分析（analysis）"></a>5.3 分析（analysis）</h2><p>分析是将文本转换为索引词的过程，其结果依赖于分词器。</p>
<h2 id="5-4-集群（cluster）"><a href="#5-4-集群（cluster）" class="headerlink" title="5.4 集群（cluster）"></a>5.4 集群（cluster）</h2><p>集群由一个或多个节点组成，对外提供服务。Elasticsearch节点如果有相同的集群名称会自动加入到同一个集群，因此如果你拥有多个独立集群，每个集群都要设置不同的名称。</p>
<h2 id="5-5-节点（node）"><a href="#5-5-节点（node）" class="headerlink" title="5.5 节点（node）"></a>5.5 节点（node）</h2><p>节点是一个逻辑上独立的服务，是集群的一部分，可以存储数据，并参与集群的索引和搜索功能。</p>
<h2 id="5-6-路由（routing）"><a href="#5-6-路由（routing）" class="headerlink" title="5.6 路由（routing）"></a>5.6 路由（routing）</h2><p>文档存储时是通过散列值进行计算，最终选择存储在主分片中，这个值默认是由文档的ID生成。</p>
<h2 id="5-7-分片（shard）"><a href="#5-7-分片（shard）" class="headerlink" title="5.7 分片（shard）"></a>5.7 分片（shard）</h2><p>分片是单个Lucene实例，是Elasticsearch管理的比较底层的功能。当索引占用空间很大超过一个节点的物理存储，Elasticsearch将索引切分成多个分片，分散在不同的物理节点上，以解决单物理节点存储空间有限的问题。</p>
<h2 id="5-8-主分片（primary-shard）"><a href="#5-8-主分片（primary-shard）" class="headerlink" title="5.8 主分片（primary shard）"></a>5.8 主分片（primary shard）</h2><p>每个文档都存储在一个分片中，存储文档时系统会首先存储在主分片中，然后复制到不同的副本中。默认情况下一个索引拥有5个主分片，分片一旦建立，主分片数量就无法修改。</p>
<h2 id="5-9-副本分片（replica-shard）"><a href="#5-9-副本分片（replica-shard）" class="headerlink" title="5.9 副本分片（replica shard）"></a>5.9 副本分片（replica shard）</h2><p>每个主分片有零个或多个副本，是主分片的复制，其主要目的是：</p>
<ol>
<li>增加高可用性：当主分片失败时，某一副本分片提升为主分片</li>
<li>提高性能：副本分片数量可以动态配置，可以为主分片分担查询压力。</li>
<li>允许水平分割扩展数据</li>
<li>允许分配和并行操作，从而提高性能和吞吐量。</li>
</ol>
<h2 id="5-10-复制（replica）"><a href="#5-10-复制（replica）" class="headerlink" title="5.10 复制（replica）"></a>5.10 复制（replica）</h2><p>主分片的数据会复制到副本分片中，这样避免了单点问题，当某个节点发生故障，复制可以对故障进行转移，保证系统的高可用。</p>
<h2 id="5-11-索引（index）"><a href="#5-11-索引（index）" class="headerlink" title="5.11 索引（index）"></a>5.11 索引（index）</h2><p>索引是具有相同结构的文档合集。</p>
<h2 id="5-12-类型（type）"><a href="#5-12-类型（type）" class="headerlink" title="5.12 类型（type）"></a>5.12 类型（type）</h2><p>一个索引可以定义一个或多个类型，类型是索引的逻辑分区。</p>
<h2 id="5-13-文档（document）"><a href="#5-13-文档（document）" class="headerlink" title="5.13 文档（document）"></a>5.13 文档（document）</h2><p>文档是存储在Elasticsearch中的一个JSON格式的字符串，就像关系数据库中表的一行记录。</p>
<h2 id="5-14-映射（mapping）"><a href="#5-14-映射（mapping）" class="headerlink" title="5.14 映射（mapping）"></a>5.14 映射（mapping）</h2><p>映射像关系数据库中的表结构，每个索引都有一个映射，它定义了索引中的每一个字段类型。映射可以事先被定义，也可以在第一次存储文档时被自动识别。</p>
<h2 id="5-15-字段（field）"><a href="#5-15-字段（field）" class="headerlink" title="5.15 字段（field）"></a>5.15 字段（field）</h2><p>文档中包含零个或多个字段，字段可以是一个简单的值，也可以是一个数组或对象的嵌套结构。字段类似于关系数据库中表的列，每个字段都对应一个字段类型。</p>
<h2 id="5-16-来源字段（source-field）"><a href="#5-16-来源字段（source-field）" class="headerlink" title="5.16 来源字段（source field）"></a>5.16 来源字段（source field）</h2><p>默认情况下源文档将被存储在_source字段中，查询时返回该字段。</p>
<h2 id="5-17-主键（ID）"><a href="#5-17-主键（ID）" class="headerlink" title="5.17 主键（ID）"></a>5.17 主键（ID）</h2><p>ID是文件的唯一标识，如果未指定，系统会自动生成一个ID，文档的index/type/id必须是唯一的。</p>
<h2 id="5-18-Elasticsearch核心概念-vs-数据库核心概念"><a href="#5-18-Elasticsearch核心概念-vs-数据库核心概念" class="headerlink" title="5.18 Elasticsearch核心概念 vs. 数据库核心概念"></a>5.18 Elasticsearch核心概念 vs. 数据库核心概念</h2><table>
<thead>
<tr>
<th>Elasticsearch</th>
<th>数据库</th>
</tr>
</thead>
<tbody><tr>
<td>Document</td>
<td>row 行</td>
</tr>
<tr>
<td>Type</td>
<td>table 表</td>
</tr>
<tr>
<td>Index</td>
<td>database 库</td>
</tr>
</tbody></table>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>本文同步发表在公众号，欢迎大家关注！😁<br>后续笔记欢迎关注获取第一时间更新！<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-26T11:34:52.000Z" title="2019-03-26T11:34:52.000Z">2019-03-26</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">27 分钟 读完 (大约 3983 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/33416609.html">《Java 8 in Action》Chapter 12：新的日期和时间API</a></h1><div class="content"><ul>
<li>在Java 1.0中，对日期和时间的支持只能依赖java.util.Date类。同时这个类还有两个很大的缺点：年份的起始选择是1900年，月份的起始从0开始。</li>
<li>在Java 1.1中，Date类中的很多方法被废弃，取而代之的是java.util.Calendar类。然而Calendar类也有类似的问题和设计缺陷，导致使用这些方法写出的代码非常容易出错。</li>
</ul>
<blockquote>
<p>DateFormat方法也有它自己的问题。比如，它不是线程安全的。这意味着两个线程如果尝试使用同一个formatter解析日期，你可能会得到无法预期的结果。</p>
</blockquote>
<h1 id="1-使用LocalDate-和LocalTime"><a href="#1-使用LocalDate-和LocalTime" class="headerlink" title="1. 使用LocalDate 和LocalTime"></a>1. 使用LocalDate 和LocalTime</h1><h2 id="1-1-LocalDate"><a href="#1-1-LocalDate" class="headerlink" title="1.1 LocalDate"></a>1.1 LocalDate</h2><p>Java 8提供新的日期和时间API,LocalDate类实例是一个不可变对象，只提供简单的日期并且不含当天时间信息。此外也不附带任何与时区相关的信息。</p>
<p>通过静态工厂方法of创建一个LocalDate实例。LocalDate实例提供了多种方法来读取常用的值，比如年份、月份、星期几等，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">int</span> year = localDate.getYear();</span><br><span class="line">Month month = localDate.getMonth();</span><br><span class="line"><span class="keyword">int</span> day = localDate.getDayOfMonth();</span><br><span class="line">DayOfWeek dow = localDate.getDayOfWeek();</span><br><span class="line"><span class="keyword">int</span> len = localDate.lengthOfMonth();</span><br><span class="line"><span class="keyword">boolean</span> leap = localDate.isLeapYear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用工厂方法从系统时钟中获取当前的日期</span></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line"></span><br><span class="line">System.out.println(String.format(<span class="string">"year:%s\nmonth:%s\nday:%s\ndow:%s\nlen:%s\nleap:%s"</span>, year, month, day, dow, len, leap));</span><br><span class="line">System.out.println(today);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">year:<span class="number">2014</span></span><br><span class="line">month:MARCH</span><br><span class="line">day:<span class="number">18</span></span><br><span class="line">dow:TUESDAY</span><br><span class="line">len:<span class="number">31</span></span><br><span class="line">leap:<span class="keyword">false</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">27</span></span><br></pre></td></tr></table></figure>

<p>Java 8日期-时间类都提供了类似的工厂方法。通过传递TemporalField参数给get方法拿到同样的信息。TemporalField接口定义了如何访问temporal对象某个字段的值。ChronoField枚举实现TemporalField接口,可以使用get方法得到枚举元素的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> year = localDate.get(ChronoField.YEAR);</span><br><span class="line"><span class="keyword">int</span> month = localDate.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line"><span class="keyword">int</span> day = localDate.get(ChronoField.DAY_OF_MONTH);</span><br></pre></td></tr></table></figure>

<h2 id="1-2-LocalTime"><a href="#1-2-LocalTime" class="headerlink" title="1.2 LocalTime"></a>1.2 LocalTime</h2><p>使用LocalTime类表示时间,可以使用of重载的两个工厂方法创建LocalTime的实例。</p>
<ul>
<li>第一个重载函数接收小时和分钟</li>
<li>第二个重载函数同时还接收秒。</li>
</ul>
<p>LocalTime类也提供了一些get方法访问这些变量的值，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.of(<span class="number">13</span>, <span class="number">45</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span> hour = localTime.getHour();</span><br><span class="line"><span class="keyword">int</span> minute = localTime.getMinute();</span><br><span class="line"><span class="keyword">int</span> second = localTime.getSecond();</span><br><span class="line">System.out.println(String.format(<span class="string">"hour:%s\nminute:%s\nsecond:%s"</span>, hour, minute, second));</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">hour:<span class="number">13</span></span><br><span class="line">minute:<span class="number">45</span></span><br><span class="line">second:<span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>LocalDate和LocalTime都可以通过解析代表它们的字符串创建。使用静态方法parse可以实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.parse(<span class="string">"2019-03-27"</span>);</span><br><span class="line">LocalTime time = LocalTime.parse(<span class="string">"20:17:08"</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以向parse方法传递一个DateTimeFormatter。该类的实例定义了如何格式化一个日期或者时间对象。用来替换老版java.util.DateFormat。<br>如果传递的字符串参数无法被解析为合法的LocalDate或LocalTime对象，这两个parse方法都会抛出一个继承自RuntimeException的DateTimeParseException异常。</p>
</blockquote>
<h1 id="2-合并日期和时间"><a href="#2-合并日期和时间" class="headerlink" title="2. 合并日期和时间"></a>2. 合并日期和时间</h1><p>复合类LocalDateTime，是LocalDate和LocalTime的合体。它同时表示了日期和时间，不带有时区信息。可以直接创建，也可以通过合并日期和时间对象构造。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LocalTime time = LocalTime.of(<span class="number">21</span>, <span class="number">31</span>, <span class="number">50</span>);</span><br><span class="line">LocalDate date = LocalDate.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">27</span>);</span><br><span class="line"></span><br><span class="line">LocalDateTime dt1 = LocalDateTime.of(<span class="number">2017</span>, Month.NOVEMBER, <span class="number">07</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">51</span>);</span><br><span class="line">LocalDateTime dt2 = LocalDateTime.of(date, time);</span><br><span class="line">LocalDateTime dt3 = date.atTime(<span class="number">22</span>, <span class="number">21</span>, <span class="number">14</span>);</span><br><span class="line">LocalDateTime dt4 = date.atTime(time);</span><br><span class="line">LocalDateTime dt5 = time.atDate(date);</span><br></pre></td></tr></table></figure>

<p>创建LocalDateTime对象</p>
<ul>
<li>直接创建</li>
<li>通过atTime方法向LocalDate传递一个时间对象</li>
<li>通过atDate方法向LocalTime传递一个时间对象</li>
</ul>
<p>也可以使用toLocalDate或者toLocalTime方法，从LocalDateTime中提取LocalDate或者LocalTime组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date1 = dt1.toLocalDate();</span><br><span class="line">LocalTime time1 = dt1.toLocalTime();</span><br></pre></td></tr></table></figure>

<h1 id="3-机器的日期和时间格式"><a href="#3-机器的日期和时间格式" class="headerlink" title="3. 机器的日期和时间格式"></a>3. 机器的日期和时间格式</h1><p>从计算机的角度来看，”2019年03月27日11:20:03”这样的方式是不容易理解的,计算机更加容易理解建模时间最自然的格式是表示一个持续时间段上某个点的单一大整型数。新的java.time.Instant类对时间建模的方式，基本上它是以Unix元年时间（传统的设定为UTC时区1970年1月1日午夜时分）开始所经历的秒数进行计算。</p>
<h2 id="3-1-创建Instant"><a href="#3-1-创建Instant" class="headerlink" title="3.1 创建Instant"></a>3.1 创建Instant</h2><ul>
<li>静态工厂方法ofEpochSecond传递一个代表秒数的值创建一个该类的实例。</li>
<li>静态工厂方法ofEpochSecond还有一个增强的重载版本，它接收第二个以纳秒为单位的参数值，对传入作为秒数的参数进行调整。重载的版本会调整纳秒参数，确保保存的纳秒分片在0到999 999999之间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instant.ofEpochSecond(<span class="number">3</span>);</span><br><span class="line">Instant.ofEpochSecond(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2 秒之后再加上100万纳秒（1秒）</span></span><br><span class="line">Instant.ofEpochSecond(<span class="number">2</span>, <span class="number">1_000_000_000</span>);</span><br><span class="line"><span class="comment">// 4秒之前的100万纳秒（1秒）</span></span><br><span class="line">Instant.ofEpochSecond(<span class="number">4</span>, -<span class="number">1_000_000_000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-2-工厂方法now"><a href="#3-2-工厂方法now" class="headerlink" title="3.2 工厂方法now"></a>3.2 工厂方法now</h2><p>Instant类也支持静态工厂方法now，它能够获取当前时刻的时间戳。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Instant now = Instant.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">27</span>T03:<span class="number">26</span>:<span class="number">39.451</span>Z</span><br></pre></td></tr></table></figure>

<p>Instant的设计初衷是为了便于机器使用,它包含的是由秒及纳秒所构成的数字。因此Instant无法处理那些我们非常容易理解的时间单位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> day = Instant.now().get(ChronoField.DAY_OF_MONTH);</span><br><span class="line">它会抛出下面这样的异常：</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.time.temporal.UnsupportedTemporalTypeException: Unsupported field: DayOfMonth</span><br><span class="line">但是你可以通过Duration和Period类使用Instant，接下来我们会对这部分内容进行介绍。</span><br></pre></td></tr></table></figure>

<h2 id="4-Duration和Period"><a href="#4-Duration和Period" class="headerlink" title="4. Duration和Period"></a>4. Duration和Period</h2><h2 id="4-1-Duration"><a href="#4-1-Duration" class="headerlink" title="4.1 Duration"></a>4.1 Duration</h2><p>所有类都实现了Temporal接口，该接口定义如何读取和操纵为时间建模的对象的值。如果需要创建两个Temporal对象之间的duration,就需要Duration类的静态工厂方法between。<br>可以创建两个LocalTimes对象、两个LocalDateTimes对象，或者两个Instant对象之间的duration：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LocalTime time1 = LocalTime.of(<span class="number">21</span>, <span class="number">50</span>, <span class="number">10</span>);</span><br><span class="line">LocalTime time2 = LocalTime.of(<span class="number">22</span>, <span class="number">50</span>, <span class="number">10</span>);</span><br><span class="line">LocalDateTime dateTime1 = LocalDateTime.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">20</span>, <span class="number">40</span>);</span><br><span class="line">LocalDateTime dateTime2 = LocalDateTime.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">20</span>, <span class="number">40</span>);</span><br><span class="line">Instant instant1 = Instant.ofEpochSecond(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>);</span><br><span class="line">Instant instant2 = Instant.ofEpochSecond(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Duration d1 = Duration.between(time1, time2);</span><br><span class="line">Duration d2 = Duration.between(dateTime1, dateTime2);</span><br><span class="line">Duration d3 = Duration.between(instant1, instant2);</span><br><span class="line"><span class="comment">// PT1H 相差1小时</span></span><br><span class="line">System.out.println(<span class="string">"d1:"</span> + d1);</span><br><span class="line"><span class="comment">// PT2H 相差2小时</span></span><br><span class="line">System.out.println(<span class="string">"d2:"</span> + d2);</span><br><span class="line"><span class="comment">// PT16H40M 相差16小时40分钟</span></span><br><span class="line">System.out.println(<span class="string">"d3:"</span> + d3);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>LocalDateTime是为了便于人阅读使用，Instant是为了便于机器处理，所以不能将二者混用。如果在这两类对象之间创建duration，会触发一个DateTimeException异常。<br>此外，由于Duration类主要用于以秒和纳秒衡量时间的长短，你不能仅向between方法传递一个LocalDate对象做参数。</p>
</blockquote>
<h2 id="4-2-Period"><a href="#4-2-Period" class="headerlink" title="4.2 Period"></a>4.2 Period</h2><p>使用Period类以年、月或者日的方式对多个时间单位建模。使用该类的工厂方法between，可以使用得到两个LocalDate之间的时长。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Period period = Period.between(LocalDate.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">7</span>), LocalDate.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">17</span>));</span><br><span class="line"><span class="comment">// 相差10天</span></span><br><span class="line">System.out.println(<span class="string">"Period between:"</span> + period);</span><br></pre></td></tr></table></figure>

<p>Duration和Period类都提供了很多非常方便的工厂类，直接创建对应的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Duration threeMinutes = Duration.ofMinutes(<span class="number">3</span>);</span><br><span class="line">Duration fourMinutes = Duration.of(<span class="number">4</span>, ChronoUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">Period tenDay = Period.ofDays(<span class="number">10</span>);</span><br><span class="line">Period threeWeeks = Period.ofWeeks(<span class="number">3</span>);</span><br><span class="line">Period twoYearsSixMonthsOneDay = Period.of(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">Duration类和Period类共享了很多相似的方法，有兴趣的可以参考官网的文档。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>截至目前，我们介绍的这些日期-时间对象都是不可修改的，这是为了更好地支持函数式编程，确保线程安全，保持领域模式一致性而做出的重大设计决定。<br>当然，新的日期和时间API也提供了一些便利的方法来创建这些对象的可变版本。比如，你可能希望在已有的LocalDate实例上增加3天。除此之外，我们还会介绍如何依据指定的模式，<br>比如dd/MM/yyyy，创建日期-时间格式器，以及如何使用这种格式器解析和输出日期。</p>
</blockquote>
<h1 id="5-操纵、解析和格式化日期"><a href="#5-操纵、解析和格式化日期" class="headerlink" title="5. 操纵、解析和格式化日期"></a>5. 操纵、解析和格式化日期</h1><p>如果已经有一个LocalDate对象，想要创建它的一个修改版，最直接也最简单的方法是使用withAttribute方法。withAttribute方法会创建对象的一个副本，并按照需要修改它的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这段代码中所有的方法都返回一个修改了属性的对象。它们都不会修改原来的对象！</span></span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2017</span>, <span class="number">12</span>, <span class="number">15</span>);</span><br><span class="line">LocalDate date2 = date1.withYear(<span class="number">2019</span>);</span><br><span class="line">LocalDate date3 = date2.withDayOfMonth(<span class="number">25</span>);</span><br><span class="line">LocalDate date4 = date3.with(ChronoField.MONTH_OF_YEAR, <span class="number">9</span>);</span><br></pre></td></tr></table></figure>

<p>它们都声明于Temporal接口，所有的日期和时间API类都实现这两个方法，它们定义了单点的时间，比如LocalDate、LocalTime、LocalDateTime以及Instant。更确切地说，使用get和with方法，我们可以将Temporal对象值的读取和修改区分开。如果Temporal对象不支持请求访问的字段，它会抛出一个UnsupportedTemporalTypeException异常，比如试图访问Instant对象的ChronoField.MONTH_OF_YEAR字段，或者LocalDate对象的ChronoField.NANO_OF_SECOND字段时都会抛出这样的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以声明的方式操纵LocalDate对象,可以加上或者减去一段时间</span></span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">10</span>, <span class="number">19</span>);</span><br><span class="line">LocalDate date2 = date1.plusWeeks(<span class="number">1</span>);</span><br><span class="line">LocalDate date3 = date2.minusYears(<span class="number">3</span>);</span><br><span class="line">LocalDate date4 = date3.plus(<span class="number">6</span>, ChronoUnit.MONTHS);</span><br></pre></td></tr></table></figure>

<p>与我们刚才介绍的get和with方法类似最后一行使用的plus方法也是通用方法，它和minus方法都声明于Temporal接口中。通过这些方法，对TemporalUnit对象加上或者减去一个数字，我们能非常方便地将Temporal对象前溯或者回滚至某个时间段，通过ChronoUnit枚举我们可以非常方便地实现TemporalUnit接口。</p>
<h1 id="6-使用TemporalAdjuster"><a href="#6-使用TemporalAdjuster" class="headerlink" title="6. 使用TemporalAdjuster"></a>6. 使用TemporalAdjuster</h1><p>有时需要进行一些更加复杂的操作，比如，将日期调整到下个周日、下个工作日，或者是本月的最后一天。可以使用重载版本的with方法，向其传递一个提供了更多定制化选择的TemporalAdjuster对象，更加灵活地处理日期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于最常见的用例，日期和时间API已经提供了大量预定义的TemporalAdjuster。可以通过TemporalAdjuster类的静态工厂方法访问。</span></span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2013</span>, <span class="number">12</span>, <span class="number">11</span>);</span><br><span class="line">LocalDate date2 = date1.with(TemporalAdjusters.nextOrSame(DayOfWeek.MONDAY));</span><br><span class="line">LocalDate date3 = date2.with(TemporalAdjusters.lastDayOfMonth());</span><br></pre></td></tr></table></figure>

<p>使用TemporalAdjuster可以进行更加复杂的日期操作，方法的名称很直观。如果没有找到符合预期的预定义的TemporalAdjuster，可以创建自定义的TemporalAdjuster。TemporalAdjuster接口只声明一个方法（即函数式接口）。实现该接口需要定义如何将一个Temporal对象转换为另一个Temporal对象,可以把它看成一个UnaryOperator<Temporal>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TemporalAdjuster</span> </span>&#123;</span><br><span class="line">    <span class="function">Temporal <span class="title">adjustInto</span><span class="params">(Temporal temporal)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="7-打印输出及解析日期-时间对象"><a href="#7-打印输出及解析日期-时间对象" class="headerlink" title="7. 打印输出及解析日期-时间对象"></a>7. 打印输出及解析日期-时间对象</h1><p>新的java.time.format包就是特别为格式化以及解析日期-时间对象而设计的。其中最重要的类是DateTimeFormatter。创建格式器最简单的方法是通过它的静态工厂方法以及常量。所有的DateTimeFormatter实例都能用于以一定的格式创建代表特定日期或时间的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2013</span>, <span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line">String s1 = date.format(DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">String s2 = date.format(DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line"></span><br><span class="line"><span class="number">20131011</span></span><br><span class="line"><span class="number">2013</span>-<span class="number">10</span>-<span class="number">11</span></span><br></pre></td></tr></table></figure>

<p>通过解析代表日期或时间的字符串重新创建该日期对象，也可以使用工厂方法parse重新创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date2 = LocalDate.parse(<span class="string">"20141007"</span>, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate date3 = LocalDate.parse(<span class="string">"2014-10-07"</span>, DateTimeFormatter.ISO_LOCAL_DATE);</span><br></pre></td></tr></table></figure>

<p>DateTimeFormatter实例是线程安全的，老的java.util.DateFormat线程不安全。单例模式创建格式器实例，在多个线程间共享实例是没有问题的。也可以通过ofPattern静态工厂方法，按照某个特定的模式创建格式器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"dd/MM/yyyy"</span>);</span><br><span class="line">String formattedDateStr = date.format(formatter);</span><br><span class="line">LocalDate date1 = LocalDate.parse(formattedDateStr, formatter);</span><br></pre></td></tr></table></figure>

<p>ofPattern方法也提供了一个重载的版本，可以传入Locale创建格式器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter italianFormatter = DateTimeFormatter.ofPattern(<span class="string">"d. MMMM yyyy"</span>, Locale.ITALIAN);</span><br><span class="line">LocalDate date = LocalDate.of(<span class="number">2015</span>, <span class="number">11</span>, <span class="number">14</span>);</span><br><span class="line">String formattedDate = date.format(italianFormatter);</span><br><span class="line">LocalDate date1 = LocalDate.parse(formattedDate, italianFormatter);</span><br></pre></td></tr></table></figure>

<p>DateTimeFormatterBuilder类还提供了更复杂的格式器,以提供更加细粒度的控制。同时也提供非常强大的解析功能，比如区分大小写的解析、柔性解析、填充，以及在格式器中指定可选节等等。</p>
<p>通过DateTimeFormatterBuilder自定义格式器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter italianFormatter = <span class="keyword">new</span> DateTimeFormatterBuilder()</span><br><span class="line">                .appendText(ChronoField.DAY_OF_MONTH)</span><br><span class="line">                .appendLiteral(<span class="string">". "</span>)</span><br><span class="line">                .appendText(ChronoField.MONTH_OF_YEAR)</span><br><span class="line">                .appendLiteral(<span class="string">" "</span>)</span><br><span class="line">                .appendText(ChronoField.YEAR)</span><br><span class="line">                .parseCaseInsensitive()</span><br><span class="line">                .toFormatter(Locale.ITALIAN);</span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">String s = now.format(italianFormatter);</span><br></pre></td></tr></table></figure>

<h1 id="8-处理不同的时区和历法"><a href="#8-处理不同的时区和历法" class="headerlink" title="8. 处理不同的时区和历法"></a>8. 处理不同的时区和历法</h1><p>新版日期和时间API新增加的重要功能是时区的处理。新的java.time.ZoneId类替代老版java.util.TimeZone。跟其他日期和时间类一样，ZoneId类也是无法修改的。是按照一定的规则将区域划分成的标准时间相同的区间。在ZoneRules这个类中包含了40个时区实例,可以通过调用ZoneId的getRules()得到指定时区的规则,每个特定的ZoneId对象都由一个地区ID标识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZoneId shanghaiZone = ZoneId.of(<span class="string">"Asia/Shanghai"</span>);</span><br></pre></td></tr></table></figure>

<p>Java 8的新方法toZoneId将一个老的时区对象转换为ZoneId。地区ID都为“{区域}/{城市}”的格式，地区集合的设定都由英特网编号分配机构（IANA）的时区数据库提供。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZoneId zoneId = TimeZone.getDefault().toZoneId();</span><br></pre></td></tr></table></figure>

<p>ZoneId对象可以与LocalDate、LocalDateTime或者是Instant对象整合构造为成ZonedDateTime实例，它代表了相对于指定时区的时间点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">27</span>);</span><br><span class="line">ZonedDateTime zdt1 = date.atStartOfDay(shanghaiZone);</span><br><span class="line"></span><br><span class="line">LocalDateTime dateTime = LocalDateTime.of(<span class="number">2015</span>, <span class="number">12</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">ZonedDateTime zdt2 = dateTime.atZone(shanghaiZone);</span><br><span class="line"></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">ZonedDateTime zdt3 = instant.atZone(shanghaiZone);</span><br><span class="line">通过ZoneId，你还可以将LocalDateTime转换为Instant：</span><br><span class="line"></span><br><span class="line">LocalDateTime dateTime = LocalDateTime.of(<span class="number">2016</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">35</span>);</span><br><span class="line">Instant instantFromDateTime = dateTime.toInstant(shanghaiZone);</span><br><span class="line">你也可以通过反向的方式得到LocalDateTime对象：</span><br><span class="line"></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">LocalDateTime timeFromInstant = LocalDateTime.ofInstant(instant, shanghaiZone);</span><br></pre></td></tr></table></figure>

<p>另一种比较通用的表达时区的方式是利用当前时区和UTC/格林尼治的固定偏差。使用ZoneId的一个子类ZoneOffset，表示的是当前时间和伦敦格林尼治子午线时间的差异：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZoneOffset newYorkOffset = ZoneOffset.of(<span class="string">"-05:00"</span>);</span><br></pre></td></tr></table></figure>

<h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h1><ul>
<li>Java 8之前老版的java.util.Date类以及其他用于建模日期时间的类有很多不一致及设计上的缺陷，包括易变性以及糟糕的偏移值、默认值和命名。</li>
<li>新版的日期和时间API中，日期-时间对象是不可变的。</li>
<li>新的API提供了两种不同的时间表示方式，有效地区分了运行时人和机器的不同需求。</li>
<li>你可以用绝对或者相对的方式操纵日期和时间，操作的结果总是返回一个新的实例，老的日期时间对象不会发生变化。</li>
<li>TemporalAdjuster让你能够用更精细的方式操纵日期，不再局限于一次只能改变它的一个值，并且你还可按照需求定义自己的日期转换器。</li>
<li>你现在可以按照特定的格式需求，定义自己的格式器，打印输出或者解析日期时间对象。这些格式器可以通过模板创建，也可以自己编程创建，并且它们都是线程安全的。</li>
<li>你可以用相对于某个地区/位置的方式，或者以与UTC/格林尼治时间的绝对偏差的方式表示时区，并将其应用到日期时间对象上，对其进行本地化。</li>
</ul>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-24T11:34:52.000Z" title="2019-03-24T11:34:52.000Z">2019-03-24</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">32 分钟 读完 (大约 4805 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/56cbc3f9.html">《Java 8 in Action》Chapter 11：CompletableFuture：组合式异步编程</a></h1><div class="content"><p>某个网站的数据来自Facebook、Twitter和Google，这就需要网站与互联网上的多个Web服务通信。可是，你并不希望因为等待某些服务的响应，阻塞应用程序的运行，浪费数十亿宝贵的CPU时钟周期。比如，不要因为等待Facebook的数据，暂停对来自Twitter的数据处理。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%85%B8%E5%9E%8B%E6%B7%B7%E8%81%9A%E5%BA%94%E7%94%A8.png" alt=""></p>
<p>第7章中介绍的分支/合并框架以及并行流是实现并行处理的宝贵工具;它们将一个操作切分为多个子操作，在多个不同的核、CPU甚至是机器上并行地执行这些子操作。与此相反，如果你的意图是实现并发，而非并行，或者你的主要目标是在同一个CPU上执行几个松耦合的任务，充分利用CPU的核，让其足够忙碌，从而最大化程序的吞吐量，那么你其实真正想做的是避免因为等待远程服务的返回，或者对数据库的查询，而阻塞线程的执行，浪费宝贵的计算资源，因为这种等待的时间很可能相当长。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C.png" alt=""></p>
<h1 id="1-Future接口"><a href="#1-Future接口" class="headerlink" title="1. Future接口"></a>1. Future接口</h1><p>Future接口在Java 5中被引入，设计初衷是对将来某个时刻会发生的结果进行建模。它建模了一种异步计算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。在Future中触发那些潜在耗时的操作把调用线程解放出来，让它能继续执行其他有价值的工作，不再需要等待耗时的操作完成。Future的另一个优点是它比更底层的Thread更易用。要使用Future，通常你只需要将耗时的操作封装在一个Callable对象中，再将它提交给ExecutorService。使用Future以异步的方式执行一个耗时的操作:<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E4%BD%BF%E7%94%A8Future%E4%BB%A5%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E8%80%97%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C.png" alt=""></p>
<p>线程可以在ExecutorService以并发方式调用另一个线程执行耗时操作的同时，去执行一些其他的任务。接着，如果你已经运行到没有异步操作的结果就无法继续任何有意义的工作时，可以调用它的get方法去获取操作的结果。如果操作已经完成，该方法会立刻返回操作的结果，否则它会阻塞你的线程，直到操作完成，返回相应的结果。如果该长时间运行的操作永远不返回了会怎样?Future提供了一个无需任何参数的get方法，推荐使用重载版本的get方法，它接受一个超时的参数，可以定义线程等待Future结果的最长时间，避免无休止的等待。下图是Future异步执行线程原理图。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/Future%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt=""></p>
<h1 id="2-使用CompletableFuture构建异步应用"><a href="#2-使用CompletableFuture构建异步应用" class="headerlink" title="2. 使用CompletableFuture构建异步应用"></a>2. 使用CompletableFuture构建异步应用</h1><p>Future接口有一定的局限性，比如，我们很难表述Future结果之间的依赖性。因此我们引入了CompletableFuture。接下来通过一个“最佳价格查询器“的应用，它会查询多个在线商店，依据给定的产品或服务找出最低的价格，来展现CompletableFuture实现异步应用。通过此例你能学到这些：</p>
<ul>
<li>如何编写异步API</li>
<li>如何让使用同步API的代码变为非阻塞代码</li>
<li>如何使用流水线将两个接续的异步操作合并为一个异步计算操作</li>
<li>如何以响应式的方式处理异步操作的完成事件</li>
</ul>
<p>同步API和异步API：</p>
<ul>
<li>同步API其实只是对传统方法调用的另一种称呼:你调用了某个方法，调用方在被调用方运行的过程中会等待，被调用方运行结束返回，调用方取得被调用方的返回值并继续运行。即使调用方和被调用方在不同的线程中运行，调用方还是需要等待被调用方结束运行，这就是阻塞式调用这个名词的由来。</li>
<li>异步API会直接返回，或者至少在被调用方计算完成之前，将它剩余的计算任务交给另一个线程去做，该线程和调用方是异步的——这就是非阻塞式调用的由来。执行剩余计算任务的线程会将它的计算结果返回给调用方。返回的方式要么是通过回调函数，要么是由调用方再次执行一个“等待，直到计算完成”的方法调用。</li>
</ul>
<h2 id="2-1-实战：实现异步API"><a href="#2-1-实战：实现异步API" class="headerlink" title="2.1 实战：实现异步API"></a>2.1 实战：实现异步API</h2><h3 id="2-1-1-同步方法"><a href="#2-1-1-同步方法" class="headerlink" title="2.1.1 同步方法"></a>2.1.1 同步方法</h3><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95.png" alt=""></p>
<blockquote>
<p>同步操作中会为等待同步事件完成而等待1s，这种是无法接受的，对于程序体验来说是非常不好的。</p>
</blockquote>
<h3 id="2-1-2-将同步方法转换为异步方法"><a href="#2-1-2-将同步方法转换为异步方法" class="headerlink" title="2.1.2 将同步方法转换为异步方法"></a>2.1.2 将同步方法转换为异步方法</h3><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95.png" alt=""></p>
<blockquote>
<p>Java 5引入了java.util.concurrent.Future接口表示一个异步计算(即调用线程可以继续运行，不会因为调用方法而阻塞)的结果。这意味着Future是一个暂时还不可知值的处理器，这个值在计算完成后，可以通过调用它的get方法取得。这种方式下，在进行价格查询的同时，还能执行一些其他的任务，比如查询其他商店中商品的价格，不会阻塞在那里等待第一家商店返回请求的结果。最后，如果所有有意义的工作都已经完成，所有要执行的工作都依赖于商品价格时，再调用Future的get方法。执行了这个操作后，要么获得Future中封装的值(如果异步任务已经完成)，要么发生阻塞，直到该异步任务完成，期望的值能够访问。同时，如果某个商品价格计算发生异常，会将当前线程杀死，从而导致等待get方法返回结果的客户端永久地被阻塞。客户端可以使用重载版本的get方法，设置超时参数来避免。为了让客户端能了解无法提供请求商品价格的原因，你需要使用CompletableFuture的completeExceptionally方法将导致CompletableFuture内发生问题的异常抛出。</p>
</blockquote>
<h2 id="2-1-3-使用工厂方法supplyAsync创建CompletableFuture对象"><a href="#2-1-3-使用工厂方法supplyAsync创建CompletableFuture对象" class="headerlink" title="2.1.3 使用工厂方法supplyAsync创建CompletableFuture对象"></a>2.1.3 使用工厂方法supplyAsync创建CompletableFuture对象</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95(%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95).png" alt=""></p>
<blockquote>
<p>supplyAsync方法接受一个生产者(Supplier)作为参数，返回一个CompletableFuture对象，该对象完成异步执行后会读取调用生产者方法的返回值。生产者方法会交由ForkJoinPool池中的某个执行线程(Executor)运行，但是你也可以使用supplyAsync方法的重载版本，传递第二个参数指定不同的执行线程执行生产者方法。</p>
</blockquote>
<h1 id="3-消除代码阻塞问题"><a href="#3-消除代码阻塞问题" class="headerlink" title="3. 消除代码阻塞问题"></a>3. 消除代码阻塞问题</h1><h2 id="3-1-顺序同步请求"><a href="#3-1-顺序同步请求" class="headerlink" title="3.1 顺序同步请求"></a>3.1 顺序同步请求</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.3/%E9%A1%BA%E5%BA%8F%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82.png" alt=""></p>
<h2 id="3-2-使用并行流对请求进行并行操作"><a href="#3-2-使用并行流对请求进行并行操作" class="headerlink" title="3.2 使用并行流对请求进行并行操作"></a>3.2 使用并行流对请求进行并行操作</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.3/%E4%BD%BF%E7%94%A8%E5%B9%B6%E8%A1%8C%E6%B5%81%E5%AF%B9%E8%AF%B7%E6%B1%82%E8%BF%9B%E8%A1%8C%E5%B9%B6%E8%A1%8C%E6%93%8D%E4%BD%9C.png" alt=""></p>
<h2 id="3-3-使用CompletableFuture发起异步请求"><a href="#3-3-使用CompletableFuture发起异步请求" class="headerlink" title="3.3 使用CompletableFuture发起异步请求"></a>3.3 使用CompletableFuture发起异步请求</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.3/%E4%BD%BF%E7%94%A8CompletableFuture%E5%8F%91%E8%B5%B7%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.png" alt=""></p>
<p>CompletableFuture版本的程序似乎比并行流版本的程序还快那么一点儿。但是最后这个版本也不太令人满意。它们看起来不相伯仲，究其原因都一样:它们内部采用的是同样的通用线程池，默认都使用固定数目的线程，具体线程数取决于Runtime.getRuntime().availableProcessors()的返回值。然而，CompletableFuture具有一定的优势，因为它允许你对执行器(Executor)进行配置，尤其是线程池的大小，让它以更适合应用需求的方式进行配置，满足程序的要求，而这是并行流API无法提供的。<br>顺序执行和并行执行的原理对比：<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.3/%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8E%9F%E7%90%86%E5%AF%B9%E6%AF%94.png" alt=""></p>
<p>图11-4的上半部分展示了使用单一流水线处理流的过程，我们看到，执行的流程(以虚线标识)是顺序的。事实上，新的CompletableFuture对象只有在前一个操作完全结束之后，才能创建。与此相反，图的下半部分展示了如何先将CompletableFutures对象聚集到一个列表中(即图中以椭圆表示的部分)，让对象们可以在等待其他对象完成操作之前就能启动。</p>
<h2 id="3-4-使用CompletableFuture发起异步请求WithExecutor"><a href="#3-4-使用CompletableFuture发起异步请求WithExecutor" class="headerlink" title="3.4 使用CompletableFuture发起异步请求WithExecutor"></a>3.4 使用CompletableFuture发起异步请求WithExecutor</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.3/%E4%BD%BF%E7%94%A8CompletableFuture%E5%8F%91%E8%B5%B7%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82WithExecutor.png" alt=""></p>
<h2 id="3-5-调用结果"><a href="#3-5-调用结果" class="headerlink" title="3.5 调用结果:"></a>3.5 调用结果:</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.3/%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%9C.png" alt=""></p>
<h2 id="3-6-并行——使用流还是CompletableFutures"><a href="#3-6-并行——使用流还是CompletableFutures" class="headerlink" title="3.6 并行——使用流还是CompletableFutures"></a>3.6 并行——使用流还是CompletableFutures</h2><p>目前为止，你已经知道对集合进行并行计算有两种方式:要么将其转化为并行流，利用map这样的操作开展工作，要么枚举出集合中的每一个元素，创建新的线程，在CompletableFuture内对其进行操作。后者提供了更多的灵活性，你可以调整线程池的大小，而这能帮助你确保整体的计算不会因为线程都在等待I/O而发生阻塞。</p>
<ul>
<li>如果你进行的是计算密集型的操作，并且没有I/O，那么推荐使用Stream接口，因为实现简单，同时效率也可能是最高的(如果所有的线程都是计算密集型的，那就没有必要创建比处理器核数更多的线程)。 </li>
<li>如果你并行的工作单元还涉及等待I/O的操作(包括网络连接等待)，那么使用CompletableFuture灵活性更好，你可以像前文讨论的那样，依据等待/计算，或者 W/C的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是，处理流的流水线中如果发生I/O等待，流的延迟性会让我们很难判断到底什么时候触发了等待。</li>
</ul>
<h1 id="4-对多个异步任务进行流水线操作"><a href="#4-对多个异步任务进行流水线操作" class="headerlink" title="4. 对多个异步任务进行流水线操作"></a>4. 对多个异步任务进行流水线操作</h1><h2 id="4-1-案例"><a href="#4-1-案例" class="headerlink" title="4.1 案例"></a>4.1 案例</h2><p>通过在shop构成的流上采用流水线方式执行三次map操作，我们得到了结果。</p>
<ul>
<li>第一个操作将每个shop对象转换成了一个字符串，该字符串包含了该 shop中指定商品的价格和折扣代码。</li>
<li>第二个操作对这些字符串进行了解析，在Quote对象中对它们进行转换。</li>
<li>第三个map会操作联系远程的Discount服务，计算出最终的折扣价格，并返回该价格及提供该价格商品的shop。</li>
</ul>
<p>代码如图:<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.4/Discount.png" alt=""><br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.4/Quote.png" alt=""><br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.4/Shop11_4.png" alt=""><br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.4/Test.png" alt=""></p>
<p>原理图：<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.4/Discount%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt=""></p>
<p>Java 8的CompletableFuture API提供了名为thenCompose的方法，它就是专门为这一目的而设计的，thenCompose方法允许你对两个异步操作进行流水线，第一个操作完成时，将其结果作为参数传递给第二个操作。换句话说，你可以创建两个CompletableFutures对象，对第一个CompletableFuture对象调用thenCompose，并向其传递一个函数。当第一个 CompletableFuture执行完毕后，它的结果将作为该函数的参数，这个函数的返回值是以第一 个CompletableFuture的返回做输入计算出的第二个CompletableFuture对象。thenCompose方法像CompletableFuture类中的其他方法一样，也提供了一个以Async后缀结尾的版本thenComposeAsync。通常而言，名称中不带Async的方法和它的前一个任务一样，在同一个线程中运行;而名称以Async结尾的方法会将后续的任务提交到一个线程池，所以每个任务是由不同的线程处理的。</p>
<h2 id="4-2-thenCombine方法"><a href="#4-2-thenCombine方法" class="headerlink" title="4.2 thenCombine方法"></a>4.2 thenCombine方法</h2><p>将两个CompletableFuture对象结合起来，无论他们是否存在依赖。thenCombine方法，它接收名为BiFunction的第二参数，这个参数 定义了当两个CompletableFuture对象完成计算后，结果如何合并。同thenCompose方法一样， thenCombine方法也提供有一个Async的版本。这里，如果使用thenCombineAsync会导致BiFunction中定义的合并操作被提交到线程池中，由另一个任务以异步的方式执行。</p>
<p>代码图：<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.5/thenCombine.png" alt=""></p>
<p>原理图：<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.5/thenCombine%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt=""></p>
<h2 id="4-3-响应CompletableFuture的completion事件"><a href="#4-3-响应CompletableFuture的completion事件" class="headerlink" title="4.3 响应CompletableFuture的completion事件"></a>4.3 响应CompletableFuture的completion事件</h2><p>Java 8的CompletableFuture通过thenAccept方法提供了这一功能，它接收 CompletableFuture执行完毕后的返回值做参数。thenAccept方法也提供 了一个异步版本，名为thenAcceptAsync。异步版本的方法会对处理结果的消费者进行调度， 从线程池中选择一个新的线程继续执行，不再由同一个线程完成CompletableFuture的所有任 务。因为你想要避免不必要的上下文切换，更重要的是你希望避免在等待线程上浪费时间，尽快响应CompletableFuture的completion事件，所以这里没有采用异步版本。</p>
<h2 id="4-3-1-实战"><a href="#4-3-1-实战" class="headerlink" title="4.3.1 实战"></a>4.3.1 实战</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.5/thenAccept%E5%AE%9E%E6%88%98.png" alt=""></p>
<h1 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h1><ul>
<li>执行比较操作时,尤其是那些依赖一个或多个远程服务的操作，使用异步任务可以改善程序的性能，加快程序的响应速度。</li>
<li>你应该尽可能地为客户提供异步API。使用CompletableFuture类提供的特性，你能够轻松地实现这一目标。</li>
<li>CompletableFuture类还提供了异常管理的机制，让你有机会抛出/管理异步任务执行中发生的异常。</li>
<li>将同步API的调用封装到一个CompletableFuture中，你能够以异步的方式使用其结果。</li>
<li>如果异步任务之间相互独立，或者它们之间某一些的结果是另一些的输入，你可以将这些异步任务构造或者合并成一个。</li>
<li>你可以为CompletableFuture注册一个回调函数，在Future执行完毕或者它们计算的结果可用时，针对性地执行一些程序。</li>
<li>你可以决定在什么时候结束程序的运行，是等待由CompletableFuture对象构成的列表中所有的对象都执行完毕，还是只要其中任何一个首先完成就中止程序的运行。</li>
</ul>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-22T11:34:52.000Z" title="2019-03-22T11:34:52.000Z">2019-03-22</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">18 分钟 读完 (大约 2637 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/d85f00c6.html">《Java 8 in Action》Chapter 10：用Optional取代null</a></h1><div class="content"><blockquote>
<p>1965年，英国一位名为Tony Hoare的计算机科学家在设计ALGOL W语言时提出了null引用的想法。ALGOL W是第一批在堆上分配记录的类型语言之一。Hoare选择null引用这种方式，“只是因为这种方法实现起来非常容易”。虽然他的设计初衷就是要“通过编译器的自动检测机制，确保所有使用引用的地方都是绝对安全的”，他还是决定为null引用开个绿灯，因为他认为这是为“不存在的值”建模最容易的方式。很多年后，他开始为自己曾经做过这样的决定而后悔不已，把它称为“我价值百万的重大事物”。实际上，Hoare的这段话低估了过去五十年来数百万程序员为修复空引用所耗费的代价。近十年出现的大多数现代程序设计语言1，包括Java，都采用了同样的设计方式，其原因是为了与更老的语言保持兼容，或者就像Hoare曾经陈述的那样，“仅仅是因为这样实现起来更加容易”。</p>
</blockquote>
<h1 id="1-如何为确实的值建模"><a href="#1-如何为确实的值建模" class="headerlink" title="1. 如何为确实的值建模"></a>1. 如何为确实的值建模</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Car car;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> car; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Insurance insurance;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Insurance <span class="title">getInsurance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> insurance; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insurance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCarInsuranceName</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> person.getCar().getInsurance().getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码的问题就在于，如果person没有车，就会造成空指针异常。</p>
<h2 id="1-1-采用防御式检查减少NullPointerException"><a href="#1-1-采用防御式检查减少NullPointerException" class="headerlink" title="1.1 采用防御式检查减少NullPointerException"></a>1.1 采用防御式检查减少NullPointerException</h2><h3 id="1-1-1-深层质疑"><a href="#1-1-1-深层质疑" class="headerlink" title="1.1.1 深层质疑"></a>1.1.1 深层质疑</h3><p>简单来说就是在需要的地方添加null检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCarInsuranceName</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (person != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Car car = person.getCar();</span><br><span class="line">        <span class="keyword">if</span> (car != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Insurance insurance = car.getInsurance();</span><br><span class="line">            <span class="keyword">if</span> (insurance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> insurance.getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Unknown"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码不具备扩展性，同时还牺牲了代码的可读性。</p>
<h3 id="1-1-2-过多的退出语句"><a href="#1-1-2-过多的退出语句" class="headerlink" title="1.1.2 过多的退出语句"></a>1.1.2 过多的退出语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCarInsuranceName</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (person == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Unknown"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Car car = person.getCar();</span><br><span class="line">    <span class="keyword">if</span> (car == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Unknown"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Insurance insurance = car.getInsurance();</span><br><span class="line">    <span class="keyword">if</span> (insurance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Unknown"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> insurance.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模式中方法的退出点有四处，使得代码的维护异常艰难。</p>
<h2 id="1-2-null带来的种种问题"><a href="#1-2-null带来的种种问题" class="headerlink" title="1.2 null带来的种种问题"></a>1.2 null带来的种种问题</h2><ul>
<li>它是错误之源。 NullPointerException是目前Java程序开发中最典型的异常。它会使你的代码膨胀。</li>
<li>它让你的代码充斥着深度嵌套的null检查，代码的可读性糟糕透顶。</li>
<li>它自身是毫无意义的。 null自身没有任何的语义，尤其是是它代表的是在静态类型语言中以一种错误的方式对缺失变量值的建模。</li>
<li>它破坏了Java的哲学。 Java一直试图避免让程序员意识到指针的存在，唯一的例外是:null指针。</li>
<li>它在Java的类型系统上开了个口子。 null并不属于任何类型，这意味着它可以被赋值给任意引用类型的变量。这会导致问题， 原因是当这个变量被传递到系统中的另一个部分后，你将无法获知这个null变量最初赋值到底是什么类型。</li>
</ul>
<h2 id="1-3-其他语言中null的替代品"><a href="#1-3-其他语言中null的替代品" class="headerlink" title="1.3 其他语言中null的替代品"></a>1.3 其他语言中null的替代品</h2><ul>
<li>Groovy中的安全导航操作符</li>
<li>Haskell中的Maybe类型</li>
<li>Scala中的Option[T]</li>
</ul>
<h1 id="2-Optional类入门"><a href="#2-Optional类入门" class="headerlink" title="2. Optional类入门"></a>2. Optional类入门</h1><p>变量存在时，Optional类只是对类简单封装。变量不存在时，缺失的值会被建模成一个“空”的Optional对象，由方法Optional.empty()返回。Optional.empty()方法是一个静态工厂方法，它返回Optional类的特定单一实例。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/10.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2010%EF%BC%9A%E7%94%A8Optional%E5%8F%96%E4%BB%A3null/1.png" alt=""></p>
<p>引入Optional类的意图并非要消除每一个null引用，相反的是，它的目标是帮助开发者更好地设计出普适的API。</p>
<h1 id="3-应用Optional的几种模式"><a href="#3-应用Optional的几种模式" class="headerlink" title="3. 应用Optional的几种模式"></a>3. 应用Optional的几种模式</h1><h2 id="3-1-创建Optional对象"><a href="#3-1-创建Optional对象" class="headerlink" title="3.1 创建Optional对象"></a>3.1 创建Optional对象</h2><h3 id="3-1-1-声明一个空的Optional"><a href="#3-1-1-声明一个空的Optional" class="headerlink" title="3.1.1 声明一个空的Optional"></a>3.1.1 声明一个空的Optional</h3><p>正如前文已经提到，你可以通过静态工厂方法Optional.empty，创建一个空的Optional对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Car&gt; optCar = Optional.empty();</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-依据一个非空值创建Optional"><a href="#3-1-2-依据一个非空值创建Optional" class="headerlink" title="3.1.2 依据一个非空值创建Optional"></a>3.1.2 依据一个非空值创建Optional</h3><p>你还可以使用静态工厂方法Optional.of，依据一个非空值创建一个Optional对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Car&gt; optCar = Optional.of(car);</span><br></pre></td></tr></table></figure>
<p>如果car是一个null，这段代码会立即抛出一个NullPointerException，而不是等到你试图访问car的属性值时才返回一个错误。</p>
<h3 id="3-2-3-可接受null的Optional"><a href="#3-2-3-可接受null的Optional" class="headerlink" title="3.2.3 可接受null的Optional"></a>3.2.3 可接受null的Optional</h3><p>最后，使用静态工厂方法Optional.ofNullable，你可以创建一个允许null值的Optional对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Car&gt; optCar = Optional.ofNullable(car);</span><br></pre></td></tr></table></figure>
<p>如果car是null，那么得到的Optional对象就是个空对象。</p>
<h2 id="3-2-使用map从Optional对象中提取和转换值"><a href="#3-2-使用map从Optional对象中提取和转换值" class="headerlink" title="3.2 使用map从Optional对象中提取和转换值"></a>3.2 使用map从Optional对象中提取和转换值</h2><p>从对象中提取信息是一种比较常见的模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(insurance != <span class="keyword">null</span>)&#123;</span><br><span class="line">        name = insurance.getName();</span><br><span class="line">    &#125;</span><br><span class="line">为了支持这种模式，Optional提供了一个map方法。</span><br><span class="line">Optional&lt;Insurance&gt; optInsurance = Optional.ofNullable(insurance); </span><br><span class="line">Optional&lt;String&gt; name = optInsurance.map(Insurance::getName);</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/10.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2010%EF%BC%9A%E7%94%A8Optional%E5%8F%96%E4%BB%A3null/2.png" alt=""></p>
<h2 id="3-3-使用flatMap链接Optional对象"><a href="#3-3-使用flatMap链接Optional对象" class="headerlink" title="3.3 使用flatMap链接Optional对象"></a>3.3 使用flatMap链接Optional对象</h2><p>使用流时，flatMap方法接受一个函数作为参数，这个函数的返回值是另一个流。 这个方法会应用到流中的每一个元素，最终形成一个新的流的流。但是flagMap会用流的内容替换每个新生成的流。换句话说，由方法生成的各个流会被合并或者扁平化为一个单一的流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCarInsuranceName</span><span class="params">(Optional&lt;Person&gt; person)</span> </span>&#123; <span class="keyword">return</span> person.flatMap(Person::getCar)</span><br><span class="line">                     .flatMap(Car::getInsurance)</span><br><span class="line">                     .map(Insurance::getName)</span><br><span class="line">                     .orElse(<span class="string">"Unknown"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/10.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2010%EF%BC%9A%E7%94%A8Optional%E5%8F%96%E4%BB%A3null/3.png" alt=""></p>
<h2 id="3-4-默认行为及解引用Optional对象"><a href="#3-4-默认行为及解引用Optional对象" class="headerlink" title="3.4 默认行为及解引用Optional对象"></a>3.4 默认行为及解引用Optional对象</h2><ol>
<li>get()是这些方法中最简单但又最不安全的方法。如果变量存在，它直接返回封装的变量值，否则就抛出一个NoSuchElementException异常。所以，除非你非常确定Optional变量一定包含值，否则使用这个方法是个相当糟糕的主意。此外，这种方式即便相对于嵌套式的null检查，也并未体现出多大的改进。</li>
<li>orElse(T other)是我们在代码清单10-5中使用的方法，正如之前提到的，它允许你在 Optional对象不包含值时提供一个默认值。</li>
<li>orElseGet(Supplier&lt;? extends T&gt; other)是orElse方法的延迟调用版，Supplier 方法只有在Optional对象不含值时才执行调用。如果创建默认值是件耗时费力的工作，你应该考虑采用这种方式(借此提升程序的性能)，或者你需要非常确定某个方法仅在 Optional为空时才进行调用，也可以考虑该方式(这种情况有严格的限制条件)。</li>
<li>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)和get方法非常类似，它们遭遇Optional对象为空时都会抛出一个异常，但是使用orElseThrow你可以定制􏳵希望抛出的异常类型。</li>
<li>ifPresent(Consumer&lt;? super T&gt;)让你能在变量值存在时执行一个作为参数传入的方法，否则就不进行任何操作。</li>
</ol>
<h2 id="3-5-两个Optional对象的组合"><a href="#3-5-两个Optional对象的组合" class="headerlink" title="3.5 两个Optional对象的组合"></a>3.5 两个Optional对象的组合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Insurance&gt; <span class="title">nullSafeFindCheapestInsurance</span><span class="params">(Optional&lt;Person&gt; person, Optional&lt;Car&gt; car)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (person.isPresent() &amp;&amp; car.isPresent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.of(findCheapestInsurance(person.get(), car.get())); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-使用filter剔除特定的值"><a href="#3-6-使用filter剔除特定的值" class="headerlink" title="3.6 使用filter剔除特定的值"></a>3.6 使用filter剔除特定的值</h2><p>filter方法接受一个谓词作为参数。如果Optional对象的值存在，并且它符合谓词的条件， filter方法就返回其值;否则它就返回一个空的Optional对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Insurance insurance = ...;</span><br><span class="line"><span class="keyword">if</span>(insurance != <span class="keyword">null</span> &amp;&amp; <span class="string">"CambridgeInsurance"</span>.equals(insurance.getName()))&#123;</span><br><span class="line">       System.out.println(<span class="string">"ok”);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">Optional&lt;Insurance&gt; optInsurance = ...;</span></span><br><span class="line"><span class="string">optInsurance.filter(insurance -&gt;</span></span><br><span class="line"><span class="string">                        "</span>CambridgeInsurance<span class="string">".equals(insurance.getName()))</span></span><br><span class="line"><span class="string">            .ifPresent(x -&gt; System.out.println("</span>ok<span class="string">"));</span></span><br></pre></td></tr></table></figure>

<p>Optional类中的方法进行了分类和概括:<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/10.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2010%EF%BC%9A%E7%94%A8Optional%E5%8F%96%E4%BB%A3null/4.png" alt=""><br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/10.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2010%EF%BC%9A%E7%94%A8Optional%E5%8F%96%E4%BB%A3null/5.png" alt=""></p>
<h1 id="4-使用Optional的实战示例"><a href="#4-使用Optional的实战示例" class="headerlink" title="4. 使用Optional的实战示例"></a>4. 使用Optional的实战示例</h1><h2 id="4-1-用Optional封装可能为null的值"><a href="#4-1-用Optional封装可能为null的值" class="headerlink" title="4.1 用Optional封装可能为null的值"></a>4.1 用Optional封装可能为null的值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Object&gt; value = Optional.ofNullable(map.get(<span class="string">"key"</span>));</span><br></pre></td></tr></table></figure>
<p>每次你希望安全地对潜在为null的对象进行转换，将其替换为Optional对象时，都可以考虑使用这种方法。</p>
<h2 id="4-2-异常与Optional的对比"><a href="#4-2-异常与Optional的对比" class="headerlink" title="4.2 异常与Optional的对比"></a>4.2 异常与Optional的对比</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;Integer&gt; <span class="title">stringToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Optional.of(Integer.parseInt(s));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的建议是，你可以将多个类似的方法封装到一个工具类中，让我们称之为OptionalUtility。通过这种方式，你以后就能直接调用OptionalUtility.stringToInt方法，将String转换为一个Optional<Integer>对象，而不再需要记得你在其中封装了笨拙的 try/catch的逻辑了。</p>
<h2 id="4-3-把所有内容结合起来"><a href="#4-3-把所有内容结合起来" class="headerlink" title="4.3 把所有内容结合起来"></a>4.3 把所有内容结合起来</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readDuration</span><span class="params">(Properties props, String name)</span> </span>&#123;</span><br><span class="line">    String value = props.getProperty(name);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = Integer.parseInt(value);</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化版本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readDuration</span><span class="params">(Properties props, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(props.getProperty(name))</span><br><span class="line">                        .flatMap(OptionalUtility::stringToInt)</span><br><span class="line">                        .filter(i -&gt; i &gt; <span class="number">0</span>)</span><br><span class="line">                        .orElse(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h1><p>这一章中，你学到了以下的内容。</p>
<ol>
<li>null引用在上被引入到程序设计语言中，目的是为了表示变量值的。</li>
<li>Java 8中引入了一个新的类java.util.Optional<T>，对存在或缺失的变量值进行建模。</li>
<li>你可以使用静态工厂方法Optional.empty、Optional.of以及Optional.ofNullable创建Optional对象。</li>
<li>Optional类支持多种方法，比如map、flatMap、filter，它们在概念上与Stream类中对应的方法十分相似。</li>
<li>使用Optional会使你更积极地解引用Optional对象，以应对变量值缺失的问题，最终，你能更有效地止代码中出现不而至的空指针异常。</li>
<li>使用Optional能帮助你设计更好的API，用户只需要阅读方法签名，就能了解该方法是否接受一个Optional类型的值。</li>
</ol>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-19T11:34:52.000Z" title="2019-03-19T11:34:52.000Z">2019-03-19</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">28 分钟 读完 (大约 4155 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/3a45c3e5.html">《Java 8 in Action》Chapter 9：默认方法</a></h1><div class="content"><blockquote>
<p>传统上，Java程序的接口是将相关方法按照约定组合到一起的方式。实现接口的类必须为接口中定义的每个方法提供一个实现，或者从父类中继承它的实现。<br>但是，一旦类库的设计者需要更新接口，向其中加入新的方法，这种方式就会出现问题。现实情况是，现存的实体类往往不在接口设计者的控制范围之内，这些实体类为了适配新的接口约定也需要进行修改。<br>由于Java 8的API在现存的接口上引入了非常多的新方法，这种变化带来的问题也愈加严重，一个例子就是前几章中使用过的 List 接口上的 sort 方法。<br>想象一下其他备选集合框架的维护人员会多么抓狂吧，像Guava和Apache Commons这样的框架现在都需要修改实现了 List 接口的所有类，为其添加sort 方法的实现。<br>Java 8为了解决这一问题引入了一种新的机制。Java 8中的接口现在支持在声明方法的同时提供实现，通过两种方式可以完成这种操作。其一，Java 8允许在接口内声明静态方法。<br>其二，Java 8引入了一个新功能，叫默认方法，通过默认方法你可以指定接口方法的默认实现。换句话说，接口能提供方法的具体实现。因此，实现接口的类如果不显式地提供该方法的具体实现，<br>就会自动继承默认的实现。这种机制可以使你平滑地进行接口的优化和演进。实际上，到目前为止你已经使用了多个默认方法。两个例子就是你前面已经见过的 List 接口中的 sort ，以及 Collection 接口中的 stream 。</p>
</blockquote>
<p>第1章中 List 接口中的 sort 方法是Java 8中全新的方法，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span></span>&#123;</span><br><span class="line">    Collections.sort(<span class="keyword">this</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意返回类型之前的新 default 修饰符。通过它，我们能够知道一个方法是否为默认方法。这里 sort 方法调用了 Collections.sort 方法进行排序操作。由于有了这个新的方法，我们现在可以直接通过调用 sort ，对列表中的元素进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">numbers.sort(Comparator.naturalOrder());</span><br></pre></td></tr></table></figure>
<p>不过除此之外，这段代码中还有些其他的新东西。我们调用了Comparator.naturalOrder 方法。这是 Comparator 接口的一个全新的静态方法，它返回一个Comparator 对象，并按自然序列对其中的元素进行排序（即标准的字母数字方式排序）。<br>第4章中的 Collection 中的 stream 方法的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在之前的几章中大量使用了该方法来处理集合，这里 stream 方法中调用了SteamSupport.stream 方法来返回一个流。你注意到 stream 方法的主体是如何调用 spliterator 方法的了吗？它也是 Collection 接口的一个默认方法。<br>接口和抽象类还是有一些本质的区别，我们在这一章中会针对性地进行讨论。<br>简而言之，向接口添加方法是诸多问题的罪恶之源；一旦接口发生变化，实现这些接口的类往往也需要更新，提供新添方法的实现才能适配接口的变化。如果你对接口以及它所有相关的实现有完全的控制，这可能不是个大问题。但是这种情况是极少的。这就是引入默认方法的目的：它让类可以自动地继承接口的一个默认实现。</p>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/09.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%209%EF%BC%9A%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/1.png" alt=""></p>
<h1 id="1-不断演进的-API"><a href="#1-不断演进的-API" class="headerlink" title="1. 不断演进的 API"></a>1. 不断演进的 API</h1><h2 id="1-1-初始版本的-API"><a href="#1-1-初始版本的-API" class="headerlink" title="1.1 初始版本的 API"></a>1.1 初始版本的 API</h2><p>Resizable 接口的最初版本提供了下面这些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resizable</span> <span class="keyword">extends</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> height)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAbsoluteSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">用户根据自身的需求实现了 Resizable 接口，创建了 Ellipse 类：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span> <span class="keyword">implements</span> <span class="title">Resizable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">他实现了一个处理各种 Resizable 形状（包括 Ellipse ）的游戏：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Resizable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">implements</span> <span class="title">Resizable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Resizable&gt; resizableShapes =</span><br><span class="line">                Arrays.asList(<span class="keyword">new</span> Square(), <span class="keyword">new</span> Triangle(), <span class="keyword">new</span> Ellipse());</span><br><span class="line">        Utils.paint(resizableShapes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(List&lt;Resizable&gt; list)</span> </span>&#123;</span><br><span class="line">        list.forEach(r -&gt; &#123;</span><br><span class="line">            r.setAbsoluteSize(<span class="number">42</span>, <span class="number">42</span>);</span><br><span class="line">            r.draw();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-第二版-API"><a href="#1-2-第二版-API" class="headerlink" title="1.2 第二版 API"></a>1.2 第二版 API</h2><p>库上线使用几个月之后，你收到很多请求，要求你更新 Resizable 的实现，让 Square Triangle 以及其他的形状都能支持 setRelativeSize 方法。为了满足这些新的需求，你发布了第二版API。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resizable</span> <span class="keyword">extends</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> height)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAbsoluteSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRelativeSize</span><span class="params">(<span class="keyword">int</span> wFactor, <span class="keyword">int</span> hFactor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 Resizable 接口的更新导致了一系列的问题。首先，接口现在要求它所有的实现类添加setRelativeSize 方法的实现。但是用户最初实现的 Ellipse 类并未包含 setRelativeSize方法。向接口添加新方法是二进制兼容的，这意味着如果不重新编译该类，即使不实现新的方法，现有类的实现依旧可以运行。不过，用户可能修改他的游戏，在他的 Utils.paint 方法中调用setRelativeSize 方法，因为 paint 方法接受一个 Resizable 对象列表作为参数。如果传递的是一个 Ellipse 对象，程序就会抛出一个运行时错误，因为它并未实现 setRelativeSize 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.AbstractMethodError:lambdasinaction.chap9.Ellipse.setRelativeSize(II)V</span><br></pre></td></tr></table></figure>
<p>其次，如果用户试图重新编译整个应用（包括 Ellipse 类），他会遭遇下面的编译错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error:(<span class="number">9</span>, <span class="number">8</span>) java: com.lujiahao.learnjava8.chapter9.Ellipse不是抽象的, 并且未覆盖</span><br><span class="line">com.lujiahao.learnjava8.chapter9.Resizable中的抽象方法setRelativeSize(<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>这就是默认方法试图解决的问题。它让类库的设计者放心地改进应用程序接口，无需担忧对遗留代码的影响，这是因为实现更新接口的类现在会自动继承一个默认的方法实现。</p>
<p>变更对Java程序的影响大体可以分成三种类型的兼容性，分别是:</p>
<ul>
<li>二进制级的兼容</li>
<li>源代码级的兼容</li>
<li>函数行为的兼容</li>
</ul>
<h1 id="2-概述默认方法"><a href="#2-概述默认方法" class="headerlink" title="2. 概述默认方法"></a>2. 概述默认方法</h1><p>默认方法由 default 修饰符修饰，并像类中声明的其他方法一样包含方法体。比如，你可以像下面这样在集合库中定义一个名为Sized 的接口，在其中定义一个抽象方法 size ，以及一个默认方法 isEmpty ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sized</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样任何一个实现了 Sized 接口的类都会自动继承 isEmpty 的实现。因此，向提供了默认实现的接口添加方法就不是源码兼容的。<br>默认方法在Java 8的API中已经大量地使用了。本章已经介绍过我们前一章中大量使用的 Collection 接口的 stream 方法就是默认方法。 List 接口的 sort 方法也是默认方法。第3章介绍的很多函数式接口，比如 Predicate 、 Function 以及 Comparator 也引入了新的默认方法，比如 Predicate.and 或者 Function.andThen （记住，函数式接口只包含一个抽象方法，默认方法是种非抽象方法）。</p>
<h1 id="3-默认方法的使用模式"><a href="#3-默认方法的使用模式" class="headerlink" title="3. 默认方法的使用模式"></a>3. 默认方法的使用模式</h1><h2 id="3-1-可选方法"><a href="#3-1-可选方法" class="headerlink" title="3.1 可选方法"></a>3.1 可选方法</h2><p>类实现了接口，不过却刻意地将一些方法的实现留白。我们以Iterator 接口为例来说。 Iterator 接口定义了 hasNext 、 next ，还定义了 remove 方法。Java 8之前，由于用户通常不会使用该方法， remove 方法常被忽略。因此，实现 Interator 接口的类通常会为 remove 方法放置一个空的实现，这些都是些毫无用处的模板代码。采用默认方法之后，你可以为这种类型的方法提供一个默认的实现，这样实体类就无需在自己的实现中显式地提供一个空方法。比如，在Java 8中， Iterator 接口就为 remove 方法提供了一个默认实现，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-行为的多继承"><a href="#3-2-行为的多继承" class="headerlink" title="3.2 行为的多继承"></a>3.2 行为的多继承</h2><p>默认方法让之前无法想象的事儿以一种优雅的方式得以实现，即行为的多继承。这是一种让类从多个来源重用代码的能力。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/09.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%209%EF%BC%9A%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/2.png" alt=""></p>
<p>Java的类只能继承单一的类，但是一个类可以实现多接口。要确认也很简单，下面是Java API中对 ArrayList 类的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-1-类型的多继承"><a href="#3-2-1-类型的多继承" class="headerlink" title="3.2.1 类型的多继承"></a>3.2.1 类型的多继承</h3><p>这个例子中 ArrayList 继承了一个类，实现了六个接口。因此 ArrayList 实际是七个类型的直接子类，分别是： AbstractList 、 List 、 RandomAccess 、 Cloneable 、 Serializable 、Iterable 和 Collection 。所以，在某种程度上，我们早就有了类型的多继承。<br>由于Java 8中接口方法可以包含实现，类可以从多个接口中继承它们的行为（即实现的代码）。让我们从一个例子入手，看看如何充分利用这种能力来为我们服务。保持接口的精致性和正交性能帮助你在现有的代码基上最大程度地实现代码复用和行为组合。</p>
<h3 id="3-2-2-利用正交方法的精简接口"><a href="#3-2-2-利用正交方法的精简接口" class="headerlink" title="3.2.2 利用正交方法的精简接口"></a>3.2.2 利用正交方法的精简接口</h3><p>假设你需要为你正在创建的游戏定义多个具有不同特质的形状。有的形状需要调整大小，但是不需要有旋转的功能；有的需要能旋转和移动，但是不需要调整大小。这种情况下，你怎么设计才能尽可能地重用代码？<br>你可以定义一个单独的 Rotatable 接口，并提供两个抽象方法 setRotationAngle 和getRotationAngle ，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rotatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRotationAngle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationAngle</span><span class="params">(<span class="keyword">int</span> angleInDegrees)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">rotateBy</span><span class="params">(<span class="keyword">int</span> angleInDegrees)</span> </span>&#123;</span><br><span class="line">        setRotationAngle((getRotationAngle() + angleInDegrees) % <span class="number">360</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式和模板设计模式有些相似，都是以其他方法需要实现的方法定义好框架算法。<br>现在，实现了 Rotatable 的所有类都需要提供 setRotationAngle 和 getRotationAngle的实现，但与此同时它们也会天然地继承 rotateBy 的默认实现。<br>类似地，你可以定义之前看到的两个接口 Moveable 和 Resizable 。它们都包含了默认实现。下面是 Moveable 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">moveHorizontally</span><span class="params">(<span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        setX(getX() + distance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">moveVertically</span><span class="params">(<span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        setY(getY() + distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">下面是 Resizable 的代码：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resizable</span> <span class="keyword">extends</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> height)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAbsoluteSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setRelativeSize</span><span class="params">(<span class="keyword">int</span> wFactor, <span class="keyword">int</span> hFactor)</span></span>&#123;</span><br><span class="line">        setAbsoluteSize(getWidth() / wFactor, getHeight() / hFactor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-组合接口"><a href="#3-2-3-组合接口" class="headerlink" title="3.2.3 组合接口"></a>3.2.3 组合接口</h3><p>通过组合这些接口，你现在可以为你的游戏创建不同的实体类。比如， Monster 可以移动、旋转和缩放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monster</span> <span class="keyword">implements</span> <span class="title">Rotatable</span>, <span class="title">Moveable</span>, <span class="title">Resizable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Monster 类会自动继承 Rotatable 、 Moveable 和 Resizable 接口的默认方法。这个例子中，Monster 继承了 rotateBy 、 moveHorizontally 、 moveVertically 和 setRelativeSize 的实现。<br>你现在可以直接调用不同的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Monster m = <span class="keyword">new</span> Monster();</span><br><span class="line">m.rotateBy(<span class="number">180</span>);</span><br><span class="line">m.moveVertically(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>像你的游戏代码那样使用默认实现来定义简单的接口还有另一个好处。假设你需要修改moveVertically 的实现，让它更高效地运行。你可以在 Moveable 接口内直接修改它的实现，所有实现该接口的类会自动继承新的代码（这里我们假设用户并未定义自己的方法实现）。<br>通过前面的介绍，你已经了解了默认方法多种强大的使用模式。不过也可能还有一些疑惑：如果一个类同时实现了两个接口，这两个接口恰巧又提供了同样的默认方法签名，这时会发生什么情况？类会选择使用哪一个方法？这些问题，我们会在接下来的一节进行讨论。</p>
<h1 id="4-解决冲突的规则"><a href="#4-解决冲突的规则" class="headerlink" title="4. 解决冲突的规则"></a>4. 解决冲突的规则</h1><p>随着默认方法在Java 8中引入，有可能出现一个类继承了多个方法而它们使用的却是同样的函数签名。这种情况下，类会选择使用哪一个函数？接下来的例子主要用于说明容易出问题的场景，并不表示这些场景在实际开发过程中会经常发生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello from A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello from B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 猜猜打印的是什么？</span></span><br><span class="line">        <span class="keyword">new</span> C().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，你可能早就对C++语言中著名的菱形继承问题有所了解，菱形继承问题中一个类同时继承了具有相同函数签名的两个方法。到底该选择哪一个实现呢？ Java 8也提供了解决这个问题的方案。请接着阅读下面的内容。</p>
<h2 id="4-1-解决问题的三条规则"><a href="#4-1-解决问题的三条规则" class="headerlink" title="4.1 解决问题的三条规则"></a>4.1 解决问题的三条规则</h2><p>如果一个类使用相同的函数签名从多个地方（比如另一个类或接口）继承了方法，通过三条规则可以进行判断。</p>
<ol>
<li>类中的方法优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。</li>
<li>如果无法依据第一条进行判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果 B 继承了 A ，那么 B 就比 A 更加具体。</li>
<li>最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法，显式地选择使用哪一个默认方法的实现。</li>
</ol>
<h2 id="4-2-菱形继承问题"><a href="#4-2-菱形继承问题" class="headerlink" title="4.2 菱形继承问题"></a>4.2 菱形继承问题</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/09.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%209%EF%BC%9A%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/3.png" alt=""></p>
<p>了解即可</p>
<h1 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h1><ol>
<li>Java 8中的接口可以通过默认方法和静态方法提供方法的代码实现。</li>
<li>默认方法的开头以关键字 default 修饰，方法体与常规的类方法相同。</li>
<li>向发布的接口添加抽象方法不是源码兼容的。</li>
<li>默认方法的出现能帮助库的设计者以后向兼容的方式演进API。</li>
<li>默认方法可以用于创建可选方法和行为的多继承。</li>
<li>我们有办法解决由于一个类从多个接口中继承了拥有相同函数签名的方法而导致的冲突。</li>
<li>类或者父类中声明的方法的优先级高于任何默认方法。如果前一条无法解决冲突，那就选择同函数签名的方法中实现得最具体的那个接口的方法。</li>
<li>两个默认方法都同样具体时，你需要在类中覆盖该方法，显式地选择使用哪个接口中提供的默认方法。</li>
</ol>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-18T11:34:52.000Z" title="2019-03-18T11:34:52.000Z">2019-03-18</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">21 分钟 读完 (大约 3124 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/9d40e29b.html">《Java 8 in Action》Chapter 8：重构、测试和调试</a></h1><div class="content"><blockquote>
<p>我们会介绍几种方法，帮助你重构代码，以适配使用Lambda表达式，让你的代码具备更好的可读性和灵活性。除此之外，我们还会讨论目前比较流行的几种面向对象的设计模式，<br>包括策略模式、模板方法模式、观察者模式、责任链模式，以及工厂模式，在结合Lambda表达式之后变得更简洁的情况。最后，我们会介绍如何测试和调试使用Lambda表达式和Stream API的代码。</p>
</blockquote>
<h1 id="1-为改善可读性和灵活性重构代码"><a href="#1-为改善可读性和灵活性重构代码" class="headerlink" title="1. 为改善可读性和灵活性重构代码"></a>1. 为改善可读性和灵活性重构代码</h1><h2 id="1-1-改善代码的可读性"><a href="#1-1-改善代码的可读性" class="headerlink" title="1.1 改善代码的可读性"></a>1.1 改善代码的可读性</h2><p>Java 8的新特性也可以帮助提升代码的可读性: </p>
<ul>
<li>使用Java 8，你可以减少冗长的代码，让代码更易于理解</li>
<li>通过方法引用和Stream API，你的代码会变得更直观</li>
</ul>
<p>利用Lambda表达式、方法引用以及Stream改善程序代码的可读性:</p>
<ul>
<li>重构代码，用Lambda表达式取代匿名类</li>
<li>用方法引用重构Lambda表达式</li>
<li>用Stream API重构命令式的数据处理 </li>
</ul>
<h2 id="1-2-从匿名内部类到Lambda表达式的转换"><a href="#1-2-从匿名内部类到Lambda表达式的转换" class="headerlink" title="1.2 从匿名内部类到Lambda表达式的转换"></a>1.2 从匿名内部类到Lambda表达式的转换</h2><p>将实现单一抽象方法的匿名类转换为Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统的方式，使用匿名类</span></span><br><span class="line">Runnable r1 = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新的方式，使用Lambda表达式</span></span><br><span class="line">Runnable r2 = () -&gt; System.out.println(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure>

<p>匿名 类和Lambda表达式中的this和super的含义是不同的。在匿名类中，this代表的是类自身，但是在Lambda中，它代表的是包含类。其次，匿名类可以屏蔽包含类的变量，而Lambda表达式不能(它们会导致编译错误)，如下面这段代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">Runnable r1 = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;                    <span class="comment">// 编译错误</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;;</span><br><span class="line">Runnable r2 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2</span>;                <span class="comment">// 正常</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在涉及重􏰴的上下文里，将匿名类转换为Lambda表达式可能导致最终的代码更加晦涩。实际上，匿名类的类型是在初始化时确定的，而Lambda的类型取决于它的上下文。通过下面这个例子，我们可以了解问题是如何发生的。我们假设你用与Runnable同样的签名声明了一个函数接口，我们称之为Task:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Runnable r)</span></span>&#123; r.run(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Task a)</span></span>&#123; a.execute(); &#125;</span><br><span class="line">doSomething(<span class="keyword">new</span> Task() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Danger danger!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// doSomething(Runnable) 和 doSomething(Task) 都匹配该类型</span></span><br><span class="line">doSomething(() -&gt; System.out.println(<span class="string">"Danger danger!!"</span>));</span><br><span class="line"><span class="comment">// 使用显式的类型转换来解决这种模棱两可的情况</span></span><br><span class="line">doSomething((Task)() -&gt; System.out.println(<span class="string">"Danger danger!!"</span>));</span><br></pre></td></tr></table></figure>
<p>目前大多数的集成开发环境，比如NetBeans和IntelliJ都支持这种重构，它们能自动地帮你检查，避免发生这些问题。</p>
<h2 id="1-3-从Lambda表达式到方法引用的转换"><a href="#1-3-从Lambda表达式到方法引用的转换" class="headerlink" title="1.3 从Lambda表达式到方法引用的转换"></a>1.3 从Lambda表达式到方法引用的转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByCaloricLevel =</span><br><span class="line">        menu.stream()</span><br><span class="line">            .collect(</span><br><span class="line">                groupingBy(dish -&gt; &#123;</span><br><span class="line">                     <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>将Lambda表达式的内容抽取到一个单独的方法中，将其作为参数传递给groupingBy方法。变换之后，代码变得更加简洁，程序的意图也更加清晰了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByCaloricLevel = menu.stream().collect(groupingBy(Dish::getCaloricLevel));</span><br></pre></td></tr></table></figure>

<h2 id="1-4-从命令式的数据处理切换到Stream"><a href="#1-4-从命令式的数据处理切换到Stream" class="headerlink" title="1.4 从命令式的数据处理切换到Stream"></a>1.4 从命令式的数据处理切换到Stream</h2><p>我们建议你将所有使用迭代器这种数据处理模式处理集合的代码都转换成Stream API的方式。为什么呢?<br>Stream API能更清晰地表达数据处理管道的意图。除此之外，通过短路和延迟载入以及利用第7章介绍的现代计算机的多核架构，我们可以对Stream进行优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令式版本</span></span><br><span class="line">List&lt;String&gt; dishNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Dish dish: menu)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dish.getCalories() &gt; <span class="number">300</span>)&#123;</span><br><span class="line">            dishNames.add(dish.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用Stream API</span></span><br><span class="line">menu.parallelStream()</span><br><span class="line">        .filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)</span><br><span class="line">        .map(Dish::getName)</span><br><span class="line">        .collect(toList());</span><br></pre></td></tr></table></figure>

<h2 id="1-5-增加代码的灵活性"><a href="#1-5-增加代码的灵活性" class="headerlink" title="1.5 增加代码的灵活性"></a>1.5 增加代码的灵活性</h2><p>没有函数式接口就无法使用Lambda表达式，因此代码中需要引入函数式接口。引入函数式接口的两种通用模式：</p>
<ul>
<li>有条件的延迟执行</li>
<li>环绕执行</li>
</ul>
<h2 id="2-使用Lambda重构面向对象的设计模式"><a href="#2-使用Lambda重构面向对象的设计模式" class="headerlink" title="2. 使用Lambda重构面向对象的设计模式"></a>2. 使用Lambda重构面向对象的设计模式</h2><p>使用Lambda表达式后，很多现存的略显臃肿的面向对象设计模式能够用更精简的方式实现了。这一节中，我们会针对五个设计模式展开讨论，它们分别是:</p>
<ul>
<li>策略模式</li>
<li>模板方法</li>
<li>观察者模式</li>
<li>责任链模式</li>
<li>工厂模式</li>
</ul>
<h2 id="2-1-策略模式"><a href="#2-1-策略模式" class="headerlink" title="2.1 策略模式"></a>2.1 策略模式</h2><p>策略模式代表了解决一类算法的通用解决方案，你可以在运行时选择使用哪种方案。策略模式包含三部分内容，如图所示。</p>
<ul>
<li>一个代表某个算法的接口(它是策略模式的接口)。 </li>
<li>一个或多个该接口的具体实现，它们代表了算法的多种实现(比如，实体类ConcreteStrategyA或者ConcreteStrategyB)。</li>
<li>一个或多个使用策略对象的客户。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/08.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%208%EF%BC%9A%E9%87%8D%E6%9E%84%E3%80%81%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B0%83%E8%AF%95/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValidationStrategy</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsAllLowerCase</span> <span class="keyword">implements</span> <span class="title">ValidationStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(<span class="string">"[a-z]+"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsNumber</span> <span class="keyword">implements</span> <span class="title">ValidationStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(<span class="string">"\\d+"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ValidationStrategy strategy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Validator</span><span class="params">(ValidationStrategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.execute(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Validator numericValidator = <span class="keyword">new</span> Validator(<span class="keyword">new</span> IsNumber());</span><br><span class="line">        <span class="keyword">boolean</span> b1 = numericValidator.validate(<span class="string">"aaaa"</span>);</span><br><span class="line">        Validator lowerCaseValidator = <span class="keyword">new</span> Validator(<span class="keyword">new</span> IsAllLowerCase());</span><br><span class="line">        <span class="keyword">boolean</span> b2 = lowerCaseValidator.validate(<span class="string">"bbbb"</span>);</span><br><span class="line">        System.out.println(b1 + <span class="string">" "</span> + b2);</span><br><span class="line">        Validator numericValidator1 = <span class="keyword">new</span> Validator((String s) -&gt; s.matches(<span class="string">"[a-z]+"</span>));</span><br><span class="line">        <span class="keyword">boolean</span> b11 = numericValidator1.validate(<span class="string">"aaaa"</span>);</span><br><span class="line">        Validator lowerCaseValidator1 = <span class="keyword">new</span> Validator((String s) -&gt; s.matches(<span class="string">"\\d+"</span>));</span><br><span class="line">        <span class="keyword">boolean</span> b21 = lowerCaseValidator.validate(<span class="string">"bbbb"</span>);</span><br><span class="line">        System.out.println(b11 + <span class="string">" "</span> + b21);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-模板方法"><a href="#2-2-模板方法" class="headerlink" title="2.2 模板方法"></a>2.2 模板方法</h2><p>模板 方法模式在你“希望使用这个算法，但是需要对其中的某些行进行改进，才能达到希望的效果” 时是非常有用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlineBanking</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processCustomer</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Customer c = DataUtil.getCustomerWithId(id);</span><br><span class="line">        makeCustomerHappy(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeCustomerHappy</span><span class="params">(Customer c)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlineBankingLambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processCustomer</span><span class="params">(<span class="keyword">int</span> id, Consumer&lt;Customer&gt; consumer)</span> </span>&#123;</span><br><span class="line">        Customer c = DataUtil.getCustomerWithId(id);</span><br><span class="line">        consumer.accept(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> OnlineBanking() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">makeCustomerHappy</span><span class="params">(Customer c)</span> </span>&#123;</span><br><span class="line">                System.out.println(c.getName() + <span class="string">" happy!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.processCustomer(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> OnlineBankingLambda().processCustomer(<span class="number">1</span>, (Customer c) -&gt; System.out.println(c.getName() + <span class="string">" happy!"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-观察者模式"><a href="#2-3-观察者模式" class="headerlink" title="2.3 观察者模式"></a>2.3 观察者模式</h2><p>观察者模式是一种比较常见的方案，某些事件发生时(比如状态转变)，如果一个对象(通常我们称之为主题)需要自动地通知其他多个对象(称为观察者)，就会采用该方案。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/08.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%208%EF%BC%9A%E9%87%8D%E6%9E%84%E3%80%81%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B0%83%E8%AF%95/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(String tweet)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYTime</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String tweet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tweet != <span class="keyword">null</span> &amp;&amp; tweet.contains(<span class="string">"money"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Breaking news in NY! "</span> + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Guardian</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String tweet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tweet != <span class="keyword">null</span> &amp;&amp; tweet.contains(<span class="string">"queen"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Yet another news in London... "</span> + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeMonde</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String tweet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tweet != <span class="keyword">null</span> &amp;&amp; tweet.contains(<span class="string">"wine"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Today cheese, wine and news! "</span> + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nofityObservers</span><span class="params">(String tweet)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Feed</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nofityObservers</span><span class="params">(String tweet)</span> </span>&#123;</span><br><span class="line">        observers.forEach(o -&gt; o.notify(tweet));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Feed f = <span class="keyword">new</span> Feed();</span><br><span class="line">        f.registerObserver(<span class="keyword">new</span> NYTime());</span><br><span class="line">        f.registerObserver(<span class="keyword">new</span> Guardian());</span><br><span class="line">        f.registerObserver(<span class="keyword">new</span> LeMonde());</span><br><span class="line">        f.nofityObservers(<span class="string">"The queen said her favourite book is Java 8 in Action!"</span>);</span><br><span class="line">        f.registerObserver((String tweet) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (tweet != <span class="keyword">null</span> &amp;&amp; tweet.contains(<span class="string">"money"</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Breaking news in NY! "</span> + tweet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        f.registerObserver((String tweet) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (tweet != <span class="keyword">null</span> &amp;&amp; tweet.contains(<span class="string">"queen"</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Yet another news in London... "</span> + tweet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-责任链模式"><a href="#2-4-责任链模式" class="headerlink" title="2.4 责任链模式"></a>2.4 责任链模式</h2><p>责任链模式是一种创建处理对象序列(比如操作序列)的通用方案。一个处理对象可能需要在完成一些工作之后，将结果传递给另一个对象，这个对象接着做一些工作，再转交给下一个处理对象，以此类推。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/08.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%208%EF%BC%9A%E9%87%8D%E6%9E%84%E3%80%81%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B0%83%E8%AF%95/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessingObject</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> ProcessingObject&lt;T&gt; successor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(ProcessingObject&lt;T&gt; successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">handle</span><span class="params">(T input)</span> </span>&#123;</span><br><span class="line">        T r = handleWork(input);</span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> successor.handle(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> T <span class="title">handleWork</span><span class="params">(T input)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderTextProcessing</span> <span class="keyword">extends</span> <span class="title">ProcessingObject</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">handleWork</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"From Raoul, Mario and Alan: "</span> + input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellCheckerProcessing</span> <span class="keyword">extends</span> <span class="title">ProcessingObject</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">handleWork</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.replaceAll(<span class="string">"labda"</span>, <span class="string">"lambda"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainOfResponsibilityDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProcessingObject&lt;String&gt; p1 = <span class="keyword">new</span> HeaderTextProcessing();</span><br><span class="line">        ProcessingObject&lt;String&gt; p2 = <span class="keyword">new</span> SpellCheckerProcessing();</span><br><span class="line">        p1.setSuccessor(p2);</span><br><span class="line">        String result = p1.handle(<span class="string">"Aren't labdas really sexy?!!"</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        UnaryOperator&lt;String&gt; headerProcessing = (String text) -&gt; <span class="string">"From Raoul, Mario and Alan: "</span> + text;</span><br><span class="line">        UnaryOperator&lt;String&gt; spellCheckerProcessing = (String text) -&gt; text.replaceAll(<span class="string">"labda"</span>, <span class="string">"lambda"</span>);</span><br><span class="line">        Function&lt;String, String&gt; pipeline = headerProcessing.andThen(spellCheckerProcessing);</span><br><span class="line">        String result1 = pipeline.apply(<span class="string">"Aren't labdas really sexy?!!"</span>);</span><br><span class="line">        System.out.println(result1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-工厂模式"><a href="#2-5-工厂模式" class="headerlink" title="2.5 工厂模式"></a>2.5 工厂模式</h2><p>使用工厂模式，你无需向客户暴露实例化的逻辑就能完成对象的创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Loan</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stock</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bond</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"loan"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Loan();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"stock"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Stock();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"bond"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Bond();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No such product "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product p = ProductFactory.createProduct(<span class="string">"loan"</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactoryLambda</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, Supplier&lt;Product&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">"loan"</span>, Loan::<span class="keyword">new</span>);</span><br><span class="line">        map.put(<span class="string">"stock"</span>, Stock::<span class="keyword">new</span>);</span><br><span class="line">        map.put(<span class="string">"bond"</span>, Bond::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Product&gt; p = map.get(name);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> p.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No such product "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product p = ProductFactoryLambda.createProduct(<span class="string">"loan"</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-测试Lambda表达式"><a href="#3-测试Lambda表达式" class="headerlink" title="3. 测试Lambda表达式"></a>3. 测试Lambda表达式</h1><p>略</p>
<h1 id="4-调试Lambda表达式"><a href="#4-调试Lambda表达式" class="headerlink" title="4. 调试Lambda表达式"></a>4. 调试Lambda表达式</h1><h2 id="4-1-查看栈跟踪"><a href="#4-1-查看栈跟踪" class="headerlink" title="4.1 查看栈跟踪"></a>4.1 查看栈跟踪</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Debugging</span></span>&#123; <span class="number">11</span> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Point&gt; points = Arrays.asList(<span class="keyword">new</span> Point(<span class="number">12</span>, <span class="number">2</span>), <span class="keyword">null</span>);</span><br><span class="line">        points.stream().map(p -&gt; p.getX()).forEach(System.out::println); &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行这段代码会产生下面的栈跟踪:</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NullPointerException</span><br><span class="line">at Debugging.lambda$main$<span class="number">0</span>(Debugging.java:<span class="number">6</span>)</span><br><span class="line">at Debugging$$Lambda$<span class="number">5</span>/<span class="number">284720968</span>.apply(Unknown Source)</span><br><span class="line">at java.util.stream.ReferencePipeline$<span class="number">3</span>$<span class="number">1</span>.accept(ReferencePipeline</span><br><span class="line">.java:<span class="number">193</span>)</span><br><span class="line">at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators</span><br><span class="line">.java:<span class="number">948</span>)</span><br></pre></td></tr></table></figure>
<p>我们需要特别注意，涉及Lambda表达式的栈􏱡􏴭可能非常难理解。这是Java编译器未来版本可以改进的一个方面。</p>
<h2 id="4-2-使用日志调试"><a href="#4-2-使用日志调试" class="headerlink" title="4.2 使用日志调试"></a>4.2 使用日志调试</h2><p>peek的设计初衷就是在流的每个元素恢复运行之前，插入执行一个动作。但是它不像forEach那样恢复整个流的运行，而是在一个元素上完成操作之后，它只会将操作顺承到流水线中的下一个操作。图8-4解释了peek的操作流程。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/08.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%208%EF%BC%9A%E9%87%8D%E6%9E%84%E3%80%81%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B0%83%E8%AF%95/peek.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; result = numbers.stream()</span><br><span class="line">         .peek(x -&gt; System.out.println(<span class="string">"from stream: "</span> + x))</span><br><span class="line">         .map(x -&gt; x + <span class="number">17</span>)</span><br><span class="line">         .peek(x -&gt; System.out.println(<span class="string">"after map: "</span> + x))</span><br><span class="line">         .filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">         .peek(x -&gt; System.out.println(<span class="string">"after filter: "</span> + x))</span><br><span class="line">         .limit(<span class="number">3</span>)</span><br><span class="line">         .peek(x -&gt; System.out.println(<span class="string">"after limit: "</span> + x))</span><br><span class="line">         .collect(toList());</span><br><span class="line">输出结果：</span><br><span class="line">from stream: <span class="number">2</span></span><br><span class="line">after map: <span class="number">19</span></span><br><span class="line">from stream: <span class="number">3</span></span><br><span class="line">after map: <span class="number">20</span></span><br><span class="line">after filter: <span class="number">20</span></span><br><span class="line">after limit: <span class="number">20</span></span><br><span class="line">from stream: <span class="number">4</span></span><br><span class="line">after map: <span class="number">21</span></span><br><span class="line">from stream: <span class="number">5</span></span><br><span class="line">after map: <span class="number">22</span></span><br><span class="line">after filter: <span class="number">22</span></span><br><span class="line">after limit: <span class="number">22</span></span><br></pre></td></tr></table></figure>

<h1 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h1><ul>
<li>Lambda表达式能提升代码的可读性和灵活性。</li>
<li>如果你的代码中使用了匿名类，尽量用Lambda表达式替换它们，但是要注意二者间语义的微妙差别，比如关键字this，以及变量隐藏。</li>
<li>Lambda表达式比起来，方法引用的可读性更好。</li>
<li>尽量使用Stream API替换迭代式的集合处理。</li>
<li>Lambda表达式有助于避免使用面向对象设计模式时容易出现的􏳂化的模板代码，典型的比如策略模式、模板方法、观察者模式、责任链模式，以及工厂模式。</li>
<li>即使采用了Lambda表达式，也同样可以进行单元测试，但是通常你应该关注使用了Lambda表达式的方法的行为。</li>
<li>尽量将复杂的Lambda表达式抽象到普通方法中。</li>
<li>Lambda表达式会让栈跟踪的分析变得更为复杂。</li>
<li>流提供的peek方法在分析Stream流水线时，能将中间变量的值输出到日志中，是非常有用的工具。</li>
</ul>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/Java/page/0/">上一页</a></div><div class="pagination-next"><a href="/categories/Java/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/Java/">1</a></li><li><a class="pagination-link" href="/categories/Java/page/2/">2</a></li></ul></nav></div><!--!--><div class="column column-right is-3-tablet is-3-desktop is-3-widescreen  order-3"><!--!--><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="/img/avatar.png" alt="后端小哥"></figure><p class="title is-size-4 is-block line-height-inherit">后端小哥</p><p class="is-size-6 is-block">Coder</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shijiazhuang, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">111</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">20</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">67</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/lujiahao0708" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://juejin.im/user/59239002570c350069c5f0bb" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">掘金</span></span><span class="level-right"><span class="level-item tag">juejin.im</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://blog.csdn.net/xinruodingshui" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://space.bilibili.com/302086424/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">B站</span></span><span class="level-right"><span class="level-item tag">space.bilibili.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Chrome/"><span class="level-start"><span class="level-item">Chrome</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Flutter/"><span class="level-start"><span class="level-item">Flutter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Hexo/"><span class="level-start"><span class="level-item">Hexo</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JavaEE/"><span class="level-start"><span class="level-item">JavaEE</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Mac/"><span class="level-start"><span class="level-item">Mac</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"><span class="level-start"><span class="level-item">MySQL必知必会</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Shiro/"><span class="level-start"><span class="level-item">Shiro</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Simpleblog%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">Simpleblog博客系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/SpringCloud/"><span class="level-start"><span class="level-item">SpringCloud</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"><span class="level-start"><span class="level-item">工具教程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B9%B6%E5%8F%91/"><span class="level-start"><span class="level-item">并发</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"><span class="level-start"><span class="level-item">持续集成</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%97%A5%E5%BF%97/"><span class="level-start"><span class="level-item">日志</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-07T20:40:52.000Z">2020-05-07</time></p><p class="title is-6"><a class="link-muted" href="/p/43930bbd.html">Redis 系列（三）Redis 常用命令</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Redis/">Redis</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-04T20:40:52.000Z">2020-05-04</time></p><p class="title is-6"><a class="link-muted" href="/p/fe744d5a.html">Redis 系列（二）Redis 安装</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Redis/">Redis</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-01T17:40:52.000Z">2020-05-01</time></p><p class="title is-6"><a class="link-muted" href="/p/c8bef241.html">Redis 系列（一）NoSQL 简介</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Redis/">Redis</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-21T22:03:59.000Z">2020-04-21</time></p><p class="title is-6"><a class="link-muted" href="/p/29174125.html">Hexo 生成永久文章链接</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Hexo/">Hexo</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-20T10:40:52.000Z">2020-04-20</time></p><p class="title is-6"><a class="link-muted" href="/p/5c6f02af.html">Mac 多 Git 账户配置</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Mac/">Mac</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="后端小哥博客" height="28"></a><p class="size-small"><span>&copy; 2020 后端小哥</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/lujiahao0708"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://lujiahao0708.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: ''
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>