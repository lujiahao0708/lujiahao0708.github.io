<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>后端小哥博客</title><meta description="一个 Java 程序猿"><meta property="og:type" content="blog"><meta property="og:title" content="后端小哥博客"><meta property="og:url" content="http://lujiahao0708.github.io/"><meta property="og:site_name" content="后端小哥博客"><meta property="og:description" content="一个 Java 程序猿"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="后端小哥"><meta property="article:tag" content="博客"><meta property="article:tag" content="技术博客"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://lujiahao0708.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://lujiahao0708.github.io"},"headline":"后端小哥博客","image":["http://lujiahao0708.github.io/img/og_image.png"],"author":{"@type":"Person","name":"后端小哥"},"description":"一个 Java 程序猿"}</script><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="/css/default.css"><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cdef3b7efc8748063e32969cc0b8dedc";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="后端小哥博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories/Redis">Redis</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/lujiahao0708"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-08T11:34:52.000Z" title="2019-03-08T11:34:52.000Z">2019-03-08</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">11 分钟 读完 (大约 1645 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/d8840bff.html">《Java 8 in Action》Chapter 4：引入流</a></h1><div class="content"><h1 id="1-流简介"><a href="#1-流简介" class="headerlink" title="1. 流简介"></a>1. 流简介</h1><p>流是Java API的新成员，它允许你以声明性方式处理数据集合(通过查询语句来表达，而不是临时编写一个实现)。就现在来说，你可以把它们看成遍历数据集的高级迭代器。此外，流还可以透明地并行处理。让我们来看一个实例返回低热量(&lt;400)的菜肴名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Java7版本：</span><br><span class="line">List&lt;Dish&gt; lowCaloricDishes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 用累加器筛选元素</span></span><br><span class="line"><span class="keyword">for</span>(Dish d: menu)&#123;</span><br><span class="line">    <span class="keyword">if</span>(d.getCalories() &lt; <span class="number">400</span>)&#123;</span><br><span class="line">        lowCaloricDishes.add(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用匿名类对菜肴排序</span></span><br><span class="line">Collections.sort(lowCaloricDishes, <span class="keyword">new</span> Comparator&lt;Dish&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dish d1, Dish d2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(d1.getCalories(), d2.getCalories());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 处理排序后的菜名列表</span></span><br><span class="line">List&lt;String&gt; lowCaloricDishesName = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Dish d: lowCaloricDishes)&#123;</span><br><span class="line">    lowCaloricDishesName.add(d.getName());</span><br><span class="line">&#125;</span><br><span class="line">Java8版本：</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.comparing;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList;</span><br><span class="line">List&lt;String&gt; lowCaloricDishesName = menu.stream()</span><br><span class="line">                                        .filter(d -&gt; d.getCalories() &lt; <span class="number">400</span>)    <span class="comment">// 选出400卡路里以下的菜肴</span></span><br><span class="line">                                        .sorted(comparing(Dish::getCalories))    <span class="comment">// 按照卡路里排序</span></span><br><span class="line">                                        .map(Dish::getName)                    <span class="comment">// 提取菜肴名称</span></span><br><span class="line">                                        .collect(toList());                    <span class="comment">// 将所有的名称保存在List中</span></span><br><span class="line">利用多核架构并行执行，只需要把stream()换成parallelStream()</span><br></pre></td></tr></table></figure>

<p>Java 8中的Stream API特性：</p>
<ul>
<li>声明性——更简洁，更易读</li>
<li>可复合——更灵活 </li>
<li>可并行——性能更好</li>
</ul>
<p>流定义：</p>
<ul>
<li>元素序列——就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序 值。</li>
<li>源——流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集 合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</li>
<li>数据处理操作——流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。</li>
<li>流水线——很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。这让我们下一章中的一些优化成为可能，如延迟和短路。流水线的操作可以看作对数据源进行数据库式查询。</li>
<li>内部迭代——与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/04.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%204%EF%BC%9A%E5%BC%95%E5%85%A5%E6%B5%81/1.%E7%AD%9B%E9%80%89%E8%8F%9C%E8%82%B4.png" alt=""></p>
<h1 id="2-流与集合"><a href="#2-流与集合" class="headerlink" title="2. 流与集合"></a>2. 流与集合</h1><p>集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。相比之下，流则是在概念上固定的数据结构(你不能添加或删除元素)，其元素则是按需计算的。集合和流的另一个关键区别在于它们遍历数据的方式。</p>
<h2 id="2-1-只能遍历一次"><a href="#2-1-只能遍历一次" class="headerlink" title="2.1 只能遍历一次"></a>2.1 只能遍历一次</h2><p>和迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。以下代码会抛出一个异常，说流已被消费掉了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; title = Arrays.asList(“Java8”,”In”, “Action”);</span><br><span class="line">Stream&lt;String&gt; s = title.stream();</span><br><span class="line">s.forEach(System.out::println);</span><br><span class="line">s.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalStateException: stream has already been operated upon or closed</span><br><span class="line">	at java.util.stream.AbstractPipeline.sourceStageSpliterator(AbstractPipeline.java:<span class="number">279</span>)</span><br><span class="line">	at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:<span class="number">580</span>)</span><br><span class="line">	at com.lujiahao.learnjava8.chapter4.StreamAndCollection.main(StreamAndCollection.java:<span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<h2 id="2-2-外部迭代与内部迭代"><a href="#2-2-外部迭代与内部迭代" class="headerlink" title="2.2 外部迭代与内部迭代"></a>2.2 外部迭代与内部迭代</h2><p>使用Collection接口需要用户去做迭代(比如用for-each)，这称为外部迭代。相反,Streams库使用内部迭代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">集合:用<span class="keyword">for</span>-each循环外部迭代</span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Dish d: menu)&#123;</span><br><span class="line">    names.add(d.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">集合:用背后的迭代器做外部迭代</span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator = menu.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    Dish d = iterator.next();</span><br><span class="line">    names.add(d.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">流:内部迭代</span><br><span class="line">List&lt;String&gt; names = menu.stream()</span><br><span class="line">                        .map(Dish::getName)</span><br><span class="line">                        .collect(toList());</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/04.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%204%EF%BC%9A%E5%BC%95%E5%85%A5%E6%B5%81/2.%E5%86%85%E9%83%A8%E8%BF%AD%E4%BB%A3%E4%B8%8E%E5%A4%96%E9%83%A8%E8%BF%AD%E4%BB%A3.png" alt=""></p>
<h1 id="3-流操作"><a href="#3-流操作" class="headerlink" title="3. 流操作"></a>3. 流操作</h1><p>java.util.stream.Stream中的Stream接口定义了许多操作。它们可以分为两大类。可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作。<br>中间操作：除非流水线上触发一个终端操作，否则中间操作不会执行任何处理。<br>终端操作：会从流的流水线生成结果。其结果是任何不是流的值。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/04.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%204%EF%BC%9A%E5%BC%95%E5%85%A5%E6%B5%81/3.%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C.png" alt=""></p>
<p>流的使用一般包括三件事:</p>
<ul>
<li>一个数据源(如集合)来执行一个查询;</li>
<li>一个中间操作链，形成一条流的流水线;</li>
<li>一个终端操作，执行流水线，并能生成结果。</li>
</ul>
<blockquote>
<p>流的流水线背后的理念类似于构建器模式。</p>
</blockquote>
<p>常见流操作：<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/04.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%204%EF%BC%9A%E5%BC%95%E5%85%A5%E6%B5%81/4.%E5%B8%B8%E8%A7%81%E6%B5%81%E6%93%8D%E4%BD%9C.png" alt=""></p>
<h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h1><p>以下是你应从本章中学到的一些关键概念。</p>
<ul>
<li>流是“从支持数据处理操作的源生成的一系列元素”。</li>
<li>流利用内部迭代:迭代通过filter、map、sorted等操作被抽象掉了。</li>
<li>流操作有两类:中间操作和终端操作。</li>
<li>filter和map等中间操作会返回一个流，并可以链接在一起。可以用它们来设置一条流水线，但并不会生成任何结果</li>
<li>forEach和count等终端操作会返回一个非流的值，并处理流水线以返回结果。</li>
<li>流中的元素是按需计算的。</li>
</ul>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-07T22:34:52.000Z" title="2019-03-07T22:34:52.000Z">2019-03-07</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">23 分钟 读完 (大约 3425 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/b1d345e3.html">《Java 8 in Action》Chapter 3：Lambda表达式</a></h1><div class="content"><h1 id="1-Lambda简介"><a href="#1-Lambda简介" class="headerlink" title="1. Lambda简介"></a>1. Lambda简介</h1><p>可以把Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。</p>
<ul>
<li>匿名——我们说匿名，是因为它不像普通的方法那样有一个明确的名称:写得少而想得多!</li>
<li>函数——我们说它是函数，是因为Lambda函数不像方法那样属于某个特定的类。但和方法一样，Lambda有参数列表、函数主体、返回类型，还可能有可以抛出的异常列表。</li>
<li>传递——Lambda表达式可以作为参数传递给方法或存储在变量中。</li>
<li>简洁——无需像匿名类那样写很多模板代码。</li>
</ul>
<h1 id="2-Lambda写法"><a href="#2-Lambda写法" class="headerlink" title="2. Lambda写法"></a>2. Lambda写法</h1><p><code>(parameters) -&gt; expression 或 (parameters) -&gt; { statements; }</code><br><code>eg：(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</code><br>Lambda表达式有三个部分:</p>
<ul>
<li>参数列表——这里它采用了Comparator中compare方法的参数，两个Apple。 </li>
<li>箭头——箭头-&gt;把参数列表与Lambda主体分隔开。</li>
<li>Lambda主体——比较两个Apple的重量。表达式就是Lambda的返回值了。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%203%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/1.lambda%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<h1 id="3-函数式接口和函数描述符"><a href="#3-函数式接口和函数描述符" class="headerlink" title="3. 函数式接口和函数描述符"></a>3. 函数式接口和函数描述符</h1><p>函数式接口就是只定义一个抽象方法的接口。接口上标有<code>@FunctionalInterface</code>表示该接口会设计成 一个函数式接口，如果你用<code>@FunctionalInterface</code>定义了一个接口，而它却不是函数式接口的话，编译器将返回一个提示原因的错误。接口现在还可以拥有默认方法(即在类没有对方法进行实现时， 其主体为方法提供默认实现的方法)。哪怕有很多默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。</p>
<p>函数式接口的抽象方法的签名就是Lambda表达式的签名。我们将这种抽象方法叫作：函数描述符。例如，Runnable接口可以看作一个什么也不接受什么也不返回(void)的函数的签名，因为它只有一个叫作run的抽象方法，这个方法什么也不接受，什么也不返回(void)。</p>
<h1 id="4-三种常用的函数式接口"><a href="#4-三种常用的函数式接口" class="headerlink" title="4. 三种常用的函数式接口"></a>4. 三种常用的函数式接口</h1><h2 id="4-1-Predicate"><a href="#4-1-Predicate" class="headerlink" title="4.1 Predicate"></a>4.1 Predicate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a predicate (boolean-valued function) of one argument.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #test(Object)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates this predicate on the given argument.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input argument matches the predicate,</span></span><br><span class="line"><span class="comment">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Predicate的英文示意是：谓词。<br>Predicate接口定义了一个名叫test的抽象方法，它接受泛型T对象，并返回一个boolean。</p>
<h2 id="4-2-Consumer"><a href="#4-2-Consumer" class="headerlink" title="4.2 Consumer"></a>4.2 Consumer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Represents an operation that accepts a single input argument and returns no</span></span><br><span class="line"><span class="comment">* result. Unlike most other functional interfaces, &#123;<span class="doctag">@code</span> Consumer&#125; is expected</span></span><br><span class="line"><span class="comment">* to operate via side-effects.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment">* whose functional method is &#123;<span class="doctag">@link</span> #accept(Object)&#125;.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; the type of the input to the operation</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Performs this operation on the given argument.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Consumer的英文示意是：消费者。<br>Consumer接口定义了一个名叫accept的抽象方法，它接受泛型T对象，并没有返回任何值。</p>
<h2 id="4-3-Function"><a href="#4-3-Function" class="headerlink" title="4.3 Function"></a>4.3 Function</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Represents a function that accepts one argument and produces a result.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment">* whose functional method is &#123;<span class="doctag">@link</span> #apply(Object)&#125;.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; the type of the input to the function</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &lt;R&gt; the type of the result of the function</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Function的英文示意是：功能。<br>Function接口定义了一个名叫apply的抽象方法，它接受泛型T对象，并返回一个泛型R的对象。</p>
<blockquote>
<p>Java还有一个自动装箱机制来帮助程序员执行这一任务:装箱和拆箱操作是自动完成的。但这在性能方面是要付出代价的。装箱后的值本质上就是把原始类型包裹起来，并保存在堆里。因此，装箱后的值需要更多的内存，并需要额外的内存搜索来获取被包裹的原始值。Java 8为我们前面所说的函数式接口带来了一个专门的版本，以便在输入和输出都是原始类型时避免自动装箱的操作。</p>
</blockquote>
<h2 id="4-4-Java-8中的常用函数式接口"><a href="#4-4-Java-8中的常用函数式接口" class="headerlink" title="4.4 Java 8中的常用函数式接口"></a>4.4 Java 8中的常用函数式接口</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%203%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/2.Java%208%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png" alt=""></p>
<h1 id="5-类型检查、类型推断以及限制"><a href="#5-类型检查、类型推断以及限制" class="headerlink" title="5. 类型检查、类型推断以及限制"></a>5. 类型检查、类型推断以及限制</h1><h2 id="5-1-类型检查"><a href="#5-1-类型检查" class="headerlink" title="5.1 类型检查"></a>5.1 类型检查</h2><p>Lambda的类型是从使用Lambda的上下文推断出来的。上下文(比如，接受它传递的方法的参数，或接受它的值的局部变量)中Lambda表达式需要的类型称为目标类型。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%203%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/3.%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5.png" alt=""><br>类型检查过程可以分解为如下所示。</p>
<ul>
<li>首先，你要找出filter方法的声明。</li>
<li>第二，要求它是Predicate<Apple>(目标类型)对象的第二个正式参数。</li>
<li>第三，Predicate<Apple>是一个函数式接口，定义了一个叫作test的抽象方法。</li>
<li>第四，test方法描述了一个函数描述符，它可以接受一个Apple，并返回一个boolean.</li>
<li>最后，filter的任何实际参数都必须匹配这个要求。</li>
</ul>
<p>这段代码是有效的，因为我们所传递的Lambda表达式也同样接受Apple为参数，并返回一个 boolean。请注意，如果Lambda表达式抛出一个异常，那么抽象方法所声明的throws语句也必 须与之匹配。有了目标类型的概念，同一个Lambda表达式就可以与不同的函数式接口联系起来，只要它 们的抽象方法签名能够兼容。比如，前面提到的Callable和PrivilegedAction，这两个接口都代表着什么也不接受且返回一个泛型T的函数。 因此，下面两个赋值是有效的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; c = () -&gt; <span class="number">42</span>;</span><br><span class="line">PrivilegedAction&lt;Integer&gt; p = () -&gt; <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>特殊的void兼容规则<br>如果一个Lambda的主体是一个语句表达式， 它就和一个返回void的函数描述符兼容(当然需要参数列表也兼容)。<br>例如，以下两行都是合法的，尽管List的add方法返回了一个 boolean，而不是Consumer上下文(T -&gt; void)所要求的void:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Predicate返回了一个boolean </span></span><br><span class="line">Predicate&lt;String&gt; p = s -&gt; list.add(s); </span><br><span class="line"><span class="comment">// Consumer返回了一个void </span></span><br><span class="line">Consumer&lt;String&gt; b = s -&gt; list.add(s);</span><br></pre></td></tr></table></figure>

<h2 id="5-2-类型推断"><a href="#5-2-类型推断" class="headerlink" title="5.2 类型推断"></a>5.2 类型推断</h2><p>Java编译器会从上下文(目标类型)推断出用什么函数式接 口来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通过目标类型来得到。这样做的好处在于，编译器可以了解Lambda表达式的参数类型，这样就可以在Lambda语法中省去标注参数类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有类 型推断</span></span><br><span class="line">Comparator&lt;Apple&gt; c = (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()); </span><br><span class="line"><span class="comment">// 有类型推断</span></span><br><span class="line">Comparator&lt;Apple&gt; c = (a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</span><br></pre></td></tr></table></figure>

<h2 id="5-3-使用局部变量"><a href="#5-3-使用局部变量" class="headerlink" title="5.3 使用局部变量"></a>5.3 使用局部变量</h2><p>Lambda表达式 也允许使用自由变量(不是参数，而是在外层作用域中定义的变量)，就像匿名类一样。 它们被 称作捕获Lambda。<br>Lambda捕获的局部变量必须显式声明为final， 或事实上是final。换句话说，Lambda表达式只能捕获指派给它们的局部变量一次。</p>
<ul>
<li>第一，实例变量和局部变量背后的实现有一 个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。</li>
<li>第二，这一限制不鼓励你使用改变外部变量的典型命令式编程模式(我们会在以后的各章中 解释，这种模式会阻碍很容易做到的并行处理)。</li>
</ul>
<h1 id="6-方法引用"><a href="#6-方法引用" class="headerlink" title="6. 方法引用"></a>6. 方法引用</h1><p>方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷 写法，方法引用看作针对仅仅涉及单一方法的Lambda的语法糖。目标引用放在分隔符::前，方法的名称放在后面。方法引用主要有三类：</p>
<ul>
<li>(1) 指向静态方法的方法引用(例如Integer的parseInt方法，写作Integer::parseInt)。</li>
<li>(2) 指向任意类型实例方法的方法引用(例如String的length方法，写作 String::length)。</li>
<li>(3) 指向现有对象的实例方法的方法引用(假设你有一个局部变量expensiveTransaction 用于存放Transaction类型的对象，它支持实例方法getValue，那么你就可以写expensive- Transaction::getValue)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对于一个现有构造函数，你可以利用它的名称和关键字<span class="keyword">new</span>来创建它的一个引用: ClassName::<span class="keyword">new</span>。它的功能与指向静态方法的引用类似。</span><br><span class="line">Supplier&lt;Apple&gt; c1 = Apple::<span class="keyword">new</span>;</span><br><span class="line">Apple a1 = c1.get();</span><br><span class="line">     </span><br><span class="line">这就等价于:</span><br><span class="line">Supplier&lt;Apple&gt; c1 = () -&gt; <span class="keyword">new</span> Apple(); <span class="comment">// 利用默认构造函数创建 Apple的Lambda表达式</span></span><br><span class="line">Apple a1 = c1.get(); <span class="comment">// 调用Supplier的get方法 将产生一个新的Apple</span></span><br></pre></td></tr></table></figure>

<h1 id="7-复合Lambda表达式的有用方法"><a href="#7-复合Lambda表达式的有用方法" class="headerlink" title="7. 复合Lambda表达式的有用方法"></a>7. 复合Lambda表达式的有用方法</h1><h2 id="7-1-比较器复合"><a href="#7-1-比较器复合" class="headerlink" title="7.1 比较器复合"></a>7.1 比较器复合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Apple&gt; c = Comparator.comparing(Apple::getWeight);</span><br><span class="line"><span class="comment">// 逆序 按重量递 减排序</span></span><br><span class="line">inventory.sort(comparing(Apple::getWeight).reversed());</span><br><span class="line"><span class="comment">// 比较器链 按重量递减排序;两个苹果一样重时，进一步按国家排序</span></span><br><span class="line">inventory.sort(comparing(Apple::getWeight)</span><br><span class="line">         .reversed()</span><br><span class="line">         .thenComparing(Apple::getCountry));</span><br></pre></td></tr></table></figure>

<h2 id="7-2-谓词复合"><a href="#7-2-谓词复合" class="headerlink" title="7.2 谓词复合"></a>7.2 谓词复合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产生现有Predicate 对象redApple的非</span></span><br><span class="line">Predicate&lt;Apple&gt; notRedApple = redApple.negate();</span><br><span class="line"><span class="comment">// 链接两个谓词来生成另 一个Predicate对象  一个苹果既是红色又比较重</span></span><br><span class="line">Predicate&lt;Apple&gt; redAndHeavyApple = redApple.and(a -&gt; a.getWeight() &gt; <span class="number">150</span>);</span><br><span class="line"><span class="comment">// 链接Predicate的方法来构造更复杂Predicate对象 表达要么是重(150克以上)的红苹果，要么是绿苹果</span></span><br><span class="line">Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen = redApple.and(a -&gt; a.getWeight() &gt; <span class="number">150</span>) </span><br><span class="line">                                            .or(a -&gt; <span class="string">"green"</span>.equals(a.getColor()));</span><br><span class="line">请注意，and和or方法是按照在表达式链中的位置，从左向右确定优 先级的。因此，a.or(b).and(c)可以看作(a || b) &amp;&amp; c。</span><br></pre></td></tr></table></figure>

<h2 id="7-3-函数复合"><a href="#7-3-函数复合" class="headerlink" title="7.3 函数复合"></a>7.3 函数复合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">andThen方法会返回一个函数，它先对输入应用一个给定函数，再对输出应用另一个函数。 比如，</span><br><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; h = f.andThen(g);</span><br><span class="line"><span class="keyword">int</span> result = h.apply(<span class="number">1</span>);</span><br><span class="line">数学上会写作g(f(x))或(g o f)(x)</span><br><span class="line">这将返回<span class="number">4</span></span><br><span class="line"></span><br><span class="line">compose方法，先把给定的函数用作compose的参数里面给的那个函 数，然后再把函数本身用于结果。</span><br><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; h = f.compose(g);</span><br><span class="line"><span class="keyword">int</span> result = h.apply(<span class="number">1</span>);</span><br><span class="line">数学上会写作f(g(x))或(f o g)(x) </span><br><span class="line">这将返回<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h1 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h1><p>以下是你应从本章中学到的关键概念。</p>
<ul>
<li>Lambda表达式可以理解为一种匿名函数:它没有名称，但有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常的列表。</li>
<li>Lambda表达式让你可以简洁地传递代码。</li>
<li>函数式接口就是仅仅声明了一个抽象方法的接口。</li>
<li>只有在接受函数式接口的地方才可以使用Lambda表达式。</li>
<li>Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例。</li>
<li>Java 8自带一些常用的函数式接口，放在java.util.function包里，包括Predicate<T>、Function&lt;T,R&gt;、Supplier<T>、Consumer<T>和BinaryOperator<T>，如表3-2所述。</li>
<li>为了避免装箱操作，对Predicate<T>和Function&lt;T, R&gt;等通用函数式接口的原始类型特化:IntPredicate、IntToLongFunction等。</li>
<li>环绕执行模式(即在方法所必需的代码中间，你需要执行点儿什么操作，比如资源分配 和清理)可以配合Lambda提高灵活性和可重用性。</li>
<li>Lambda表达式所需要代表的类型称为目标类型。</li>
<li>方法引用让你重复使用现有的方法实现并直接传递它们。</li>
<li>Comparator、Predicate和Function等函数式接口都有几个可以用来结合Lambda表达式的默认方法。</li>
</ul>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-03T10:52:12.000Z" title="2019-03-03T10:52:12.000Z">2019-03-03</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">17 分钟 读完 (大约 2494 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/64e9d771.html">《Java 8 in Action》Chapter 2：通过行为参数化传递代码</a></h1><div class="content"><p>你将了解行为参数化，这是Java 8非常依赖的一种软件开发模式，也是引入 Lambda表达式的主要原因。行为参数化就是可以帮助你处理频繁变更的需求的一种软件开发模式。一言以蔽之，它意味 着拿出一个代码块，把它准备好却不去执行它。这个代码块以后可以被你程序的其他部分调用。本章通过筛选苹果这个实际需求来一步步引出Lambda表达式，同时我也会把代码贴出来，读完你会看到代码是如何一步一步的向Lambda转化。多代码来袭，保护我方ADC！！</p>
<h2 id="代码演化"><a href="#代码演化" class="headerlink" title="代码演化"></a>代码演化</h2><h3 id="1-实习生版本"><a href="#1-实习生版本" class="headerlink" title="1.实习生版本"></a>1.实习生版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lujiahao.learnjava8.chapter2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 筛选绿色苹果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lujiahao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-02-19 18:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterAppleV0</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; appleList = DataUtil.generateApples();</span><br><span class="line">        List&lt;Apple&gt; greenAppleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Apple apple : appleList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"green"</span>.equals(apple.getColor())) &#123;</span><br><span class="line">                greenAppleList.add(apple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"原集合:"</span> + appleList);</span><br><span class="line">        System.out.println(<span class="string">"绿苹果集合:"</span> + greenAppleList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种之所以称之为实习生版本，是因为此种写法比较初级，所有代码在一个方法中实现。没有进行方法的抽取，不符合面向对象的理念，希望大家在编码工作时避免这种写法。</p>
<h3 id="2-方法抽取版本"><a href="#2-方法抽取版本" class="headerlink" title="2.方法抽取版本"></a>2.方法抽取版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lujiahao.learnjava8.chapter2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 筛选绿色苹果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lujiahao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-02-19 18:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterAppleV1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; appleList = DataUtil.generateApples();</span><br><span class="line">        System.out.println(<span class="string">"原集合:"</span> + appleList);</span><br><span class="line"></span><br><span class="line">        List&lt;Apple&gt; filterGreenApples = filterGreenApples(appleList);</span><br><span class="line">        System.out.println(<span class="string">"绿苹果集合:"</span> + filterGreenApples);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 筛选绿色苹果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appleList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterGreenApples</span><span class="params">(List&lt;Apple&gt; appleList)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Apple apple : appleList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"green"</span>.equals(apple.getColor())) &#123;</span><br><span class="line">                resultList.add(apple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此版本对筛选绿色苹果的方法进行了简单的抽取，相较于上个版本有了很大的提升。然而，如果需求方改变想法，想筛选红色的苹果。复制filterGreenApples() 方法并将其中的绿色筛选条件改为红色，确实可以实现。但是，这样有太多重复的模板代码，不是良好的编码规范。因此，我们将筛选条件颜色进一步抽象化。</p>
<h3 id="3-筛选条件作为参数传入"><a href="#3-筛选条件作为参数传入" class="headerlink" title="3.筛选条件作为参数传入"></a>3.筛选条件作为参数传入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lujiahao.learnjava8.chapter2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要判断的属性作为参数传入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lujiahao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-02-19 18:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterAppleV2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; appleList = DataUtil.generateApples();</span><br><span class="line">        System.out.println(<span class="string">"原集合:"</span> + appleList);</span><br><span class="line"></span><br><span class="line">        List&lt;Apple&gt; filterGreenApples = filterApples(appleList, <span class="string">"green"</span>);</span><br><span class="line">        System.out.println(<span class="string">"筛选绿色苹果:"</span> + filterGreenApples);</span><br><span class="line"></span><br><span class="line">        List&lt;Apple&gt; filterRedApples = filterApples(appleList, <span class="string">"red"</span>);</span><br><span class="line">        System.out.println(<span class="string">"筛选红色苹果:"</span> + filterRedApples);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 筛选特定颜色苹果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appleList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApples</span><span class="params">(List&lt;Apple&gt; appleList, String color)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Apple apple : appleList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color.equals(apple.getColor())) &#123;</span><br><span class="line">                resultList.add(apple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>满足了颜色的筛选条件，然而需求方又灵光一闪，筛选大于150克的苹果。无论是复制filterApples() 方法，还是增加重量作为参数传入，都是不推荐的编码习惯。第一种方法复制了大部分的代码来实现遍历，它打破了DRY（Don’t Repeat Yourself）的软件工程原则；第二种方法并不能考虑到所有情况，并且每次修改都对原有代码产生了影响，无法做到修改对外封闭的原则。</p>
<h3 id="4-行为参数化"><a href="#4-行为参数化" class="headerlink" title="4.行为参数化"></a>4.行为参数化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lujiahao.learnjava8.chapter2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 行为参数化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lujiahao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-02-19 18:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterAppleV3</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; appleList = DataUtil.generateApples();</span><br><span class="line">        System.out.println(<span class="string">"原集合:"</span> + appleList);</span><br><span class="line"></span><br><span class="line">        List&lt;Apple&gt; filterGreenApples = filterApples(appleList, <span class="keyword">new</span> AppleGreenColorPredicate());</span><br><span class="line">        System.out.println(<span class="string">"筛选绿色苹果:"</span> + filterGreenApples);</span><br><span class="line"></span><br><span class="line">        List&lt;Apple&gt; filterHeavyApples = filterApples(appleList, <span class="keyword">new</span> AppleHeavyWeightPredicate());</span><br><span class="line">        System.out.println(<span class="string">"筛选重量大于150苹果:"</span> + filterHeavyApples);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 筛选绿色苹果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appleList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApples</span><span class="params">(List&lt;Apple&gt; appleList, ApplePredicate predicate)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Apple apple : appleList) &#123;</span><br><span class="line">            <span class="comment">// 谓词对象封装了条件</span></span><br><span class="line">            <span class="keyword">if</span> (predicate.filter(apple)) &#123;</span><br><span class="line">                resultList.add(apple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplePredicate</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Apple apple)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleHeavyWeightPredicate</span> <span class="keyword">implements</span> <span class="title">ApplePredicate</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleGreenColorPredicate</span> <span class="keyword">implements</span> <span class="title">ApplePredicate</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"green"</span>.equals(apple.getColor());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们对苹果的所有属性进行更高一个层次的抽象建模，通过定义ApplePredicate 接口，AppleHeavyWeightPredicate 和 AppleGreenColorPredicate 分别实现该接口来达到进行不同的筛选功能。客户端调用中创建不同的实现类，对于filterApple() 方法而言，是传入了不同的行为，即行为参数化。行为参数化：让方法接受多种行为(或战略)作为参数，并在内部使用，来完成不同的行为。<br>其原理如下图所示：<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/01.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%202%EF%BC%9A%E9%80%9A%E8%BF%87%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96%E4%BC%A0%E9%80%92%E4%BB%A3%E7%A0%81/%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96.png" alt=""></p>
<h3 id="5-匿名内部类"><a href="#5-匿名内部类" class="headerlink" title="5.匿名内部类"></a>5.匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lujiahao.learnjava8.chapter2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用匿名类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lujiahao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-02-19 18:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterAppleV4</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; appleList = DataUtil.generateApples();</span><br><span class="line">        System.out.println(<span class="string">"原集合:"</span> + appleList);</span><br><span class="line"></span><br><span class="line">        List&lt;Apple&gt; filterGreenApples = filterApples(appleList, <span class="keyword">new</span> ApplePredicate() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"green"</span>.equals(apple.getColor());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"筛选绿色苹果:"</span> + filterGreenApples);</span><br><span class="line"></span><br><span class="line">        List&lt;Apple&gt; filterHeavyApples = filterApples(appleList, <span class="keyword">new</span> ApplePredicate() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"筛选重量大于150苹果:"</span> + filterHeavyApples);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 筛选绿色苹果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appleList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApples</span><span class="params">(List&lt;Apple&gt; appleList, ApplePredicate predicate)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Apple apple : appleList) &#123;</span><br><span class="line">            <span class="comment">// 谓词对象封装了条件</span></span><br><span class="line">            <span class="keyword">if</span> (predicate.filter(apple)) &#123;</span><br><span class="line">                resultList.add(apple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplePredicate</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Apple apple)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当每次有新的查询需求提出，都要新建一个实现类，随着条件越来越多，实现类的数量也在急剧上升。此时，通过使用匿名内部类的方式，来减少实现类过多的模板代码。然而，匿名内部类并非完美，第一，它往往很笨重，因为它占用了很多空间；第二，很多程序员觉得它用起来很让人费解。</p>
<h3 id="6-使用-Lambda-表达式"><a href="#6-使用-Lambda-表达式" class="headerlink" title="6.使用 Lambda 表达式"></a>6.使用 Lambda 表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lujiahao.learnjava8.chapter2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Lambda表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lujiahao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-02-19 18:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterAppleV5</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; appleList = DataUtil.generateApples();</span><br><span class="line">        System.out.println(<span class="string">"原集合:"</span> + appleList);</span><br><span class="line"></span><br><span class="line">        List&lt;Apple&gt; filterGreenApples = filterApples(appleList, (Apple apple) -&gt; <span class="string">"green"</span>.equals(apple.getColor()));</span><br><span class="line">        System.out.println(<span class="string">"筛选绿色苹果:"</span> + filterGreenApples);</span><br><span class="line"></span><br><span class="line">        List&lt;Apple&gt; filterHeavyApples = filterApples(appleList, (Apple apple) -&gt; apple.getWeight() &gt; <span class="number">150</span>);</span><br><span class="line">        System.out.println(<span class="string">"筛选重量大于150苹果:"</span> + filterHeavyApples);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 筛选绿色苹果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appleList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApples</span><span class="params">(List&lt;Apple&gt; appleList, ApplePredicate predicate)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Apple apple : appleList) &#123;</span><br><span class="line">            <span class="comment">// 谓词对象封装了条件</span></span><br><span class="line">            <span class="keyword">if</span> (predicate.filter(apple)) &#123;</span><br><span class="line">                resultList.add(apple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplePredicate</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Apple apple)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不得不承认这代码看上去比先前干净很多，而且它看起来更像是在陈述问题本身，更加通俗易懂。</p>
<h3 id="7-List-类型抽象化"><a href="#7-List-类型抽象化" class="headerlink" title="7.List 类型抽象化"></a>7.List 类型抽象化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lujiahao.learnjava8.chapter2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List类型抽象话</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lujiahao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-02-19 18:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterAppleV6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; appleList = DataUtil.generateApples();</span><br><span class="line">        System.out.println(<span class="string">"原集合:"</span> + appleList);</span><br><span class="line"></span><br><span class="line">        List&lt;Apple&gt; filterGreenApples = filter(appleList, (Apple apple) -&gt; <span class="string">"green"</span>.equals(apple.getColor()));</span><br><span class="line">        System.out.println(<span class="string">"筛选绿色苹果:"</span> + filterGreenApples);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"============================================="</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; numberList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"原集合:"</span> + numberList);</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; numbers = filter(numberList, (Integer i) -&gt; i % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"能被2整除的数:"</span> + numbers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 筛选绿色苹果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(List&lt;T&gt; list, Predicate&lt;T&gt; predicate)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">            <span class="comment">// 谓词对象封装了条件</span></span><br><span class="line">            <span class="keyword">if</span> (predicate.filter(t)) &#123;</span><br><span class="line">                resultList.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(T t)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在通往抽象的路上，我们还可以更进一步。目前，filterApples方法还只适用于Apple。还可以将List类型抽象化，从而支持所有类型。</p>
<h3 id="8-演化小结"><a href="#8-演化小结" class="headerlink" title="8.演化小结"></a>8.演化小结</h3><p>这一路演化中我们可以看出代码是如何一步一步转化的更加简洁更加优雅，对此我们进行总结：<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/01.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%202%EF%BC%9A%E9%80%9A%E8%BF%87%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96%E4%BC%A0%E9%80%92%E4%BB%A3%E7%A0%81/%E6%BC%94%E5%8C%96%E5%B0%8F%E7%BB%93.png" alt=""></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="1-用-Comparator-排序"><a href="#1-用-Comparator-排序" class="headerlink" title="1.用 Comparator 排序"></a>1.用 Comparator 排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lujiahao.learnjava8.chapter2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用 Comparator 排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lujiahao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-03-02 18:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; appleList = DataUtil.generateApples();</span><br><span class="line">        System.out.println(<span class="string">"原集合:"</span> + appleList);</span><br><span class="line"></span><br><span class="line">        appleList.sort(<span class="keyword">new</span> Comparator&lt;Apple&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple o1, Apple o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getWeight().compareTo(o2.getWeight());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"按重量升序:"</span> + appleList);</span><br><span class="line"></span><br><span class="line">        appleList.sort((Apple a1, Apple a2) -&gt; a1.getColor().compareTo(a2.getColor()));</span><br><span class="line">        System.out.println(<span class="string">"按颜色字典排序:"</span> + appleList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-用-Runnable-执行代码块"><a href="#2-用-Runnable-执行代码块" class="headerlink" title="2.用 Runnable 执行代码块"></a>2.用 Runnable 执行代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lujiahao.learnjava8.chapter2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用 Runnable 执行代码块</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lujiahao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-03-02 18:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Hello Java 8!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"Hello Lambda!"</span>));</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-GUI-事件处理"><a href="#3-GUI-事件处理" class="headerlink" title="3.GUI 事件处理"></a>3.GUI 事件处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Button button = <span class="keyword">new</span> Button(“Send”);</span><br><span class="line">button.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">        lable.setText(“Send!!”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.setOnAction((ActionEvent event) -&gt; lable.setText(“Send!!”));</span><br></pre></td></tr></table></figure>

<p>小猿之前搞安卓开发的，各种控件的监听都是这个样子，想想以前各种代码啊啊啊<del>~</del></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以下是你应从本章中学到的关键概念。</p>
<ul>
<li>行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。</li>
<li>行为参数化可让代码更好地适应不断变化的要求，减轻未来的工作量。</li>
<li>传递代码，就是将新行为作为参数传递给方法。但在Java 8之前这实现起来很啰嗦。为接口声明许多只用一次的实体类而造成的啰嗦代码，在Java 8之前可以用匿名类来减少。</li>
<li>Java API包含很多可以用不同行为进行参数化的方法，包括排序、线程和GUI处理。</li>
</ul>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-02T14:11:14.000Z" title="2019-03-02T14:11:14.000Z">2019-03-02</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">6 分钟 读完 (大约 934 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/88e39eba.html">《Java 8 in Action》Chapter 1：为什么要关心Java 8</a></h1><div class="content"><p>自1998年 JDK 1.0(Java 1.0) 发布以来，Java 已经受到了学生、项目经理和程序员等一大批活跃用户的欢迎。这一语言极富活力，不断被用在大大小小的项目里。从 Java 1.1(1997年) 一直到 Java 7(2011年)，Java 通过增加新功能，不断得到良好的升级。Java 8 则是在2014年3月发布的。Java 8 所做的改变，在许多方面比 Java 历史上任何一次改变都深远，而且极大的提高了 Java 代码的简洁性。</p>
<h2 id="1-lambda-表达式"><a href="#1-lambda-表达式" class="headerlink" title="1. lambda 表达式"></a>1. lambda 表达式</h2><p>本文通过筛选苹果的需求引入 Java 8 ，对 inventory 中的苹果按照重量进行排序。<br>Java 8 之前的版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(inventory, <span class="keyword">new</span> Comparator&lt;Apple&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple a1, Apple a2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a1.getWeight().compareTo(a2.getWeight());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Java 8 版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(comparing(Apple::getWeight));</span><br></pre></td></tr></table></figure>

<p>通过对比我们不难发现，使用 Java 8 可以编写更为简洁的代码，而且代码读起来更接近问题的描述。</p>
<h2 id="2-方法引用"><a href="#2-方法引用" class="headerlink" title="2. 方法引用"></a>2. 方法引用</h2><p>在 Java 8 之前类（Class）是Java中的一等公民，Java8中将方法和lambda增加为一等公民。方法和lambda作为一等公民，是Java8中方法引用的基础。除了允许(命名)函数成为一等值外，Java 8还体现了更广义的将函数作为值的思想，包括 Lambda1(或匿名函数)。</p>
<p>筛选一个目录中的所有隐藏文件，Java 8 之前版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File[] hiddenFiles = <span class="keyword">new</span> File(“.”).listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span> <span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> file.isHidden();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 8 版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File[] hiddenFiles = <span class="keyword">new</span> File(<span class="string">"."</span>).listFiles(File::isHidden);</span><br></pre></td></tr></table></figure>

<h2 id="3-流"><a href="#3-流" class="headerlink" title="3. 流"></a>3. 流</h2><p>在Java8之前，遍历处理集合元素，你得用for-each循环一个个去迭代元素，然后再处理元素。我们把这种数据迭代的方法称为外部迭代。相反，有了Stream API，你根本用不着操心循环的事情。数据处理完全是在库内部进行的。我们把这种思想叫作内部迭代。</p>
<p>Java 8 中对于大数据量的集合，用Stream API(java.util.stream)解决了：集合处理时的套路和晦涩，以及难以利用多核这两个问题。</p>
<p>如下展示 Java 8 中使用 Stream API 并行处理数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList;</span><br><span class="line">List&lt;Apple&gt; heavyApples = inventory.parallelStream().filter((Apple a) -&gt; a.getWeight() &gt; <span class="number">150</span>) .collect(toList());</span><br></pre></td></tr></table></figure>

<h2 id="4-默认方法"><a href="#4-默认方法" class="headerlink" title="4. 默认方法"></a>4. 默认方法</h2><p>Java 8中加入默认方法主要是为了支持库设计师，让他们能够写出更容易改进的接口。同时，普通开发者也可以在接口中使用默认方法，在实现类没有实现方法时提供方法内容，进一步方便开发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; heavyApples1 = inventory.stream().filter((Apple a) -&gt; a.getWeight() &gt; <span class="number">150</span>).collect(toList());</span><br><span class="line">List&lt;Apple&gt; heavyApples2 = inventory.parallelStream().filter((Apple a) -&gt; a.getWeight() &gt; <span class="number">150</span>).collect(toList());</span><br></pre></td></tr></table></figure>

<p>在Java 8之前，List<T>并没有stream或parallelStream方法，它实现 的Collection<T>接口也没有。Java 8 给接口设计者提供了一个扩充接口的方式，而不会破坏现有的代码。Java 8在接口声明 中使用新的default关键字来表示这一点。这样就实现了改变已发布的接口而不破坏已有的实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章主要总结Java 8 的主要变化(Lambda表达式、方法引用、流和默认方法)，为后面更进一步学习打下坚实基础。</p>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-02-14T17:39:18.000Z" title="2019-02-14T17:39:18.000Z">2019-02-14</time><span class="level-item"><a class="link-muted" href="/categories/Flutter/">Flutter</a></span><span class="level-item">4 分钟 读完 (大约 584 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/d26371f0.html">阿里开源项目上新，Flutter Go 请查收！</a></h1><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>新年伊始，阿里开源项目上新了！此次是阿里拍卖前端团队带来的 Fluttr Go ，针对于时下很火的跨平台移动解决方案推出的实例APP项目，对于Flutter初学者，学习掌握此项目是极其有益的。<br><img src="https://raw.githubusercontent.com/github/explore/cebd63002168a05a6a642f309227eefeccd92950/topics/flutter/flutter.png" alt=""></p>
<h2 id="Flutter-是什么"><a href="#Flutter-是什么" class="headerlink" title="Flutter 是什么?"></a>Flutter 是什么?</h2><p>2018年6月21日Google发布Flutter首个release预览版,作为Google 大力推出的一种全新的响应式，跨平台，高性能的移动开发框架。Flutter是一个跨平台的移动UI框架，旨在帮助开发者使用一套代码开发高性能、高保真的Android和iOS应用。</p>
<p>flutter优点主要包括：</p>
<ul>
<li>开源、跨平台</li>
<li>Hot Reload、响应式框架、及其丰富的控件以及开发工具</li>
<li>灵活的界面设计以及控件组合</li>
<li>借助可以移植的GPU加速的渲染引擎以及高性能ARM代码运行时已达到高质量的用户体验</li>
</ul>
<h2 id="Flutter-Go-的由来"><a href="#Flutter-Go-的由来" class="headerlink" title="Flutter Go 的由来"></a>Flutter Go 的由来</h2><ul>
<li>帮助开发者快速上手 Flutter</li>
<li>Flutter学习资料太少，对于英文不好的同学相对来说比较困难</li>
<li>官网文档示例不够健全，不够直观</li>
<li>各个 widget 的用法各异，属性纷繁，要运行一个 widget 的 demo 往往要到处翻阅各种资料</li>
</ul>
<h2 id="Flutter-Go-的优势"><a href="#Flutter-Go-的优势" class="headerlink" title="Flutter Go 的优势"></a>Flutter Go 的优势</h2><ul>
<li>详解常用widget多达 <strong>140+</strong> 个</li>
<li>配套 Demo 详解 widget 常规用法</li>
<li>集中整合 widget 案例，一个 APP 搞定所有常用 widget 的用法</li>
<li>持续迭代 ‘追新’ 官方版本</li>
</ul>
<h2 id="app-预览"><a href="#app-预览" class="headerlink" title="app 预览"></a>app 预览</h2><p><img src="https://img.alicdn.com/tfs/TB1MoiNExTpK1RjSZFGXXcHqFXa-362-751.gif" width=200> <img src="https://img.alicdn.com/tfs/TB1oeicBhjaK1RjSZFAXXbdLFXa-345-717.gif" width=200>  <img src="https://img.alicdn.com/tfs/TB1WJNuBmzqK1RjSZPcXXbTepXa-345-717.gif" width=200>  <img src="https://img.alicdn.com/tfs/TB13Xh3BkvoK1RjSZFNXXcxMVXa-345-717.gif" width=200>  </p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>跨平台技术蓝海已经出现，未来跨平台开发甚至多端统一的开发模式与语言势必成为主流。而我们大家一般都是只拥有一个技术栈，这就需要我们努力扩展知识宽度广度的同时，也要多涉猎时下新兴技术，紧追技术的时代大潮！</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>本文同步发表在公众号，欢迎大家关注！😁 各位大佬点点广告，万分感谢！！！<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-02-13T11:48:46.000Z" title="2019-02-13T11:48:46.000Z">2019-02-13</time><span class="level-item"><a class="link-muted" href="/categories/Chrome/">Chrome</a></span><span class="level-item">8 分钟 读完 (大约 1184 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/b7450b36.html">谷歌推出12款新官方主题，赶快给你的Chrome换换样子！</a></h1><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>新年伊始，开工大吉！新的一年，各位大佬准备好码起来了吗！俗话说得好，工欲善其事必先利其器，今天介绍下谷歌官方出品的浏览器主题，让我们的 Chrome 浏览器更加赏心悦目！<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/2019/20190213%E8%B0%B7%E6%AD%8C%E6%8E%A8%E5%87%BA12%E6%AC%BE%E6%96%B0%E5%AE%98%E6%96%B9%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BB%99%E4%BD%A0%E7%9A%84Chrome%E6%8D%A2%E6%8D%A2%E6%A0%B7%E5%AD%90%EF%BC%81/chrome.png" alt=""></p>
<p>随着 macOS Mojave 的发布，黑暗模式不再仅是手机专属，PC 端迎来了黑暗模式主题。小编本人就在第一时间更新系统，黑暗模式绝对的科技感十足！<br>![](<a href="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/2019/20190213%E8%B0%B7%E6%AD%8C%E6%8E%A8%E5%87%BA12%E6%AC%BE%E6%96%B0%E5%AE%98%E6%96%B9%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BB%99%E4%BD%A0%E7%9A%84Chrome%E6%8D%A2%E6%8D%A2%E6%A0%B7%E5%AD%90%EF%BC%81/macOS">https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/2019/20190213%E8%B0%B7%E6%AD%8C%E6%8E%A8%E5%87%BA12%E6%AC%BE%E6%96%B0%E5%AE%98%E6%96%B9%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BB%99%E4%BD%A0%E7%9A%84Chrome%E6%8D%A2%E6%8D%A2%E6%A0%B7%E5%AD%90%EF%BC%81/macOS</a> Mojave.png)</p>
<h2 id="Chrome-新主题"><a href="#Chrome-新主题" class="headerlink" title="Chrome 新主题"></a>Chrome 新主题</h2><p>为了满足用户对黑暗模式的需求，Google Chrome 团队在新年期间为大众提供了全新的主题模式。这套 Chrome 谷歌浏览器官方新主题共包含 12 款，其中备受欢迎的黑暗模式主题(Just Black），极大的满足了倾向于夜间工作的用户群体。<br>![](<a href="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/2019/20190213%E8%B0%B7%E6%AD%8C%E6%8E%A8%E5%87%BA12%E6%AC%BE%E6%96%B0%E5%AE%98%E6%96%B9%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BB%99%E4%BD%A0%E7%9A%84Chrome%E6%8D%A2%E6%8D%A2%E6%A0%B7%E5%AD%90%EF%BC%81/Just">https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/2019/20190213%E8%B0%B7%E6%AD%8C%E6%8E%A8%E5%87%BA12%E6%AC%BE%E6%96%B0%E5%AE%98%E6%96%B9%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BB%99%E4%BD%A0%E7%9A%84Chrome%E6%8D%A2%E6%8D%A2%E6%A0%B7%E5%AD%90%EF%BC%81/Just</a> Black.png)</p>
<p>除了备受欢迎的黑暗模式外，还有一系列主题可选择，包括 Slate、Oceanic、Ultra Violet、Classic Blue、Banana、Black＆White、Honeysuckle、Rose、Serenity、Sea Foam、Marsala、高对比色彩、以及 Pretty in Pink 等。大家可以依据个人喜好选择自己中意的主题。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/2019/20190213%E8%B0%B7%E6%AD%8C%E6%8E%A8%E5%87%BA12%E6%AC%BE%E6%96%B0%E5%AE%98%E6%96%B9%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BB%99%E4%BD%A0%E7%9A%84Chrome%E6%8D%A2%E6%8D%A2%E6%A0%B7%E5%AD%90%EF%BC%81/%E4%B8%BB%E9%A2%98%E6%B1%87%E6%80%BB.png" alt=""></p>
<p>截止小编发稿是，本次新主题中好评度较高的的几款如下：<br>![](<a href="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/2019/20190213%E8%B0%B7%E6%AD%8C%E6%8E%A8%E5%87%BA12%E6%AC%BE%E6%96%B0%E5%AE%98%E6%96%B9%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BB%99%E4%BD%A0%E7%9A%84Chrome%E6%8D%A2%E6%8D%A2%E6%A0%B7%E5%AD%90%EF%BC%81/Ultra">https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/2019/20190213%E8%B0%B7%E6%AD%8C%E6%8E%A8%E5%87%BA12%E6%AC%BE%E6%96%B0%E5%AE%98%E6%96%B9%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BB%99%E4%BD%A0%E7%9A%84Chrome%E6%8D%A2%E6%8D%A2%E6%A0%B7%E5%AD%90%EF%BC%81/Ultra</a> Violet.png)<br>![](<a href="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/2019/20190213%E8%B0%B7%E6%AD%8C%E6%8E%A8%E5%87%BA12%E6%AC%BE%E6%96%B0%E5%AE%98%E6%96%B9%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BB%99%E4%BD%A0%E7%9A%84Chrome%E6%8D%A2%E6%8D%A2%E6%A0%B7%E5%AD%90%EF%BC%81/Black">https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/2019/20190213%E8%B0%B7%E6%AD%8C%E6%8E%A8%E5%87%BA12%E6%AC%BE%E6%96%B0%E5%AE%98%E6%96%B9%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BB%99%E4%BD%A0%E7%9A%84Chrome%E6%8D%A2%E6%8D%A2%E6%A0%B7%E5%AD%90%EF%BC%81/Black</a> &amp; White.png)<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/2019/20190213%E8%B0%B7%E6%AD%8C%E6%8E%A8%E5%87%BA12%E6%AC%BE%E6%96%B0%E5%AE%98%E6%96%B9%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BB%99%E4%BD%A0%E7%9A%84Chrome%E6%8D%A2%E6%8D%A2%E6%A0%B7%E5%AD%90%EF%BC%81/Serenity.png" alt=""><br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/2019/20190213%E8%B0%B7%E6%AD%8C%E6%8E%A8%E5%87%BA12%E6%AC%BE%E6%96%B0%E5%AE%98%E6%96%B9%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BB%99%E4%BD%A0%E7%9A%84Chrome%E6%8D%A2%E6%8D%A2%E6%A0%B7%E5%AD%90%EF%BC%81/Slate.png" alt=""><br>小编个人选择了 Slate 主题。（我感觉 Just Black 主题太黑了😁，纯个人观点）</p>
<h2 id="恢复默认主题"><a href="#恢复默认主题" class="headerlink" title="恢复默认主题"></a>恢复默认主题</h2><ol>
<li><p>主题刚刚安装后，顶部会有一个撤销按钮，如果感觉并不满意当前的主题，可以撤销恢复默认主题。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/2019/20190213%E8%B0%B7%E6%AD%8C%E6%8E%A8%E5%87%BA12%E6%AC%BE%E6%96%B0%E5%AE%98%E6%96%B9%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BB%99%E4%BD%A0%E7%9A%84Chrome%E6%8D%A2%E6%8D%A2%E6%A0%B7%E5%AD%90%EF%BC%81/%E6%92%A4%E9%94%80%E4%B8%BB%E9%A2%98.png" alt=""></p>
</li>
<li><p>如果用户在使用任何主题一段时间后，若要恢复成默认主题，可以单击菜单&gt;设置&gt;外观，然后单击“ 重置为默认值 ”，即可恢复。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/2019/20190213%E8%B0%B7%E6%AD%8C%E6%8E%A8%E5%87%BA12%E6%AC%BE%E6%96%B0%E5%AE%98%E6%96%B9%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BB%99%E4%BD%A0%E7%9A%84Chrome%E6%8D%A2%E6%8D%A2%E6%A0%B7%E5%AD%90%EF%BC%81/%E6%81%A2%E5%A4%8D%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98.png" alt=""></p>
<h2 id="获得主题"><a href="#获得主题" class="headerlink" title="获得主题"></a>获得主题</h2><p>有兴趣朋友可以访问 Chrome 网上应用商店，搜索主题背景，进入主题页面来查看及获得主题。</p>
</li>
</ol>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>本文同步发表在公众号，欢迎大家关注！😁 各位大佬点点广告，万分感谢！！！<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-01-31T10:16:00.000Z" title="2019-01-31T10:16:00.000Z">2019-01-31</time><span class="level-item"><a class="link-muted" href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/">工具教程</a></span><span class="level-item">3 分钟 读完 (大约 408 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/719434de.html">Mac iTerm2 配置 rz/sz 上传下载功能</a></h1><div class="content"><p>使用mac的同学要进行远程服务器文件的上传下载，推荐使用 sz 和 rz 命令，下文为iTerm2配置的方法。</p>
<h2 id="1-安装lrzsz"><a href="#1-安装lrzsz" class="headerlink" title="1. 安装lrzsz"></a>1. 安装lrzsz</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install lrzsz</span><br></pre></td></tr></table></figure>

<h2 id="2-下载脚本"><a href="#2-下载脚本" class="headerlink" title="2. 下载脚本"></a>2. 下载脚本</h2><p><a href="https://github.com/mmastrac/iterm2-zmodem">https://github.com/mmastrac/iterm2-zmodem</a></p>
<h2 id="3-复制脚本"><a href="#3-复制脚本" class="headerlink" title="3. 复制脚本"></a>3. 复制脚本</h2><p>将脚本<code>iterm2-send-zmodem.sh</code>和<code>iterm2-recv-zmodem.sh</code>复制到<code>/usr/local/bin/</code>目录中即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp iterm2-recv-zmodem.sh iterm2-send-zmodem.sh &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="4-配置-iTerm2"><a href="#4-配置-iTerm2" class="headerlink" title="4. 配置 iTerm2"></a>4. 配置 iTerm2</h2><p>打开 iTerm2,按<code>⌘+,</code>打开Perfences，选择Profiles标签页，在Profiles标签页下选择Advanced标签页，编辑Triggers</p>
<pre><code>Regular expression: rz waiting to receive.\*\*B0100
Action: Run Silent Coprocess
Parameters: /usr/local/bin/iterm2-send-zmodem.sh
Instant: checked

Regular expression: \*\*B00000000000000
Action: Run Silent Coprocess
Parameters: /usr/local/bin/iterm2-recv-zmodem.sh
Instant: checked</code></pre><p>图示 :<br><img src="https://github.com/lujiahao0708/PicRepo/raw/master/blogPic/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/iterm2/iterm2%E9%85%8D%E7%BD%AEszrz1.png" alt=""><br><img src="https://github.com/lujiahao0708/PicRepo/raw/master/blogPic/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/iterm2/iterm2%E9%85%8D%E7%BD%AEszrz2.png" alt=""></p>
<h2 id="5-远程服务器安装lrzsz"><a href="#5-远程服务器安装lrzsz" class="headerlink" title="5. 远程服务器安装lrzsz"></a>5. 远程服务器安装lrzsz</h2><p>CentOS安装方法 : <code>yum -y install lrzsz</code></p>
<h2 id="6-使用方法"><a href="#6-使用方法" class="headerlink" title="6. 使用方法"></a>6. 使用方法</h2><ol>
<li><p>本地上传文件到远程服务器</p>
<ol>
<li>登录到远程服务器，在远端服务器上输入 rz ，回车</li>
<li>弹框中选择本地要上传的文件</li>
<li>确定后等待上传完成</li>
</ol>
</li>
<li><p>远程服务器下载文件到本地</p>
<ol>
<li>在远程服务器输入 <code>sz filename filename1 ... filenameN</code></li>
<li>弹框中选择本地的存储目录</li>
<li>确定后等待下载完成</li>
</ol>
</li>
</ol>
<p>至此，我们就可以使用这项黑科技了！</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>本文同步发表在公众号，欢迎大家关注！😁 各位大佬点点广告，万分感谢！！！<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-01-12T19:22:27.000Z" title="2019-01-12T19:22:27.000Z">2019-01-12</time><span class="level-item"><a class="link-muted" href="/categories/JVM/">JVM</a></span><span class="level-item">6 分钟 读完 (大约 860 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/64aed4c5.html">《深入理解Java虚拟机》第六章 类文件结构</a></h1><div class="content"><h1 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h1><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>
<h1 id="6-2-无关性的基石"><a href="#6-2-无关性的基石" class="headerlink" title="6.2 无关性的基石"></a>6.2 无关性的基石</h1><p>Java虚拟机有两个无关性，即平台无关性和语言无关性。字节码(ByteCode) 是构成平台无关性的基石。在 Java 发展之初，设计者就曾经考虑过并实现了让其他语言运行在 Java 虚拟机之上的可能性，由此 Java 规范拆分成了 Java语言规范《The Java Language Specification》及 Java 虚拟机规范《The Java Virtual Machine Specification》。</p>
<blockquote>
<p>In the future, we will consider bounded extensions to the Java virtual machine to provide better support for the other languages.</p>
</blockquote>
<ul>
<li><p>语言无关性是指虚拟机并不止执行 Java程序，也考虑让其支持其他语言(Groovy/Scala/Kotlin等)的运行。</p>
</li>
<li><p>“一次编写，到处运行”。Java的平台无关性即体现在此处，可以在多个平台上运行。</p>
</li>
</ul>
<h1 id="6-3-Class-类文件的结构"><a href="#6-3-Class-类文件的结构" class="headerlink" title="6.3 Class 类文件的结构"></a>6.3 Class 类文件的结构</h1><p>Class 文件是<code>一组以8位字节为基础单位的二进制流</code>。Class 文件采用一种类似于 C 语言结构体的伪结构来存储数据 :</p>
<ul>
<li>无符号数<ul>
<li>基本的数据类型</li>
<li>u1 / u2 / u4 / u8 分别代表1个字节 / 2个字节 / 4个字节 / 8个字节</li>
<li>可以用来描述数字 / 索引引用 / 数量值或者按照UTF-8编码构成字符串值</li>
</ul>
</li>
<li>表<ul>
<li>复合数据类型</li>
<li>由多个无符号数或者其他表作为数据项构成，习惯以“_info”结尾</li>
<li>用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/lujiahao0708/PicRepo/raw/master/blogPic/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/6.%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/6.3_Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt=""></p>
<h2 id="6-3-1-魔数与-Class-文件的版本"><a href="#6-3-1-魔数与-Class-文件的版本" class="headerlink" title="6.3.1 魔数与 Class 文件的版本"></a>6.3.1 魔数与 Class 文件的版本</h2><p>每个 Class 文件的头4个字节称为魔数(Magic Number)。唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件。</p>
<p>紧接着魔数的4个字节是 Class 文件的版本号 : 第5和第6个字节是次版本号(Minor Version)，第7和第8个字节是主版本号(Major Version)。</p>
<p>将HelloWorld.java编译成 Class 文件后，使用 Synalyze It 16进制编辑工具查看</p>
<p><img src="https://github.com/lujiahao0708/PicRepo/raw/master/blogPic/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/6.%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/6.3.1_JavaClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt=""></p>
<p>也可以使用命令查看 Class 文件的版本号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># javap -v HelloWorld.class </span><br><span class="line">Classfile &#x2F;Users&#x2F;lujiahao&#x2F;HelloWorld.class</span><br><span class="line">  Last modified 2019-1-12; size 430 bytes</span><br><span class="line">  MD5 checksum f6fad4e65a952d7f01272063b971c2f8</span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;</span><br><span class="line">public class HelloWorld</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>同时查看本机 JDK 版本 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># java -version  </span><br><span class="line">java version &quot;1.8.0_161&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_161-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)</span><br></pre></td></tr></table></figure>

<p>通过上述方式我们可以看到 Class 文件的前9个字节的含义。下面是 Class 文件的版本号汇总 :</p>
<table>
<thead>
<tr>
<th>发布版本号</th>
<th>内部版本号（十六进制）</th>
<th>内部版本号（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>1.5</td>
<td>31</td>
<td>49</td>
</tr>
<tr>
<td>1.6</td>
<td>32</td>
<td>50</td>
</tr>
<tr>
<td>1.7</td>
<td>33</td>
<td>51</td>
</tr>
<tr>
<td>1.8</td>
<td>34</td>
<td>52</td>
</tr>
</tbody></table>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Java_class_file#Magic_Number">0xCAFEBABE 的由来</a></li>
<li><a href="http://www.synalysis.net/">Synalyze It 16进制编辑工具</a></li>
</ul>
<h2 id="6-3-2-常量池"><a href="#6-3-2-常量池" class="headerlink" title="6.3.2 常量池"></a>6.3.2 常量池</h2><h2 id="6-3-3-访问标志"><a href="#6-3-3-访问标志" class="headerlink" title="6.3.3 访问标志"></a>6.3.3 访问标志</h2><h2 id="6-3-4-类索引、父类索引与接口索引集合"><a href="#6-3-4-类索引、父类索引与接口索引集合" class="headerlink" title="6.3.4 类索引、父类索引与接口索引集合"></a>6.3.4 类索引、父类索引与接口索引集合</h2><h2 id="6-3-5-字段表集合"><a href="#6-3-5-字段表集合" class="headerlink" title="6.3.5 字段表集合"></a>6.3.5 字段表集合</h2><h2 id="6-3-6-方法表集合"><a href="#6-3-6-方法表集合" class="headerlink" title="6.3.6 方法表集合"></a>6.3.6 方法表集合</h2><h2 id="6-3-7-属性表集合"><a href="#6-3-7-属性表集合" class="headerlink" title="6.3.7 属性表集合"></a>6.3.7 属性表集合</h2><hr>
<p>欢迎大家关注😁<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-01-11T19:22:27.000Z" title="2019-01-11T19:22:27.000Z">2019-01-11</time><span class="level-item"><a class="link-muted" href="/categories/JVM/">JVM</a></span><span class="level-item">19 分钟 读完 (大约 2838 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/65739f60.html">《深入理解Java虚拟机》第二章 Java 内存区域与内存溢出异常</a></h1><div class="content"><blockquote>
<p>著名数学家华罗庚先生说：“读一本书要越读越薄。”书越读越薄的过程，就是在多次重复阅读中不断删除冗余信息的过程，浓缩的主要办法是：列提纲与写梗概。前者必须在认真读的基础上，理清文章的脉络，然后逐段概括内容；后者也必须反复阅读,掌握课文要点，将内容加以高度浓缩。浓缩法就是博学反约，厚积薄发，把厚书读薄，又把薄书积厚的读书方法。</p>
</blockquote>
<p><img src="https://github.com/lujiahao0708/PicRepo/raw/master/blogPic/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/%E6%90%9E%E7%AC%91%E5%9B%BE%E7%89%87.png" alt=""></p>
<h1 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h1><p>从概念上介绍 Java 虚拟机内存的各个区域，讲解这些区域的作用、服务对象以及其中可能产生的问题，这是翻越虚拟机内存管理这堵围墙的第一步。</p>
<h1 id="2-2-运行时数据区域"><a href="#2-2-运行时数据区域" class="headerlink" title="2.2 运行时数据区域"></a>2.2 运行时数据区域</h1><p><img src="https://github.com/lujiahao0708/PicRepo/raw/master/blogPic/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/2.2JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt=""></p>
<p>JVM 内存结构的布局和相应的控制参数 :</p>
<p><img src="https://github.com/lujiahao0708/PicRepo/raw/master/blogPic/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/2.2JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%842.png" alt=""></p>
<h2 id="2-2-1-程序计数器"><a href="#2-2-1-程序计数器" class="headerlink" title="2.2.1 程序计数器"></a>2.2.1 程序计数器</h2><ul>
<li>一块较小的内存空间，固定宽度的整数的存储空间</li>
<li>线程私有</li>
<li>当前线程所执行的字节码的行号指示器</li>
<li>Java 虚拟机规范中唯一一个没有规定 OutOfMemoryError 的区域</li>
<li>如果线程正在执行 Java 方法，存储的是正在执行的虚拟机字节码指令的地址；如果正在执行 Native 方法，其值为空(Undefined)。</li>
</ul>
<blockquote>
<p>经典问题扩展 : <a href="https://www.zhihu.com/question/49597071">Java 程序计数器为什么不规定 OutOfMemoryError ？</a></p>
</blockquote>
<h2 id="2-2-2-Java-虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#2-2-2-Java-虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="2.2.2 Java 虚拟机栈(Java Virtual Machine Stacks)"></a>2.2.2 Java 虚拟机栈(Java Virtual Machine Stacks)</h2><ul>
<li>线程私有，生命周期与线程相同</li>
<li>运行 Java 方法( 字节码 ) 服务</li>
<li>描述的是 Java 方法执行的内存模型 : 栈帧(Stack Frame)，包含：局部变量表、操作数栈、动态链接、方法出口等</li>
<li>StackOverflowError 异常：如果线程请求的栈深度大于虚拟机所允许的深度，抛出此异常</li>
<li>OutOfMemoryError 异常：如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，抛出此异常</li>
</ul>
<h2 id="2-2-3-本地方法栈-Native-Method-Stack"><a href="#2-2-3-本地方法栈-Native-Method-Stack" class="headerlink" title="2.2.3 本地方法栈(Native Method Stack)"></a>2.2.3 本地方法栈(Native Method Stack)</h2><ul>
<li>线程私有，生命周期与线程相同</li>
<li>运行 Native方法服务</li>
<li>与Java虚拟机栈相似，也会抛出StackOverflowError异常和OutOfMemoryError异常</li>
</ul>
<h2 id="2-2-4-Java-堆-Java-Heap"><a href="#2-2-4-Java-堆-Java-Heap" class="headerlink" title="2.2.4 Java 堆(Java Heap)"></a>2.2.4 Java 堆(Java Heap)</h2><ul>
<li>JVM 所管理的内存中最大的一块，垃圾回收的主要操作区域</li>
<li>所有线程共享，虚拟机启动时创建</li>
<li>所有对象实例以及数组都要在堆上分配(非绝对，JIT 和逃逸分析技术发展)</li>
<li>物理上不连续的内存空间，逻辑上是连续的</li>
<li>划分为：新生代( Eden空间、From Survivor空间、To Survivor空间 (分配比例 8:1:1) )和老年代</li>
<li>控制参数<ul>
<li>-Xms 设置堆的最小空间大小</li>
<li>-Xmx 设置堆的最大空间大小</li>
<li>-XX:NewSize 设置新生代最小空间大小</li>
<li>-XX:MaxNewSize 设置新生代最小空间大小。</li>
</ul>
</li>
<li>OutOfMemoryError异常：如果堆中没有内存完成实例分配，并且堆也无法扩展，抛出此异常</li>
</ul>
<h2 id="2-2-5-方法区-Method-Area"><a href="#2-2-5-方法区-Method-Area" class="headerlink" title="2.2.5 方法区(Method Area)"></a>2.2.5 方法区(Method Area)</h2><ul>
<li>所有线程共享</li>
<li>Java 虚拟机规范把方法区描述为堆的一个逻辑部分，别名非堆 Non-Heap，包含：类信息、常量、静态变量、即时编译器编译后的代码等数据</li>
<li>HotSpot 虚拟机称为“永久代”(Permanent Generation)</li>
<li>回收效率并不高</li>
<li>OutOfMemoryError异常：当方法区无法满足内存分配需求时，抛出此异常</li>
</ul>
<h2 id="2-2-6-运行时常量池-Runtime-Constant-Pool"><a href="#2-2-6-运行时常量池-Runtime-Constant-Pool" class="headerlink" title="2.2.6 运行时常量池(Runtime Constant Pool)"></a>2.2.6 运行时常量池(Runtime Constant Pool)</h2><ul>
<li>方法区一部分，所有线程共享</li>
<li>存储编译期生成的各种字面量和符号引用</li>
<li>OutOfMemoryError 异常：方法区一部分，受到方法区内存限制，当常量池无法再申请到内存时，抛出此异常</li>
<li>扩展 <a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">深入解析String#intern</a></li>
</ul>
<h2 id="2-2-7-直接内存-Direct-Memory"><a href="#2-2-7-直接内存-Direct-Memory" class="headerlink" title="2.2.7 直接内存(Direct Memory)"></a>2.2.7 直接内存(Direct Memory)</h2><ul>
<li>并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域</li>
<li>OutOfMemoryError 异常：配置虚拟机参数时，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现异常</li>
</ul>
<h1 id="2-3-HotSpot-虚拟机对象探秘"><a href="#2-3-HotSpot-虚拟机对象探秘" class="headerlink" title="2.3 HotSpot 虚拟机对象探秘"></a>2.3 HotSpot 虚拟机对象探秘</h1><h2 id="2-3-1-对象的创建"><a href="#2-3-1-对象的创建" class="headerlink" title="2.3.1 对象的创建"></a>2.3.1 对象的创建</h2><ol>
<li>类加载检查：new 类名，根据 new 的参数在常量池中定位一个类的符号引用，如果没有找到这个符号引用,说明类还未加载，则进行类的加载/解析和初始化。</li>
<li>虚拟机为对象分配内存(位于堆中)</li>
<li>将分配的内存初始化为零值(不包括对象头)，如果使用 TLAB ，这一过程可以提前至 TLAB 分配时进行</li>
<li>调用对象的<code>&lt;init&gt;</code>方法</li>
</ol>
<p>堆内存分配两种方式：指针碰撞(Bump the Pointer) : Java 堆中的内存是规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存也就是把指针向空闲空间那边移动一段与内存大小相等的距离。例如：Serial、ParNew 等收集器。空闲列表(Free List) : Java 堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，就没有办法简单的进行指针碰撞了。虚拟机必须维护一张列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。例如：CMS 这种基于 Mark-Sweep 算法的收集器。</p>
<p>堆内存分配并发解决方案：对分配内存空间的动作进行同步处理，实际上虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。本地线程分配缓冲 TLAB (Thread Local Allocation Buffer)，把内存分配的动作按照线程划分为在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(TLAB)。哪个线程要分配内存，就在哪个线程的TLAB上分配。只有TLAB用完并分配新的TLAB时，才需要同步锁定。</p>
<h2 id="2-3-2-对象的内存布局"><a href="#2-3-2-对象的内存布局" class="headerlink" title="2.3.2 对象的内存布局"></a>2.3.2 对象的内存布局</h2><ul>
<li>对象头( Header )<ul>
<li>对象自身运行时数据 ( Mark Word )，包含：哈希码 / GC分代年龄 / 锁状态标志 / 线程持有的锁 / 偏向线程ID / 偏向时间戳</li>
<li>类型指针：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
</ul>
</li>
<li>实例数据( Instance Data )<ul>
<li>对象真正存储的有效信息</li>
<li>程序代码中定义的各种类型的字段内容</li>
<li>HotSpot 虚拟机默认分配策略：longs/doubles/ints/shorts/chars/bytes/booleans/oops(Oridinary Object Pointers)</li>
</ul>
</li>
<li>对齐填充( Padding ),并不是必然存在的，仅仅起着占位符的作用。</li>
</ul>
<h2 id="2-3-2-对象的访问定位"><a href="#2-3-2-对象的访问定位" class="headerlink" title="2.3.2 对象的访问定位"></a>2.3.2 对象的访问定位</h2><ul>
<li>使用句柄：Java 堆中分配一块内存,reference 中存储的就是对象句柄地址,使用句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中实例数据地址，reference 本身不用改变。如下图所示：<img src="https://github.com/lujiahao0708/PicRepo/raw/master/blogPic/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/2.3.3%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt=""></li>
<li>直接指针：Java 堆中分配一块内存，reference 中存储的就是对象实例地址，HostSpot 使用此种方式，节省了一次指针定位的时间开销，提升了速度。如下图所示：<img src="https://github.com/lujiahao0708/PicRepo/raw/master/blogPic/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/2.3.3%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt=""></li>
</ul>
<h1 id="2-4-实战：OutOfMemoryError-异常"><a href="#2-4-实战：OutOfMemoryError-异常" class="headerlink" title="2.4 实战：OutOfMemoryError 异常"></a>2.4 实战：OutOfMemoryError 异常</h1><ul>
<li>MacBook Pro Retina, 2.6 GHz Intel Core i7, 16 GB 2133 MHz LPDDR3, OS X Yosemite</li>
<li>JDK 1.8</li>
</ul>
<h2 id="2-4-1-Java-堆溢出"><a href="#2-4-1-Java-堆溢出" class="headerlink" title="2.4.1 Java 堆溢出"></a>2.4.1 Java 堆溢出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java 堆内存溢出</span></span><br><span class="line"><span class="comment"> * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lujiahao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-12-21 14:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid1439.hprof ...</span><br><span class="line">Heap dump file created [28440089 bytes in 0.115 secs]</span><br><span class="line">Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3210)</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3181)</span><br><span class="line">	at java.util.ArrayList.grow(ArrayList.java:265)</span><br><span class="line">	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:239)</span><br><span class="line">	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:231)</span><br><span class="line">	at java.util.ArrayList.add(ArrayList.java:462)</span><br><span class="line">	at OutOfMemory.HeapOOM.main(HeapOOM.java:20)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure>



<h2 id="2-4-2-虚拟机栈和本地方法栈溢出"><a href="#2-4-2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2.4.2 虚拟机栈和本地方法栈溢出"></a>2.4.2 虚拟机栈和本地方法栈溢出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚拟机栈和本地方法栈溢出</span></span><br><span class="line"><span class="comment"> * VM Args: -Xss128k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lujiahao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-12-21 17:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设置128k,启动会报下面的问题</span><br><span class="line">The stack size specified is too small, Specify at least 160k</span><br><span class="line">Error: Could not create the Java Virtual Machine.</span><br><span class="line">Error: A fatal exception has occurred. Program will exit.</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修改为161k，实现效果</span><br><span class="line">stack length:7738</span><br><span class="line">Exception in thread "main" java.lang.StackOverflowError</span><br><span class="line">	at OutOfMemory.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:22)</span><br><span class="line">	at OutOfMemory.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:22)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程导致内存溢出   危险!!! 可能导致死机,我就不轻易尝试了</span></span><br><span class="line"><span class="comment"> * VM Args: -Xss2M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lujiahao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-12-21 17:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    dontStop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackOOM oom = <span class="keyword">new</span> JavaVMStackOOM();</span><br><span class="line">        oom.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-4-3-方法区和运行时常量池溢出"><a href="#2-4-3-方法区和运行时常量池溢出" class="headerlink" title="2.4.3 方法区和运行时常量池溢出"></a>2.4.3 方法区和运行时常量池溢出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行时常量池导致内存溢出</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:PermSize=10m -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment"> * jdk1.6</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用新版本的jdk会输出:</span></span><br><span class="line"><span class="comment"> * Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=10m; support was removed in 8.0</span></span><br><span class="line"><span class="comment"> * Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=10M; support was removed in 8.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lujiahao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-12-21 17:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用List保持炸常量池引用,避免Full GC回收常量池行为</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 10MB的PermSize在Integer范围内足够产生OOM了</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 借助CGLib使方法区出现内存溢出</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lujiahao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-12-21 17:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(objects, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-4-4-本机直接内存溢出"><a href="#2-4-4-本机直接内存溢出" class="headerlink" title="2.4.4 本机直接内存溢出"></a>2.4.4 本机直接内存溢出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本机直接内存溢出(使用unsafe分配本机内存)</span></span><br><span class="line"><span class="comment"> * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lujiahao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-12-21 17:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>欢迎大家关注😁<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-01-11T19:22:27.000Z" title="2019-01-11T19:22:27.000Z">2019-01-11</time><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></span><span class="level-item">6 分钟 读完 (大约 857 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/p/35b26ecb.html">还在用if else？策略模式了解一下！</a></h1><div class="content"><p>小编在公司负责的就是订单取消业务，老系统中各种类型订单取消都是通过if else 判断不同的订单类型进行不同的逻辑。在经历老系统的折磨和产品需求的不断变更，小编决定进行一次大的重构：消灭 if else。</p>
<p>接下来就向大家介绍下是如何消灭 if else。</p>
<h2 id="1-if-else模式"><a href="#1-if-else模式" class="headerlink" title="1. if else模式"></a>1. if else模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelOrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(OrderDTO orderDTO)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> serviceType = orderDTO.getServiceType();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == serviceType) &#123;</span><br><span class="line">            System.out.println(<span class="string">"取消即时订单"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> == serviceType) &#123;</span><br><span class="line">            System.out.println(<span class="string">"取消预约订单"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">3</span> == serviceType) &#123;</span><br><span class="line">            System.out.println(<span class="string">"取消拼车订单"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若干个月再来看就是这样的感觉<br><img src="http://i1.go2yd.com/image.php?url=0KDCiIBwkf" alt=""></p>
<h2 id="2-策略模式"><a href="#2-策略模式" class="headerlink" title="2. 策略模式"></a>2. 策略模式</h2><h3 id="2-1-策略模式实现的Service"><a href="#2-1-策略模式实现的Service" class="headerlink" title="2.1 策略模式实现的Service"></a>2.1 策略模式实现的Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelOrderStrategyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StrategyContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(OrderDTO orderDTO)</span> </span>&#123;</span><br><span class="line">        OrderTypeEnum orderTypeEnum = OrderTypeEnum.getByCode(orderDTO.getServiceType());</span><br><span class="line">        AbstractStrategy strategy = context.getStrategy(orderTypeEnum);</span><br><span class="line">        strategy.process(orderDTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简洁的有点过分了是不是!!!</p>
<h3 id="2-2-各种类型策略实现及抽象策略类"><a href="#2-2-各种类型策略实现及抽象策略类" class="headerlink" title="2.2 各种类型策略实现及抽象策略类"></a>2.2 各种类型策略实现及抽象策略类</h3><p>下面选取了即时订单和预约订单的策略.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@OrderTypeAnnotation</span>(orderType = OrderTypeEnum.INSTANT)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantOrderStrategy</span> <span class="keyword">extends</span> <span class="title">AbstractStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(OrderDTO orderDTO)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"取消即时订单"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@OrderTypeAnnotation</span>(orderType = OrderTypeEnum.BOOKING)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookingOrderStrategy</span> <span class="keyword">extends</span> <span class="title">AbstractStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(OrderDTO orderDTO)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"取消预约订单"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(OrderDTO orderDTO)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-策略类型注解"><a href="#2-3-策略类型注解" class="headerlink" title="2.3 策略类型注解"></a>2.3 策略类型注解</h3><p>每个策略中增加了注解OrderTypeAnnotation,以标注适用于不同类型的策略内容.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OrderTypeAnnotation &#123;</span><br><span class="line">    <span class="function">OrderTypeEnum <span class="title">orderType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-策略处理器类StrategyProcessor和策略上下文StrategyContext"><a href="#2-4-策略处理器类StrategyProcessor和策略上下文StrategyContext" class="headerlink" title="2.4 策略处理器类StrategyProcessor和策略上下文StrategyContext"></a>2.4 策略处理器类StrategyProcessor和策略上下文StrategyContext</h3><p>其中最为核心的为StrategyProcessor 策略处理器类和StrategyContext 策略上下文,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String STRATEGY_PACKAGE = <span class="string">"com.lujiahao.strategy"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        Map&lt;OrderTypeEnum, Class&gt; handlerMap = Maps.newHashMapWithExpectedSize(<span class="number">3</span>);</span><br><span class="line">        ClassScanner.scan(STRATEGY_PACKAGE, OrderTypeAnnotation<span class="class">.<span class="keyword">class</span>).<span class="title">forEach</span>(<span class="title">clazz</span> -&gt; </span>&#123;</span><br><span class="line">            OrderTypeEnum type = clazz.getAnnotation(OrderTypeAnnotation<span class="class">.<span class="keyword">class</span>).<span class="title">orderType</span>()</span>;</span><br><span class="line">            handlerMap.put(type, clazz);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        StrategyContext context = <span class="keyword">new</span> StrategyContext(handlerMap);</span><br><span class="line">        configurableListableBeanFactory.registerSingleton(StrategyContext<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">context</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;OrderTypeEnum, Class&gt; strategyMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StrategyContext</span><span class="params">(Map&lt;OrderTypeEnum, Class&gt; strategyMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategyMap = strategyMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractStrategy <span class="title">getStrategy</span><span class="params">(OrderTypeEnum orderTypeEnum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (orderTypeEnum == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not fond enum"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(strategyMap)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"strategy map is empty,please check you strategy package path"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class clazz = strategyMap.get(orderTypeEnum);</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not fond strategy for type:"</span> + orderTypeEnum.getCode());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (AbstractStrategy) SpringBeanUtils.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先会扫描指定包中标有@OrderTypeAnnotation的类</li>
<li>将符合类的对应的枚举值作为key，对应的类作为value，保存在策略Map中</li>
<li>初始化StrategyContext,并注册到spring容器中,同时将策略Map传入其中</li>
</ul>
<blockquote>
<p>我们使用了枚举作为Map中的key,相信大家很少有人这样操作过,不过可以放心操作.通过下面两篇文章解答大家的疑问.</p>
<ul>
<li><a href="https://blog.csdn.net/dalinsi/article/details/53064843">自定义枚举类 Enum 是否可以作为 HashMap 的key</a></li>
<li><a href="https://blog.csdn.net/zhuchunyan_aijia/article/details/81000065">Java 在 Map 中使用复杂数据类型作为 Key</a></li>
</ul>
</blockquote>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>策略模式极大的减少if else等模板代码,在提升代码可读性的同时,也大大增加代码的灵活性,添加新的策略即可以满足业务需求.<br>本人在我司业务中对策略模式的应用得到了很好的验证,从此再也不用担心产品改需求.<br>用策略模式一时爽,一直用一直爽😏!</p>
<h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h2><p><a href="https://github.com/lujiahao0708/LearnSeries/tree/master/LearnDesignPattern/src/main/java/com/lujiahao/strategy">完整代码</a></p>
<hr>
<p>欢迎大家关注😁<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" alt=""></p>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/6/">上一页</a></div><div class="pagination-next"><a href="/page/8/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/6/">6</a></li><li><a class="pagination-link is-current" href="/page/7/">7</a></li><li><a class="pagination-link" href="/page/8/">8</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/12/">12</a></li></ul></nav></div><!--!--><div class="column column-right is-3-tablet is-3-desktop is-3-widescreen  order-3"><!--!--><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="/img/avatar.png" alt="后端小哥"></figure><p class="title is-size-4 is-block line-height-inherit">后端小哥</p><p class="is-size-6 is-block">Coder</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shijiazhuang, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">111</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">20</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">67</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/lujiahao0708" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://juejin.im/user/59239002570c350069c5f0bb" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">掘金</span></span><span class="level-right"><span class="level-item tag">juejin.im</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://blog.csdn.net/xinruodingshui" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://space.bilibili.com/302086424/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">B站</span></span><span class="level-right"><span class="level-item tag">space.bilibili.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Chrome/"><span class="level-start"><span class="level-item">Chrome</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Flutter/"><span class="level-start"><span class="level-item">Flutter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Hexo/"><span class="level-start"><span class="level-item">Hexo</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JavaEE/"><span class="level-start"><span class="level-item">JavaEE</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Mac/"><span class="level-start"><span class="level-item">Mac</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"><span class="level-start"><span class="level-item">MySQL必知必会</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Shiro/"><span class="level-start"><span class="level-item">Shiro</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Simpleblog%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">Simpleblog博客系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/SpringCloud/"><span class="level-start"><span class="level-item">SpringCloud</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"><span class="level-start"><span class="level-item">工具教程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B9%B6%E5%8F%91/"><span class="level-start"><span class="level-item">并发</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"><span class="level-start"><span class="level-item">持续集成</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%97%A5%E5%BF%97/"><span class="level-start"><span class="level-item">日志</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-07T20:40:52.000Z">2020-05-07</time></p><p class="title is-6"><a class="link-muted" href="/p/43930bbd.html">Redis 系列（三）Redis 常用命令</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Redis/">Redis</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-04T20:40:52.000Z">2020-05-04</time></p><p class="title is-6"><a class="link-muted" href="/p/fe744d5a.html">Redis 系列（二）Redis 安装</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Redis/">Redis</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-01T17:40:52.000Z">2020-05-01</time></p><p class="title is-6"><a class="link-muted" href="/p/c8bef241.html">Redis 系列（一）NoSQL 简介</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Redis/">Redis</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-21T22:03:59.000Z">2020-04-21</time></p><p class="title is-6"><a class="link-muted" href="/p/29174125.html">Hexo 生成永久文章链接</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Hexo/">Hexo</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-20T10:40:52.000Z">2020-04-20</time></p><p class="title is-6"><a class="link-muted" href="/p/5c6f02af.html">Mac 多 Git 账户配置</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Mac/">Mac</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="后端小哥博客" height="28"></a><p class="size-small"><span>&copy; 2020 后端小哥</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/lujiahao0708"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://lujiahao0708.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: ''
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>