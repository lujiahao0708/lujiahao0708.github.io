<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>《Java 8 in Action》Chapter 12：新的日期和时间API - 后端小哥博客</title><meta description="《Java 8 in Action》Chapter 12：新的日期和时间API"><meta property="og:type" content="blog"><meta property="og:title" content="《Java 8 in Action》Chapter 12：新的日期和时间API"><meta property="og:url" content="http://lujiahao0708.github.io/"><meta property="og:site_name" content="后端小哥博客"><meta property="og:description" content="《Java 8 in Action》Chapter 12：新的日期和时间API"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2019-03-26T03:34:52.000Z"><meta property="article:modified_time" content="2020-02-26T07:13:37.498Z"><meta property="article:author" content="后端小哥"><meta property="article:tag" content="读书笔记"><meta property="article:tag" content="Java8"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://lujiahao0708.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://lujiahao0708.github.io/2019/03/26/%E3%80%8AJava%208%20in%20Action%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2012%EF%BC%9A%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4API/"},"headline":"后端小哥博客","image":["http://lujiahao0708.github.io/img/og_image.png"],"datePublished":"2019-03-26T03:34:52.000Z","dateModified":"2020-02-26T07:13:37.498Z","author":{"@type":"Person","name":"后端小哥"},"description":"《Java 8 in Action》Chapter 12：新的日期和时间API"}</script><link rel="canonical" href="http://lujiahao0708.github.io/2019/03/26/%E3%80%8AJava%208%20in%20Action%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2012%EF%BC%9A%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4API/"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="/css/default.css"><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cdef3b7efc8748063e32969cc0b8dedc";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="后端小哥博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories/Redis">Redis</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/lujiahao0708"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-26T03:34:52.000Z" title="2019-03-26T03:34:52.000Z">2019-03-26</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">27 分钟 读完 (大约 3987 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">《Java 8 in Action》Chapter 12：新的日期和时间API</h1><div class="content"><ul>
<li>在Java 1.0中，对日期和时间的支持只能依赖java.util.Date类。同时这个类还有两个很大的缺点：年份的起始选择是1900年，月份的起始从0开始。</li>
<li>在Java 1.1中，Date类中的很多方法被废弃，取而代之的是java.util.Calendar类。然而Calendar类也有类似的问题和设计缺陷，导致使用这些方法写出的代码非常容易出错。</li>
</ul>
<blockquote>
<p>DateFormat方法也有它自己的问题。比如，它不是线程安全的。这意味着两个线程如果尝试使用同一个formatter解析日期，你可能会得到无法预期的结果。</p>
</blockquote>
<h1 id="1-使用LocalDate-和LocalTime"><a href="#1-使用LocalDate-和LocalTime" class="headerlink" title="1. 使用LocalDate 和LocalTime"></a>1. 使用LocalDate 和LocalTime</h1><h2 id="1-1-LocalDate"><a href="#1-1-LocalDate" class="headerlink" title="1.1 LocalDate"></a>1.1 LocalDate</h2><p>Java 8提供新的日期和时间API,LocalDate类实例是一个不可变对象，只提供简单的日期并且不含当天时间信息。此外也不附带任何与时区相关的信息。</p>
<p>通过静态工厂方法of创建一个LocalDate实例。LocalDate实例提供了多种方法来读取常用的值，比如年份、月份、星期几等，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">int</span> year = localDate.getYear();</span><br><span class="line">Month month = localDate.getMonth();</span><br><span class="line"><span class="keyword">int</span> day = localDate.getDayOfMonth();</span><br><span class="line">DayOfWeek dow = localDate.getDayOfWeek();</span><br><span class="line"><span class="keyword">int</span> len = localDate.lengthOfMonth();</span><br><span class="line"><span class="keyword">boolean</span> leap = localDate.isLeapYear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用工厂方法从系统时钟中获取当前的日期</span></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line"></span><br><span class="line">System.out.println(String.format(<span class="string">"year:%s\nmonth:%s\nday:%s\ndow:%s\nlen:%s\nleap:%s"</span>, year, month, day, dow, len, leap));</span><br><span class="line">System.out.println(today);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">year:<span class="number">2014</span></span><br><span class="line">month:MARCH</span><br><span class="line">day:<span class="number">18</span></span><br><span class="line">dow:TUESDAY</span><br><span class="line">len:<span class="number">31</span></span><br><span class="line">leap:<span class="keyword">false</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">27</span></span><br></pre></td></tr></table></figure>

<p>Java 8日期-时间类都提供了类似的工厂方法。通过传递TemporalField参数给get方法拿到同样的信息。TemporalField接口定义了如何访问temporal对象某个字段的值。ChronoField枚举实现TemporalField接口,可以使用get方法得到枚举元素的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> year = localDate.get(ChronoField.YEAR);</span><br><span class="line"><span class="keyword">int</span> month = localDate.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line"><span class="keyword">int</span> day = localDate.get(ChronoField.DAY_OF_MONTH);</span><br></pre></td></tr></table></figure>

<h2 id="1-2-LocalTime"><a href="#1-2-LocalTime" class="headerlink" title="1.2 LocalTime"></a>1.2 LocalTime</h2><p>使用LocalTime类表示时间,可以使用of重载的两个工厂方法创建LocalTime的实例。</p>
<ul>
<li>第一个重载函数接收小时和分钟</li>
<li>第二个重载函数同时还接收秒。</li>
</ul>
<p>LocalTime类也提供了一些get方法访问这些变量的值，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.of(<span class="number">13</span>, <span class="number">45</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span> hour = localTime.getHour();</span><br><span class="line"><span class="keyword">int</span> minute = localTime.getMinute();</span><br><span class="line"><span class="keyword">int</span> second = localTime.getSecond();</span><br><span class="line">System.out.println(String.format(<span class="string">"hour:%s\nminute:%s\nsecond:%s"</span>, hour, minute, second));</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">hour:<span class="number">13</span></span><br><span class="line">minute:<span class="number">45</span></span><br><span class="line">second:<span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>LocalDate和LocalTime都可以通过解析代表它们的字符串创建。使用静态方法parse可以实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.parse(<span class="string">"2019-03-27"</span>);</span><br><span class="line">LocalTime time = LocalTime.parse(<span class="string">"20:17:08"</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以向parse方法传递一个DateTimeFormatter。该类的实例定义了如何格式化一个日期或者时间对象。用来替换老版java.util.DateFormat。<br>如果传递的字符串参数无法被解析为合法的LocalDate或LocalTime对象，这两个parse方法都会抛出一个继承自RuntimeException的DateTimeParseException异常。</p>
</blockquote>
<h1 id="2-合并日期和时间"><a href="#2-合并日期和时间" class="headerlink" title="2. 合并日期和时间"></a>2. 合并日期和时间</h1><p>复合类LocalDateTime，是LocalDate和LocalTime的合体。它同时表示了日期和时间，不带有时区信息。可以直接创建，也可以通过合并日期和时间对象构造。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LocalTime time = LocalTime.of(<span class="number">21</span>, <span class="number">31</span>, <span class="number">50</span>);</span><br><span class="line">LocalDate date = LocalDate.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">27</span>);</span><br><span class="line"></span><br><span class="line">LocalDateTime dt1 = LocalDateTime.of(<span class="number">2017</span>, Month.NOVEMBER, <span class="number">07</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">51</span>);</span><br><span class="line">LocalDateTime dt2 = LocalDateTime.of(date, time);</span><br><span class="line">LocalDateTime dt3 = date.atTime(<span class="number">22</span>, <span class="number">21</span>, <span class="number">14</span>);</span><br><span class="line">LocalDateTime dt4 = date.atTime(time);</span><br><span class="line">LocalDateTime dt5 = time.atDate(date);</span><br></pre></td></tr></table></figure>

<p>创建LocalDateTime对象</p>
<ul>
<li>直接创建</li>
<li>通过atTime方法向LocalDate传递一个时间对象</li>
<li>通过atDate方法向LocalTime传递一个时间对象</li>
</ul>
<p>也可以使用toLocalDate或者toLocalTime方法，从LocalDateTime中提取LocalDate或者LocalTime组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date1 = dt1.toLocalDate();</span><br><span class="line">LocalTime time1 = dt1.toLocalTime();</span><br></pre></td></tr></table></figure>

<h1 id="3-机器的日期和时间格式"><a href="#3-机器的日期和时间格式" class="headerlink" title="3. 机器的日期和时间格式"></a>3. 机器的日期和时间格式</h1><p>从计算机的角度来看，”2019年03月27日11:20:03”这样的方式是不容易理解的,计算机更加容易理解建模时间最自然的格式是表示一个持续时间段上某个点的单一大整型数。新的java.time.Instant类对时间建模的方式，基本上它是以Unix元年时间（传统的设定为UTC时区1970年1月1日午夜时分）开始所经历的秒数进行计算。</p>
<h2 id="3-1-创建Instant"><a href="#3-1-创建Instant" class="headerlink" title="3.1 创建Instant"></a>3.1 创建Instant</h2><ul>
<li>静态工厂方法ofEpochSecond传递一个代表秒数的值创建一个该类的实例。</li>
<li>静态工厂方法ofEpochSecond还有一个增强的重载版本，它接收第二个以纳秒为单位的参数值，对传入作为秒数的参数进行调整。重载的版本会调整纳秒参数，确保保存的纳秒分片在0到999 999999之间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instant.ofEpochSecond(<span class="number">3</span>);</span><br><span class="line">Instant.ofEpochSecond(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2 秒之后再加上100万纳秒（1秒）</span></span><br><span class="line">Instant.ofEpochSecond(<span class="number">2</span>, <span class="number">1_000_000_000</span>);</span><br><span class="line"><span class="comment">// 4秒之前的100万纳秒（1秒）</span></span><br><span class="line">Instant.ofEpochSecond(<span class="number">4</span>, -<span class="number">1_000_000_000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-2-工厂方法now"><a href="#3-2-工厂方法now" class="headerlink" title="3.2 工厂方法now"></a>3.2 工厂方法now</h2><p>Instant类也支持静态工厂方法now，它能够获取当前时刻的时间戳。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Instant now = Instant.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">27</span>T03:<span class="number">26</span>:<span class="number">39.451</span>Z</span><br></pre></td></tr></table></figure>

<p>Instant的设计初衷是为了便于机器使用,它包含的是由秒及纳秒所构成的数字。因此Instant无法处理那些我们非常容易理解的时间单位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> day = Instant.now().get(ChronoField.DAY_OF_MONTH);</span><br><span class="line">它会抛出下面这样的异常：</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.time.temporal.UnsupportedTemporalTypeException: Unsupported field: DayOfMonth</span><br><span class="line">但是你可以通过Duration和Period类使用Instant，接下来我们会对这部分内容进行介绍。</span><br></pre></td></tr></table></figure>

<h2 id="4-Duration和Period"><a href="#4-Duration和Period" class="headerlink" title="4. Duration和Period"></a>4. Duration和Period</h2><h2 id="4-1-Duration"><a href="#4-1-Duration" class="headerlink" title="4.1 Duration"></a>4.1 Duration</h2><p>所有类都实现了Temporal接口，该接口定义如何读取和操纵为时间建模的对象的值。如果需要创建两个Temporal对象之间的duration,就需要Duration类的静态工厂方法between。<br>可以创建两个LocalTimes对象、两个LocalDateTimes对象，或者两个Instant对象之间的duration：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LocalTime time1 = LocalTime.of(<span class="number">21</span>, <span class="number">50</span>, <span class="number">10</span>);</span><br><span class="line">LocalTime time2 = LocalTime.of(<span class="number">22</span>, <span class="number">50</span>, <span class="number">10</span>);</span><br><span class="line">LocalDateTime dateTime1 = LocalDateTime.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">20</span>, <span class="number">40</span>);</span><br><span class="line">LocalDateTime dateTime2 = LocalDateTime.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">20</span>, <span class="number">40</span>);</span><br><span class="line">Instant instant1 = Instant.ofEpochSecond(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>);</span><br><span class="line">Instant instant2 = Instant.ofEpochSecond(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Duration d1 = Duration.between(time1, time2);</span><br><span class="line">Duration d2 = Duration.between(dateTime1, dateTime2);</span><br><span class="line">Duration d3 = Duration.between(instant1, instant2);</span><br><span class="line"><span class="comment">// PT1H 相差1小时</span></span><br><span class="line">System.out.println(<span class="string">"d1:"</span> + d1);</span><br><span class="line"><span class="comment">// PT2H 相差2小时</span></span><br><span class="line">System.out.println(<span class="string">"d2:"</span> + d2);</span><br><span class="line"><span class="comment">// PT16H40M 相差16小时40分钟</span></span><br><span class="line">System.out.println(<span class="string">"d3:"</span> + d3);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>LocalDateTime是为了便于人阅读使用，Instant是为了便于机器处理，所以不能将二者混用。如果在这两类对象之间创建duration，会触发一个DateTimeException异常。<br>此外，由于Duration类主要用于以秒和纳秒衡量时间的长短，你不能仅向between方法传递一个LocalDate对象做参数。</p>
</blockquote>
<h2 id="4-2-Period"><a href="#4-2-Period" class="headerlink" title="4.2 Period"></a>4.2 Period</h2><p>使用Period类以年、月或者日的方式对多个时间单位建模。使用该类的工厂方法between，可以使用得到两个LocalDate之间的时长。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Period period = Period.between(LocalDate.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">7</span>), LocalDate.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">17</span>));</span><br><span class="line"><span class="comment">// 相差10天</span></span><br><span class="line">System.out.println(<span class="string">"Period between:"</span> + period);</span><br></pre></td></tr></table></figure>

<p>Duration和Period类都提供了很多非常方便的工厂类，直接创建对应的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Duration threeMinutes = Duration.ofMinutes(<span class="number">3</span>);</span><br><span class="line">Duration fourMinutes = Duration.of(<span class="number">4</span>, ChronoUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">Period tenDay = Period.ofDays(<span class="number">10</span>);</span><br><span class="line">Period threeWeeks = Period.ofWeeks(<span class="number">3</span>);</span><br><span class="line">Period twoYearsSixMonthsOneDay = Period.of(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">Duration类和Period类共享了很多相似的方法，有兴趣的可以参考官网的文档。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>截至目前，我们介绍的这些日期-时间对象都是不可修改的，这是为了更好地支持函数式编程，确保线程安全，保持领域模式一致性而做出的重大设计决定。<br>当然，新的日期和时间API也提供了一些便利的方法来创建这些对象的可变版本。比如，你可能希望在已有的LocalDate实例上增加3天。除此之外，我们还会介绍如何依据指定的模式，<br>比如dd/MM/yyyy，创建日期-时间格式器，以及如何使用这种格式器解析和输出日期。</p>
</blockquote>
<h1 id="5-操纵、解析和格式化日期"><a href="#5-操纵、解析和格式化日期" class="headerlink" title="5. 操纵、解析和格式化日期"></a>5. 操纵、解析和格式化日期</h1><p>如果已经有一个LocalDate对象，想要创建它的一个修改版，最直接也最简单的方法是使用withAttribute方法。withAttribute方法会创建对象的一个副本，并按照需要修改它的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这段代码中所有的方法都返回一个修改了属性的对象。它们都不会修改原来的对象！</span></span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2017</span>, <span class="number">12</span>, <span class="number">15</span>);</span><br><span class="line">LocalDate date2 = date1.withYear(<span class="number">2019</span>);</span><br><span class="line">LocalDate date3 = date2.withDayOfMonth(<span class="number">25</span>);</span><br><span class="line">LocalDate date4 = date3.with(ChronoField.MONTH_OF_YEAR, <span class="number">9</span>);</span><br></pre></td></tr></table></figure>

<p>它们都声明于Temporal接口，所有的日期和时间API类都实现这两个方法，它们定义了单点的时间，比如LocalDate、LocalTime、LocalDateTime以及Instant。更确切地说，使用get和with方法，我们可以将Temporal对象值的读取和修改区分开。如果Temporal对象不支持请求访问的字段，它会抛出一个UnsupportedTemporalTypeException异常，比如试图访问Instant对象的ChronoField.MONTH_OF_YEAR字段，或者LocalDate对象的ChronoField.NANO_OF_SECOND字段时都会抛出这样的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以声明的方式操纵LocalDate对象,可以加上或者减去一段时间</span></span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">10</span>, <span class="number">19</span>);</span><br><span class="line">LocalDate date2 = date1.plusWeeks(<span class="number">1</span>);</span><br><span class="line">LocalDate date3 = date2.minusYears(<span class="number">3</span>);</span><br><span class="line">LocalDate date4 = date3.plus(<span class="number">6</span>, ChronoUnit.MONTHS);</span><br></pre></td></tr></table></figure>

<p>与我们刚才介绍的get和with方法类似最后一行使用的plus方法也是通用方法，它和minus方法都声明于Temporal接口中。通过这些方法，对TemporalUnit对象加上或者减去一个数字，我们能非常方便地将Temporal对象前溯或者回滚至某个时间段，通过ChronoUnit枚举我们可以非常方便地实现TemporalUnit接口。</p>
<h1 id="6-使用TemporalAdjuster"><a href="#6-使用TemporalAdjuster" class="headerlink" title="6. 使用TemporalAdjuster"></a>6. 使用TemporalAdjuster</h1><p>有时需要进行一些更加复杂的操作，比如，将日期调整到下个周日、下个工作日，或者是本月的最后一天。可以使用重载版本的with方法，向其传递一个提供了更多定制化选择的TemporalAdjuster对象，更加灵活地处理日期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于最常见的用例，日期和时间API已经提供了大量预定义的TemporalAdjuster。可以通过TemporalAdjuster类的静态工厂方法访问。</span></span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2013</span>, <span class="number">12</span>, <span class="number">11</span>);</span><br><span class="line">LocalDate date2 = date1.with(TemporalAdjusters.nextOrSame(DayOfWeek.MONDAY));</span><br><span class="line">LocalDate date3 = date2.with(TemporalAdjusters.lastDayOfMonth());</span><br></pre></td></tr></table></figure>

<p>使用TemporalAdjuster可以进行更加复杂的日期操作，方法的名称很直观。如果没有找到符合预期的预定义的TemporalAdjuster，可以创建自定义的TemporalAdjuster。TemporalAdjuster接口只声明一个方法（即函数式接口）。实现该接口需要定义如何将一个Temporal对象转换为另一个Temporal对象,可以把它看成一个UnaryOperator<Temporal>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TemporalAdjuster</span> </span>&#123;</span><br><span class="line">    <span class="function">Temporal <span class="title">adjustInto</span><span class="params">(Temporal temporal)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="7-打印输出及解析日期-时间对象"><a href="#7-打印输出及解析日期-时间对象" class="headerlink" title="7. 打印输出及解析日期-时间对象"></a>7. 打印输出及解析日期-时间对象</h1><p>新的java.time.format包就是特别为格式化以及解析日期-时间对象而设计的。其中最重要的类是DateTimeFormatter。创建格式器最简单的方法是通过它的静态工厂方法以及常量。所有的DateTimeFormatter实例都能用于以一定的格式创建代表特定日期或时间的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2013</span>, <span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line">String s1 = date.format(DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">String s2 = date.format(DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line"></span><br><span class="line"><span class="number">20131011</span></span><br><span class="line"><span class="number">2013</span>-<span class="number">10</span>-<span class="number">11</span></span><br></pre></td></tr></table></figure>

<p>通过解析代表日期或时间的字符串重新创建该日期对象，也可以使用工厂方法parse重新创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date2 = LocalDate.parse(<span class="string">"20141007"</span>, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate date3 = LocalDate.parse(<span class="string">"2014-10-07"</span>, DateTimeFormatter.ISO_LOCAL_DATE);</span><br></pre></td></tr></table></figure>

<p>DateTimeFormatter实例是线程安全的，老的java.util.DateFormat线程不安全。单例模式创建格式器实例，在多个线程间共享实例是没有问题的。也可以通过ofPattern静态工厂方法，按照某个特定的模式创建格式器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"dd/MM/yyyy"</span>);</span><br><span class="line">String formattedDateStr = date.format(formatter);</span><br><span class="line">LocalDate date1 = LocalDate.parse(formattedDateStr, formatter);</span><br></pre></td></tr></table></figure>

<p>ofPattern方法也提供了一个重载的版本，可以传入Locale创建格式器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter italianFormatter = DateTimeFormatter.ofPattern(<span class="string">"d. MMMM yyyy"</span>, Locale.ITALIAN);</span><br><span class="line">LocalDate date = LocalDate.of(<span class="number">2015</span>, <span class="number">11</span>, <span class="number">14</span>);</span><br><span class="line">String formattedDate = date.format(italianFormatter);</span><br><span class="line">LocalDate date1 = LocalDate.parse(formattedDate, italianFormatter);</span><br></pre></td></tr></table></figure>

<p>DateTimeFormatterBuilder类还提供了更复杂的格式器,以提供更加细粒度的控制。同时也提供非常强大的解析功能，比如区分大小写的解析、柔性解析、填充，以及在格式器中指定可选节等等。</p>
<p>通过DateTimeFormatterBuilder自定义格式器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter italianFormatter = <span class="keyword">new</span> DateTimeFormatterBuilder()</span><br><span class="line">                .appendText(ChronoField.DAY_OF_MONTH)</span><br><span class="line">                .appendLiteral(<span class="string">". "</span>)</span><br><span class="line">                .appendText(ChronoField.MONTH_OF_YEAR)</span><br><span class="line">                .appendLiteral(<span class="string">" "</span>)</span><br><span class="line">                .appendText(ChronoField.YEAR)</span><br><span class="line">                .parseCaseInsensitive()</span><br><span class="line">                .toFormatter(Locale.ITALIAN);</span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">String s = now.format(italianFormatter);</span><br></pre></td></tr></table></figure>

<h1 id="8-处理不同的时区和历法"><a href="#8-处理不同的时区和历法" class="headerlink" title="8. 处理不同的时区和历法"></a>8. 处理不同的时区和历法</h1><p>新版日期和时间API新增加的重要功能是时区的处理。新的java.time.ZoneId类替代老版java.util.TimeZone。跟其他日期和时间类一样，ZoneId类也是无法修改的。是按照一定的规则将区域划分成的标准时间相同的区间。在ZoneRules这个类中包含了40个时区实例,可以通过调用ZoneId的getRules()得到指定时区的规则,每个特定的ZoneId对象都由一个地区ID标识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZoneId shanghaiZone = ZoneId.of(<span class="string">"Asia/Shanghai"</span>);</span><br></pre></td></tr></table></figure>

<p>Java 8的新方法toZoneId将一个老的时区对象转换为ZoneId。地区ID都为“{区域}/{城市}”的格式，地区集合的设定都由英特网编号分配机构（IANA）的时区数据库提供。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZoneId zoneId = TimeZone.getDefault().toZoneId();</span><br></pre></td></tr></table></figure>

<p>ZoneId对象可以与LocalDate、LocalDateTime或者是Instant对象整合构造为成ZonedDateTime实例，它代表了相对于指定时区的时间点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">27</span>);</span><br><span class="line">ZonedDateTime zdt1 = date.atStartOfDay(shanghaiZone);</span><br><span class="line"></span><br><span class="line">LocalDateTime dateTime = LocalDateTime.of(<span class="number">2015</span>, <span class="number">12</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">ZonedDateTime zdt2 = dateTime.atZone(shanghaiZone);</span><br><span class="line"></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">ZonedDateTime zdt3 = instant.atZone(shanghaiZone);</span><br><span class="line">通过ZoneId，你还可以将LocalDateTime转换为Instant：</span><br><span class="line"></span><br><span class="line">LocalDateTime dateTime = LocalDateTime.of(<span class="number">2016</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">35</span>);</span><br><span class="line">Instant instantFromDateTime = dateTime.toInstant(shanghaiZone);</span><br><span class="line">你也可以通过反向的方式得到LocalDateTime对象：</span><br><span class="line"></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">LocalDateTime timeFromInstant = LocalDateTime.ofInstant(instant, shanghaiZone);</span><br></pre></td></tr></table></figure>

<p>另一种比较通用的表达时区的方式是利用当前时区和UTC/格林尼治的固定偏差。使用ZoneId的一个子类ZoneOffset，表示的是当前时间和伦敦格林尼治子午线时间的差异：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZoneOffset newYorkOffset = ZoneOffset.of(<span class="string">"-05:00"</span>);</span><br></pre></td></tr></table></figure>

<h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h1><ul>
<li>Java 8之前老版的java.util.Date类以及其他用于建模日期时间的类有很多不一致及设计上的缺陷，包括易变性以及糟糕的偏移值、默认值和命名。</li>
<li>新版的日期和时间API中，日期-时间对象是不可变的。</li>
<li>新的API提供了两种不同的时间表示方式，有效地区分了运行时人和机器的不同需求。</li>
<li>你可以用绝对或者相对的方式操纵日期和时间，操作的结果总是返回一个新的实例，老的日期时间对象不会发生变化。</li>
<li>TemporalAdjuster让你能够用更精细的方式操纵日期，不再局限于一次只能改变它的一个值，并且你还可按照需求定义自己的日期转换器。</li>
<li>你现在可以按照特定的格式需求，定义自己的格式器，打印输出或者解析日期时间对象。这些格式器可以通过模板创建，也可以自己编程创建，并且它们都是线程安全的。</li>
<li>你可以用相对于某个地区/位置的方式，或者以与UTC/格林尼治时间的绝对偏差的方式表示时区，并将其应用到日期时间对象上，对其进行本地化。</li>
</ul>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我的公众号：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><a class="link-muted mr-2" rel="tag" href="/tags/Java8/">Java8</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpeg" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat_pay.jpeg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/04/12/%E3%80%8AElasticsearch%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Chapter%201.1%20Elasticsearch%E5%85%A5%E9%97%A8%E5%92%8C%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">《Elasticsearch技术解析与实战》Chapter 1.1：Elasticsearch入门和倒排索引</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/03/24/%E3%80%8AJava%208%20in%20Action%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"><span class="level-item">《Java 8 in Action》Chapter 11：CompletableFuture：组合式异步编程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-3-tablet is-3-desktop is-3-widescreen  order-3"><!--!--><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="/img/avatar.png" alt="后端小哥"></figure><p class="title is-size-4 is-block line-height-inherit">后端小哥</p><p class="is-size-6 is-block">Coder</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shijiazhuang, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">107</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">20</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">65</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/lujiahao0708" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://juejin.im/user/59239002570c350069c5f0bb" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">掘金</span></span><span class="level-right"><span class="level-item tag">juejin.im</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://blog.csdn.net/xinruodingshui" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://space.bilibili.com/302086424/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">B站</span></span><span class="level-right"><span class="level-item tag">space.bilibili.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Chrome/"><span class="level-start"><span class="level-item">Chrome</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Flutter/"><span class="level-start"><span class="level-item">Flutter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Hexo/"><span class="level-start"><span class="level-item">Hexo</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JavaEE/"><span class="level-start"><span class="level-item">JavaEE</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Mac/"><span class="level-start"><span class="level-item">Mac</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"><span class="level-start"><span class="level-item">MySQL必知必会</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Shiro/"><span class="level-start"><span class="level-item">Shiro</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Simpleblog%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">Simpleblog博客系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/SpringCloud/"><span class="level-start"><span class="level-item">SpringCloud</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"><span class="level-start"><span class="level-item">工具教程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B9%B6%E5%8F%91/"><span class="level-start"><span class="level-item">并发</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"><span class="level-start"><span class="level-item">持续集成</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%97%A5%E5%BF%97/"><span class="level-start"><span class="level-item">日志</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-11T09:28:08.000Z">2020-04-11</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/11/Redis/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Redis学习笔记</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Redis/">Redis</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-11T09:25:40.000Z">2020-04-11</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/11/Redis/Redis%E5%AE%89%E8%A3%85-%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83-%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/">Redis安装&amp;搭建本地环境&amp;备份恢复</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Redis/">Redis</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2019-12-20T12:54:41.000Z">2019-12-20</time></p><p class="title is-6"><a class="link-muted" href="/2019/12/20/MySQL/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AC%AC6-7%E7%AB%A0%20%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/">《MySQL必知必会》第6-7章 过滤数据与数据过滤</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">MySQL必知必会</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2019-12-19T14:54:41.000Z">2019-12-19</time></p><p class="title is-6"><a class="link-muted" href="/2019/12/19/MySQL/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AC%AC4-5%E7%AB%A0%20SELECT%E6%A3%80%E7%B4%A2%E4%B8%8E%E6%8E%92%E5%BA%8F/">《MySQL必知必会》第4-5章 SELECT检索与排序</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">MySQL必知必会</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2019-12-19T11:54:41.000Z">2019-12-19</time></p><p class="title is-6"><a class="link-muted" href="/2019/12/19/MySQL/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AC%AC1-3%E7%AB%A0%20MySQL%E4%BB%8B%E7%BB%8D/">《MySQL必知必会》第1-3章 MySQL介绍</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">MySQL必知必会</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="后端小哥博客" height="28"></a><p class="size-small"><span>&copy; 2020 后端小哥</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/lujiahao0708"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://lujiahao0708.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: ''
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>