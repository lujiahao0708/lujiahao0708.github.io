<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: Java8 - 后端小哥博客</title><meta description="一个 Java 程序猿"><meta property="og:type" content="blog"><meta property="og:title" content="后端小哥博客"><meta property="og:url" content="http://lujiahao0708.github.io/"><meta property="og:site_name" content="后端小哥博客"><meta property="og:description" content="一个 Java 程序猿"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="后端小哥"><meta property="article:tag" content="博客"><meta property="article:tag" content="技术博客"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://lujiahao0708.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://lujiahao0708.github.io"},"headline":"后端小哥博客","image":["http://lujiahao0708.github.io/img/og_image.png"],"author":{"@type":"Person","name":"后端小哥"},"description":"一个 Java 程序猿"}</script><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="/css/default.css"><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cdef3b7efc8748063e32969cc0b8dedc";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="后端小哥博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories/Redis">Redis</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/lujiahao0708"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">Java8</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-26T03:34:52.000Z" title="2019-03-26T03:34:52.000Z">2019-03-26</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">27 分钟 读完 (大约 3987 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/26/%E3%80%8AJava%208%20in%20Action%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2012%EF%BC%9A%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4API/">《Java 8 in Action》Chapter 12：新的日期和时间API</a></h1><div class="content"><ul>
<li>在Java 1.0中，对日期和时间的支持只能依赖java.util.Date类。同时这个类还有两个很大的缺点：年份的起始选择是1900年，月份的起始从0开始。</li>
<li>在Java 1.1中，Date类中的很多方法被废弃，取而代之的是java.util.Calendar类。然而Calendar类也有类似的问题和设计缺陷，导致使用这些方法写出的代码非常容易出错。</li>
</ul>
<blockquote>
<p>DateFormat方法也有它自己的问题。比如，它不是线程安全的。这意味着两个线程如果尝试使用同一个formatter解析日期，你可能会得到无法预期的结果。</p>
</blockquote>
<h1 id="1-使用LocalDate-和LocalTime"><a href="#1-使用LocalDate-和LocalTime" class="headerlink" title="1. 使用LocalDate 和LocalTime"></a>1. 使用LocalDate 和LocalTime</h1><h2 id="1-1-LocalDate"><a href="#1-1-LocalDate" class="headerlink" title="1.1 LocalDate"></a>1.1 LocalDate</h2><p>Java 8提供新的日期和时间API,LocalDate类实例是一个不可变对象，只提供简单的日期并且不含当天时间信息。此外也不附带任何与时区相关的信息。</p>
<p>通过静态工厂方法of创建一个LocalDate实例。LocalDate实例提供了多种方法来读取常用的值，比如年份、月份、星期几等，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">int</span> year = localDate.getYear();</span><br><span class="line">Month month = localDate.getMonth();</span><br><span class="line"><span class="keyword">int</span> day = localDate.getDayOfMonth();</span><br><span class="line">DayOfWeek dow = localDate.getDayOfWeek();</span><br><span class="line"><span class="keyword">int</span> len = localDate.lengthOfMonth();</span><br><span class="line"><span class="keyword">boolean</span> leap = localDate.isLeapYear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用工厂方法从系统时钟中获取当前的日期</span></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line"></span><br><span class="line">System.out.println(String.format(<span class="string">"year:%s\nmonth:%s\nday:%s\ndow:%s\nlen:%s\nleap:%s"</span>, year, month, day, dow, len, leap));</span><br><span class="line">System.out.println(today);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">year:<span class="number">2014</span></span><br><span class="line">month:MARCH</span><br><span class="line">day:<span class="number">18</span></span><br><span class="line">dow:TUESDAY</span><br><span class="line">len:<span class="number">31</span></span><br><span class="line">leap:<span class="keyword">false</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">27</span></span><br></pre></td></tr></table></figure>

<p>Java 8日期-时间类都提供了类似的工厂方法。通过传递TemporalField参数给get方法拿到同样的信息。TemporalField接口定义了如何访问temporal对象某个字段的值。ChronoField枚举实现TemporalField接口,可以使用get方法得到枚举元素的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> year = localDate.get(ChronoField.YEAR);</span><br><span class="line"><span class="keyword">int</span> month = localDate.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line"><span class="keyword">int</span> day = localDate.get(ChronoField.DAY_OF_MONTH);</span><br></pre></td></tr></table></figure>

<h2 id="1-2-LocalTime"><a href="#1-2-LocalTime" class="headerlink" title="1.2 LocalTime"></a>1.2 LocalTime</h2><p>使用LocalTime类表示时间,可以使用of重载的两个工厂方法创建LocalTime的实例。</p>
<ul>
<li>第一个重载函数接收小时和分钟</li>
<li>第二个重载函数同时还接收秒。</li>
</ul>
<p>LocalTime类也提供了一些get方法访问这些变量的值，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.of(<span class="number">13</span>, <span class="number">45</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span> hour = localTime.getHour();</span><br><span class="line"><span class="keyword">int</span> minute = localTime.getMinute();</span><br><span class="line"><span class="keyword">int</span> second = localTime.getSecond();</span><br><span class="line">System.out.println(String.format(<span class="string">"hour:%s\nminute:%s\nsecond:%s"</span>, hour, minute, second));</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">hour:<span class="number">13</span></span><br><span class="line">minute:<span class="number">45</span></span><br><span class="line">second:<span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>LocalDate和LocalTime都可以通过解析代表它们的字符串创建。使用静态方法parse可以实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.parse(<span class="string">"2019-03-27"</span>);</span><br><span class="line">LocalTime time = LocalTime.parse(<span class="string">"20:17:08"</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以向parse方法传递一个DateTimeFormatter。该类的实例定义了如何格式化一个日期或者时间对象。用来替换老版java.util.DateFormat。<br>如果传递的字符串参数无法被解析为合法的LocalDate或LocalTime对象，这两个parse方法都会抛出一个继承自RuntimeException的DateTimeParseException异常。</p>
</blockquote>
<h1 id="2-合并日期和时间"><a href="#2-合并日期和时间" class="headerlink" title="2. 合并日期和时间"></a>2. 合并日期和时间</h1><p>复合类LocalDateTime，是LocalDate和LocalTime的合体。它同时表示了日期和时间，不带有时区信息。可以直接创建，也可以通过合并日期和时间对象构造。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LocalTime time = LocalTime.of(<span class="number">21</span>, <span class="number">31</span>, <span class="number">50</span>);</span><br><span class="line">LocalDate date = LocalDate.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">27</span>);</span><br><span class="line"></span><br><span class="line">LocalDateTime dt1 = LocalDateTime.of(<span class="number">2017</span>, Month.NOVEMBER, <span class="number">07</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">51</span>);</span><br><span class="line">LocalDateTime dt2 = LocalDateTime.of(date, time);</span><br><span class="line">LocalDateTime dt3 = date.atTime(<span class="number">22</span>, <span class="number">21</span>, <span class="number">14</span>);</span><br><span class="line">LocalDateTime dt4 = date.atTime(time);</span><br><span class="line">LocalDateTime dt5 = time.atDate(date);</span><br></pre></td></tr></table></figure>

<p>创建LocalDateTime对象</p>
<ul>
<li>直接创建</li>
<li>通过atTime方法向LocalDate传递一个时间对象</li>
<li>通过atDate方法向LocalTime传递一个时间对象</li>
</ul>
<p>也可以使用toLocalDate或者toLocalTime方法，从LocalDateTime中提取LocalDate或者LocalTime组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date1 = dt1.toLocalDate();</span><br><span class="line">LocalTime time1 = dt1.toLocalTime();</span><br></pre></td></tr></table></figure>

<h1 id="3-机器的日期和时间格式"><a href="#3-机器的日期和时间格式" class="headerlink" title="3. 机器的日期和时间格式"></a>3. 机器的日期和时间格式</h1><p>从计算机的角度来看，”2019年03月27日11:20:03”这样的方式是不容易理解的,计算机更加容易理解建模时间最自然的格式是表示一个持续时间段上某个点的单一大整型数。新的java.time.Instant类对时间建模的方式，基本上它是以Unix元年时间（传统的设定为UTC时区1970年1月1日午夜时分）开始所经历的秒数进行计算。</p>
<h2 id="3-1-创建Instant"><a href="#3-1-创建Instant" class="headerlink" title="3.1 创建Instant"></a>3.1 创建Instant</h2><ul>
<li>静态工厂方法ofEpochSecond传递一个代表秒数的值创建一个该类的实例。</li>
<li>静态工厂方法ofEpochSecond还有一个增强的重载版本，它接收第二个以纳秒为单位的参数值，对传入作为秒数的参数进行调整。重载的版本会调整纳秒参数，确保保存的纳秒分片在0到999 999999之间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instant.ofEpochSecond(<span class="number">3</span>);</span><br><span class="line">Instant.ofEpochSecond(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2 秒之后再加上100万纳秒（1秒）</span></span><br><span class="line">Instant.ofEpochSecond(<span class="number">2</span>, <span class="number">1_000_000_000</span>);</span><br><span class="line"><span class="comment">// 4秒之前的100万纳秒（1秒）</span></span><br><span class="line">Instant.ofEpochSecond(<span class="number">4</span>, -<span class="number">1_000_000_000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-2-工厂方法now"><a href="#3-2-工厂方法now" class="headerlink" title="3.2 工厂方法now"></a>3.2 工厂方法now</h2><p>Instant类也支持静态工厂方法now，它能够获取当前时刻的时间戳。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Instant now = Instant.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">27</span>T03:<span class="number">26</span>:<span class="number">39.451</span>Z</span><br></pre></td></tr></table></figure>

<p>Instant的设计初衷是为了便于机器使用,它包含的是由秒及纳秒所构成的数字。因此Instant无法处理那些我们非常容易理解的时间单位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> day = Instant.now().get(ChronoField.DAY_OF_MONTH);</span><br><span class="line">它会抛出下面这样的异常：</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.time.temporal.UnsupportedTemporalTypeException: Unsupported field: DayOfMonth</span><br><span class="line">但是你可以通过Duration和Period类使用Instant，接下来我们会对这部分内容进行介绍。</span><br></pre></td></tr></table></figure>

<h2 id="4-Duration和Period"><a href="#4-Duration和Period" class="headerlink" title="4. Duration和Period"></a>4. Duration和Period</h2><h2 id="4-1-Duration"><a href="#4-1-Duration" class="headerlink" title="4.1 Duration"></a>4.1 Duration</h2><p>所有类都实现了Temporal接口，该接口定义如何读取和操纵为时间建模的对象的值。如果需要创建两个Temporal对象之间的duration,就需要Duration类的静态工厂方法between。<br>可以创建两个LocalTimes对象、两个LocalDateTimes对象，或者两个Instant对象之间的duration：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LocalTime time1 = LocalTime.of(<span class="number">21</span>, <span class="number">50</span>, <span class="number">10</span>);</span><br><span class="line">LocalTime time2 = LocalTime.of(<span class="number">22</span>, <span class="number">50</span>, <span class="number">10</span>);</span><br><span class="line">LocalDateTime dateTime1 = LocalDateTime.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">20</span>, <span class="number">40</span>);</span><br><span class="line">LocalDateTime dateTime2 = LocalDateTime.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">20</span>, <span class="number">40</span>);</span><br><span class="line">Instant instant1 = Instant.ofEpochSecond(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>);</span><br><span class="line">Instant instant2 = Instant.ofEpochSecond(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Duration d1 = Duration.between(time1, time2);</span><br><span class="line">Duration d2 = Duration.between(dateTime1, dateTime2);</span><br><span class="line">Duration d3 = Duration.between(instant1, instant2);</span><br><span class="line"><span class="comment">// PT1H 相差1小时</span></span><br><span class="line">System.out.println(<span class="string">"d1:"</span> + d1);</span><br><span class="line"><span class="comment">// PT2H 相差2小时</span></span><br><span class="line">System.out.println(<span class="string">"d2:"</span> + d2);</span><br><span class="line"><span class="comment">// PT16H40M 相差16小时40分钟</span></span><br><span class="line">System.out.println(<span class="string">"d3:"</span> + d3);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>LocalDateTime是为了便于人阅读使用，Instant是为了便于机器处理，所以不能将二者混用。如果在这两类对象之间创建duration，会触发一个DateTimeException异常。<br>此外，由于Duration类主要用于以秒和纳秒衡量时间的长短，你不能仅向between方法传递一个LocalDate对象做参数。</p>
</blockquote>
<h2 id="4-2-Period"><a href="#4-2-Period" class="headerlink" title="4.2 Period"></a>4.2 Period</h2><p>使用Period类以年、月或者日的方式对多个时间单位建模。使用该类的工厂方法between，可以使用得到两个LocalDate之间的时长。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Period period = Period.between(LocalDate.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">7</span>), LocalDate.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">17</span>));</span><br><span class="line"><span class="comment">// 相差10天</span></span><br><span class="line">System.out.println(<span class="string">"Period between:"</span> + period);</span><br></pre></td></tr></table></figure>

<p>Duration和Period类都提供了很多非常方便的工厂类，直接创建对应的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Duration threeMinutes = Duration.ofMinutes(<span class="number">3</span>);</span><br><span class="line">Duration fourMinutes = Duration.of(<span class="number">4</span>, ChronoUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">Period tenDay = Period.ofDays(<span class="number">10</span>);</span><br><span class="line">Period threeWeeks = Period.ofWeeks(<span class="number">3</span>);</span><br><span class="line">Period twoYearsSixMonthsOneDay = Period.of(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">Duration类和Period类共享了很多相似的方法，有兴趣的可以参考官网的文档。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>截至目前，我们介绍的这些日期-时间对象都是不可修改的，这是为了更好地支持函数式编程，确保线程安全，保持领域模式一致性而做出的重大设计决定。<br>当然，新的日期和时间API也提供了一些便利的方法来创建这些对象的可变版本。比如，你可能希望在已有的LocalDate实例上增加3天。除此之外，我们还会介绍如何依据指定的模式，<br>比如dd/MM/yyyy，创建日期-时间格式器，以及如何使用这种格式器解析和输出日期。</p>
</blockquote>
<h1 id="5-操纵、解析和格式化日期"><a href="#5-操纵、解析和格式化日期" class="headerlink" title="5. 操纵、解析和格式化日期"></a>5. 操纵、解析和格式化日期</h1><p>如果已经有一个LocalDate对象，想要创建它的一个修改版，最直接也最简单的方法是使用withAttribute方法。withAttribute方法会创建对象的一个副本，并按照需要修改它的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这段代码中所有的方法都返回一个修改了属性的对象。它们都不会修改原来的对象！</span></span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2017</span>, <span class="number">12</span>, <span class="number">15</span>);</span><br><span class="line">LocalDate date2 = date1.withYear(<span class="number">2019</span>);</span><br><span class="line">LocalDate date3 = date2.withDayOfMonth(<span class="number">25</span>);</span><br><span class="line">LocalDate date4 = date3.with(ChronoField.MONTH_OF_YEAR, <span class="number">9</span>);</span><br></pre></td></tr></table></figure>

<p>它们都声明于Temporal接口，所有的日期和时间API类都实现这两个方法，它们定义了单点的时间，比如LocalDate、LocalTime、LocalDateTime以及Instant。更确切地说，使用get和with方法，我们可以将Temporal对象值的读取和修改区分开。如果Temporal对象不支持请求访问的字段，它会抛出一个UnsupportedTemporalTypeException异常，比如试图访问Instant对象的ChronoField.MONTH_OF_YEAR字段，或者LocalDate对象的ChronoField.NANO_OF_SECOND字段时都会抛出这样的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以声明的方式操纵LocalDate对象,可以加上或者减去一段时间</span></span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">10</span>, <span class="number">19</span>);</span><br><span class="line">LocalDate date2 = date1.plusWeeks(<span class="number">1</span>);</span><br><span class="line">LocalDate date3 = date2.minusYears(<span class="number">3</span>);</span><br><span class="line">LocalDate date4 = date3.plus(<span class="number">6</span>, ChronoUnit.MONTHS);</span><br></pre></td></tr></table></figure>

<p>与我们刚才介绍的get和with方法类似最后一行使用的plus方法也是通用方法，它和minus方法都声明于Temporal接口中。通过这些方法，对TemporalUnit对象加上或者减去一个数字，我们能非常方便地将Temporal对象前溯或者回滚至某个时间段，通过ChronoUnit枚举我们可以非常方便地实现TemporalUnit接口。</p>
<h1 id="6-使用TemporalAdjuster"><a href="#6-使用TemporalAdjuster" class="headerlink" title="6. 使用TemporalAdjuster"></a>6. 使用TemporalAdjuster</h1><p>有时需要进行一些更加复杂的操作，比如，将日期调整到下个周日、下个工作日，或者是本月的最后一天。可以使用重载版本的with方法，向其传递一个提供了更多定制化选择的TemporalAdjuster对象，更加灵活地处理日期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于最常见的用例，日期和时间API已经提供了大量预定义的TemporalAdjuster。可以通过TemporalAdjuster类的静态工厂方法访问。</span></span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2013</span>, <span class="number">12</span>, <span class="number">11</span>);</span><br><span class="line">LocalDate date2 = date1.with(TemporalAdjusters.nextOrSame(DayOfWeek.MONDAY));</span><br><span class="line">LocalDate date3 = date2.with(TemporalAdjusters.lastDayOfMonth());</span><br></pre></td></tr></table></figure>

<p>使用TemporalAdjuster可以进行更加复杂的日期操作，方法的名称很直观。如果没有找到符合预期的预定义的TemporalAdjuster，可以创建自定义的TemporalAdjuster。TemporalAdjuster接口只声明一个方法（即函数式接口）。实现该接口需要定义如何将一个Temporal对象转换为另一个Temporal对象,可以把它看成一个UnaryOperator<Temporal>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TemporalAdjuster</span> </span>&#123;</span><br><span class="line">    <span class="function">Temporal <span class="title">adjustInto</span><span class="params">(Temporal temporal)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="7-打印输出及解析日期-时间对象"><a href="#7-打印输出及解析日期-时间对象" class="headerlink" title="7. 打印输出及解析日期-时间对象"></a>7. 打印输出及解析日期-时间对象</h1><p>新的java.time.format包就是特别为格式化以及解析日期-时间对象而设计的。其中最重要的类是DateTimeFormatter。创建格式器最简单的方法是通过它的静态工厂方法以及常量。所有的DateTimeFormatter实例都能用于以一定的格式创建代表特定日期或时间的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2013</span>, <span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line">String s1 = date.format(DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">String s2 = date.format(DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line"></span><br><span class="line"><span class="number">20131011</span></span><br><span class="line"><span class="number">2013</span>-<span class="number">10</span>-<span class="number">11</span></span><br></pre></td></tr></table></figure>

<p>通过解析代表日期或时间的字符串重新创建该日期对象，也可以使用工厂方法parse重新创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date2 = LocalDate.parse(<span class="string">"20141007"</span>, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate date3 = LocalDate.parse(<span class="string">"2014-10-07"</span>, DateTimeFormatter.ISO_LOCAL_DATE);</span><br></pre></td></tr></table></figure>

<p>DateTimeFormatter实例是线程安全的，老的java.util.DateFormat线程不安全。单例模式创建格式器实例，在多个线程间共享实例是没有问题的。也可以通过ofPattern静态工厂方法，按照某个特定的模式创建格式器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"dd/MM/yyyy"</span>);</span><br><span class="line">String formattedDateStr = date.format(formatter);</span><br><span class="line">LocalDate date1 = LocalDate.parse(formattedDateStr, formatter);</span><br></pre></td></tr></table></figure>

<p>ofPattern方法也提供了一个重载的版本，可以传入Locale创建格式器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter italianFormatter = DateTimeFormatter.ofPattern(<span class="string">"d. MMMM yyyy"</span>, Locale.ITALIAN);</span><br><span class="line">LocalDate date = LocalDate.of(<span class="number">2015</span>, <span class="number">11</span>, <span class="number">14</span>);</span><br><span class="line">String formattedDate = date.format(italianFormatter);</span><br><span class="line">LocalDate date1 = LocalDate.parse(formattedDate, italianFormatter);</span><br></pre></td></tr></table></figure>

<p>DateTimeFormatterBuilder类还提供了更复杂的格式器,以提供更加细粒度的控制。同时也提供非常强大的解析功能，比如区分大小写的解析、柔性解析、填充，以及在格式器中指定可选节等等。</p>
<p>通过DateTimeFormatterBuilder自定义格式器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter italianFormatter = <span class="keyword">new</span> DateTimeFormatterBuilder()</span><br><span class="line">                .appendText(ChronoField.DAY_OF_MONTH)</span><br><span class="line">                .appendLiteral(<span class="string">". "</span>)</span><br><span class="line">                .appendText(ChronoField.MONTH_OF_YEAR)</span><br><span class="line">                .appendLiteral(<span class="string">" "</span>)</span><br><span class="line">                .appendText(ChronoField.YEAR)</span><br><span class="line">                .parseCaseInsensitive()</span><br><span class="line">                .toFormatter(Locale.ITALIAN);</span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">String s = now.format(italianFormatter);</span><br></pre></td></tr></table></figure>

<h1 id="8-处理不同的时区和历法"><a href="#8-处理不同的时区和历法" class="headerlink" title="8. 处理不同的时区和历法"></a>8. 处理不同的时区和历法</h1><p>新版日期和时间API新增加的重要功能是时区的处理。新的java.time.ZoneId类替代老版java.util.TimeZone。跟其他日期和时间类一样，ZoneId类也是无法修改的。是按照一定的规则将区域划分成的标准时间相同的区间。在ZoneRules这个类中包含了40个时区实例,可以通过调用ZoneId的getRules()得到指定时区的规则,每个特定的ZoneId对象都由一个地区ID标识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZoneId shanghaiZone = ZoneId.of(<span class="string">"Asia/Shanghai"</span>);</span><br></pre></td></tr></table></figure>

<p>Java 8的新方法toZoneId将一个老的时区对象转换为ZoneId。地区ID都为“{区域}/{城市}”的格式，地区集合的设定都由英特网编号分配机构（IANA）的时区数据库提供。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZoneId zoneId = TimeZone.getDefault().toZoneId();</span><br></pre></td></tr></table></figure>

<p>ZoneId对象可以与LocalDate、LocalDateTime或者是Instant对象整合构造为成ZonedDateTime实例，它代表了相对于指定时区的时间点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">27</span>);</span><br><span class="line">ZonedDateTime zdt1 = date.atStartOfDay(shanghaiZone);</span><br><span class="line"></span><br><span class="line">LocalDateTime dateTime = LocalDateTime.of(<span class="number">2015</span>, <span class="number">12</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">ZonedDateTime zdt2 = dateTime.atZone(shanghaiZone);</span><br><span class="line"></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">ZonedDateTime zdt3 = instant.atZone(shanghaiZone);</span><br><span class="line">通过ZoneId，你还可以将LocalDateTime转换为Instant：</span><br><span class="line"></span><br><span class="line">LocalDateTime dateTime = LocalDateTime.of(<span class="number">2016</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">35</span>);</span><br><span class="line">Instant instantFromDateTime = dateTime.toInstant(shanghaiZone);</span><br><span class="line">你也可以通过反向的方式得到LocalDateTime对象：</span><br><span class="line"></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">LocalDateTime timeFromInstant = LocalDateTime.ofInstant(instant, shanghaiZone);</span><br></pre></td></tr></table></figure>

<p>另一种比较通用的表达时区的方式是利用当前时区和UTC/格林尼治的固定偏差。使用ZoneId的一个子类ZoneOffset，表示的是当前时间和伦敦格林尼治子午线时间的差异：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZoneOffset newYorkOffset = ZoneOffset.of(<span class="string">"-05:00"</span>);</span><br></pre></td></tr></table></figure>

<h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h1><ul>
<li>Java 8之前老版的java.util.Date类以及其他用于建模日期时间的类有很多不一致及设计上的缺陷，包括易变性以及糟糕的偏移值、默认值和命名。</li>
<li>新版的日期和时间API中，日期-时间对象是不可变的。</li>
<li>新的API提供了两种不同的时间表示方式，有效地区分了运行时人和机器的不同需求。</li>
<li>你可以用绝对或者相对的方式操纵日期和时间，操作的结果总是返回一个新的实例，老的日期时间对象不会发生变化。</li>
<li>TemporalAdjuster让你能够用更精细的方式操纵日期，不再局限于一次只能改变它的一个值，并且你还可按照需求定义自己的日期转换器。</li>
<li>你现在可以按照特定的格式需求，定义自己的格式器，打印输出或者解析日期时间对象。这些格式器可以通过模板创建，也可以自己编程创建，并且它们都是线程安全的。</li>
<li>你可以用相对于某个地区/位置的方式，或者以与UTC/格林尼治时间的绝对偏差的方式表示时区，并将其应用到日期时间对象上，对其进行本地化。</li>
</ul>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我的公众号：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-24T03:34:52.000Z" title="2019-03-24T03:34:52.000Z">2019-03-24</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">32 分钟 读完 (大约 4809 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/24/%E3%80%8AJava%208%20in%20Action%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">《Java 8 in Action》Chapter 11：CompletableFuture：组合式异步编程</a></h1><div class="content"><p>某个网站的数据来自Facebook、Twitter和Google，这就需要网站与互联网上的多个Web服务通信。可是，你并不希望因为等待某些服务的响应，阻塞应用程序的运行，浪费数十亿宝贵的CPU时钟周期。比如，不要因为等待Facebook的数据，暂停对来自Twitter的数据处理。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%85%B8%E5%9E%8B%E6%B7%B7%E8%81%9A%E5%BA%94%E7%94%A8.png" alt=""></p>
<p>第7章中介绍的分支/合并框架以及并行流是实现并行处理的宝贵工具;它们将一个操作切分为多个子操作，在多个不同的核、CPU甚至是机器上并行地执行这些子操作。与此相反，如果你的意图是实现并发，而非并行，或者你的主要目标是在同一个CPU上执行几个松耦合的任务，充分利用CPU的核，让其足够忙碌，从而最大化程序的吞吐量，那么你其实真正想做的是避免因为等待远程服务的返回，或者对数据库的查询，而阻塞线程的执行，浪费宝贵的计算资源，因为这种等待的时间很可能相当长。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C.png" alt=""></p>
<h1 id="1-Future接口"><a href="#1-Future接口" class="headerlink" title="1. Future接口"></a>1. Future接口</h1><p>Future接口在Java 5中被引入，设计初衷是对将来某个时刻会发生的结果进行建模。它建模了一种异步计算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。在Future中触发那些潜在耗时的操作把调用线程解放出来，让它能继续执行其他有价值的工作，不再需要等待耗时的操作完成。Future的另一个优点是它比更底层的Thread更易用。要使用Future，通常你只需要将耗时的操作封装在一个Callable对象中，再将它提交给ExecutorService。使用Future以异步的方式执行一个耗时的操作:<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E4%BD%BF%E7%94%A8Future%E4%BB%A5%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E8%80%97%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C.png" alt=""></p>
<p>线程可以在ExecutorService以并发方式调用另一个线程执行耗时操作的同时，去执行一些其他的任务。接着，如果你已经运行到没有异步操作的结果就无法继续任何有意义的工作时，可以调用它的get方法去获取操作的结果。如果操作已经完成，该方法会立刻返回操作的结果，否则它会阻塞你的线程，直到操作完成，返回相应的结果。如果该长时间运行的操作永远不返回了会怎样?Future提供了一个无需任何参数的get方法，推荐使用重载版本的get方法，它接受一个超时的参数，可以定义线程等待Future结果的最长时间，避免无休止的等待。下图是Future异步执行线程原理图。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/Future%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt=""></p>
<h1 id="2-使用CompletableFuture构建异步应用"><a href="#2-使用CompletableFuture构建异步应用" class="headerlink" title="2. 使用CompletableFuture构建异步应用"></a>2. 使用CompletableFuture构建异步应用</h1><p>Future接口有一定的局限性，比如，我们很难表述Future结果之间的依赖性。因此我们引入了CompletableFuture。接下来通过一个“最佳价格查询器“的应用，它会查询多个在线商店，依据给定的产品或服务找出最低的价格，来展现CompletableFuture实现异步应用。通过此例你能学到这些：</p>
<ul>
<li>如何编写异步API</li>
<li>如何让使用同步API的代码变为非阻塞代码</li>
<li>如何使用流水线将两个接续的异步操作合并为一个异步计算操作</li>
<li>如何以响应式的方式处理异步操作的完成事件</li>
</ul>
<p>同步API和异步API：</p>
<ul>
<li>同步API其实只是对传统方法调用的另一种称呼:你调用了某个方法，调用方在被调用方运行的过程中会等待，被调用方运行结束返回，调用方取得被调用方的返回值并继续运行。即使调用方和被调用方在不同的线程中运行，调用方还是需要等待被调用方结束运行，这就是阻塞式调用这个名词的由来。</li>
<li>异步API会直接返回，或者至少在被调用方计算完成之前，将它剩余的计算任务交给另一个线程去做，该线程和调用方是异步的——这就是非阻塞式调用的由来。执行剩余计算任务的线程会将它的计算结果返回给调用方。返回的方式要么是通过回调函数，要么是由调用方再次执行一个“等待，直到计算完成”的方法调用。</li>
</ul>
<h2 id="2-1-实战：实现异步API"><a href="#2-1-实战：实现异步API" class="headerlink" title="2.1 实战：实现异步API"></a>2.1 实战：实现异步API</h2><h3 id="2-1-1-同步方法"><a href="#2-1-1-同步方法" class="headerlink" title="2.1.1 同步方法"></a>2.1.1 同步方法</h3><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95.png" alt=""></p>
<blockquote>
<p>同步操作中会为等待同步事件完成而等待1s，这种是无法接受的，对于程序体验来说是非常不好的。</p>
</blockquote>
<h3 id="2-1-2-将同步方法转换为异步方法"><a href="#2-1-2-将同步方法转换为异步方法" class="headerlink" title="2.1.2 将同步方法转换为异步方法"></a>2.1.2 将同步方法转换为异步方法</h3><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95.png" alt=""></p>
<blockquote>
<p>Java 5引入了java.util.concurrent.Future接口表示一个异步计算(即调用线程可以继续运行，不会因为调用方法而阻塞)的结果。这意味着Future是一个暂时还不可知值的处理器，这个值在计算完成后，可以通过调用它的get方法取得。这种方式下，在进行价格查询的同时，还能执行一些其他的任务，比如查询其他商店中商品的价格，不会阻塞在那里等待第一家商店返回请求的结果。最后，如果所有有意义的工作都已经完成，所有要执行的工作都依赖于商品价格时，再调用Future的get方法。执行了这个操作后，要么获得Future中封装的值(如果异步任务已经完成)，要么发生阻塞，直到该异步任务完成，期望的值能够访问。同时，如果某个商品价格计算发生异常，会将当前线程杀死，从而导致等待get方法返回结果的客户端永久地被阻塞。客户端可以使用重载版本的get方法，设置超时参数来避免。为了让客户端能了解无法提供请求商品价格的原因，你需要使用CompletableFuture的completeExceptionally方法将导致CompletableFuture内发生问题的异常抛出。</p>
</blockquote>
<h2 id="2-1-3-使用工厂方法supplyAsync创建CompletableFuture对象"><a href="#2-1-3-使用工厂方法supplyAsync创建CompletableFuture对象" class="headerlink" title="2.1.3 使用工厂方法supplyAsync创建CompletableFuture对象"></a>2.1.3 使用工厂方法supplyAsync创建CompletableFuture对象</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95(%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95).png" alt=""></p>
<blockquote>
<p>supplyAsync方法接受一个生产者(Supplier)作为参数，返回一个CompletableFuture对象，该对象完成异步执行后会读取调用生产者方法的返回值。生产者方法会交由ForkJoinPool池中的某个执行线程(Executor)运行，但是你也可以使用supplyAsync方法的重载版本，传递第二个参数指定不同的执行线程执行生产者方法。</p>
</blockquote>
<h1 id="3-消除代码阻塞问题"><a href="#3-消除代码阻塞问题" class="headerlink" title="3. 消除代码阻塞问题"></a>3. 消除代码阻塞问题</h1><h2 id="3-1-顺序同步请求"><a href="#3-1-顺序同步请求" class="headerlink" title="3.1 顺序同步请求"></a>3.1 顺序同步请求</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.3/%E9%A1%BA%E5%BA%8F%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82.png" alt=""></p>
<h2 id="3-2-使用并行流对请求进行并行操作"><a href="#3-2-使用并行流对请求进行并行操作" class="headerlink" title="3.2 使用并行流对请求进行并行操作"></a>3.2 使用并行流对请求进行并行操作</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.3/%E4%BD%BF%E7%94%A8%E5%B9%B6%E8%A1%8C%E6%B5%81%E5%AF%B9%E8%AF%B7%E6%B1%82%E8%BF%9B%E8%A1%8C%E5%B9%B6%E8%A1%8C%E6%93%8D%E4%BD%9C.png" alt=""></p>
<h2 id="3-3-使用CompletableFuture发起异步请求"><a href="#3-3-使用CompletableFuture发起异步请求" class="headerlink" title="3.3 使用CompletableFuture发起异步请求"></a>3.3 使用CompletableFuture发起异步请求</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.3/%E4%BD%BF%E7%94%A8CompletableFuture%E5%8F%91%E8%B5%B7%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.png" alt=""></p>
<p>CompletableFuture版本的程序似乎比并行流版本的程序还快那么一点儿。但是最后这个版本也不太令人满意。它们看起来不相伯仲，究其原因都一样:它们内部采用的是同样的通用线程池，默认都使用固定数目的线程，具体线程数取决于Runtime.getRuntime().availableProcessors()的返回值。然而，CompletableFuture具有一定的优势，因为它允许你对执行器(Executor)进行配置，尤其是线程池的大小，让它以更适合应用需求的方式进行配置，满足程序的要求，而这是并行流API无法提供的。<br>顺序执行和并行执行的原理对比：<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.3/%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8E%9F%E7%90%86%E5%AF%B9%E6%AF%94.png" alt=""></p>
<p>图11-4的上半部分展示了使用单一流水线处理流的过程，我们看到，执行的流程(以虚线标识)是顺序的。事实上，新的CompletableFuture对象只有在前一个操作完全结束之后，才能创建。与此相反，图的下半部分展示了如何先将CompletableFutures对象聚集到一个列表中(即图中以椭圆表示的部分)，让对象们可以在等待其他对象完成操作之前就能启动。</p>
<h2 id="3-4-使用CompletableFuture发起异步请求WithExecutor"><a href="#3-4-使用CompletableFuture发起异步请求WithExecutor" class="headerlink" title="3.4 使用CompletableFuture发起异步请求WithExecutor"></a>3.4 使用CompletableFuture发起异步请求WithExecutor</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.3/%E4%BD%BF%E7%94%A8CompletableFuture%E5%8F%91%E8%B5%B7%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82WithExecutor.png" alt=""></p>
<h2 id="3-5-调用结果"><a href="#3-5-调用结果" class="headerlink" title="3.5 调用结果:"></a>3.5 调用结果:</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.3/%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%9C.png" alt=""></p>
<h2 id="3-6-并行——使用流还是CompletableFutures"><a href="#3-6-并行——使用流还是CompletableFutures" class="headerlink" title="3.6 并行——使用流还是CompletableFutures"></a>3.6 并行——使用流还是CompletableFutures</h2><p>目前为止，你已经知道对集合进行并行计算有两种方式:要么将其转化为并行流，利用map这样的操作开展工作，要么枚举出集合中的每一个元素，创建新的线程，在CompletableFuture内对其进行操作。后者提供了更多的灵活性，你可以调整线程池的大小，而这能帮助你确保整体的计算不会因为线程都在等待I/O而发生阻塞。</p>
<ul>
<li>如果你进行的是计算密集型的操作，并且没有I/O，那么推荐使用Stream接口，因为实现简单，同时效率也可能是最高的(如果所有的线程都是计算密集型的，那就没有必要创建比处理器核数更多的线程)。 </li>
<li>如果你并行的工作单元还涉及等待I/O的操作(包括网络连接等待)，那么使用CompletableFuture灵活性更好，你可以像前文讨论的那样，依据等待/计算，或者 W/C的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是，处理流的流水线中如果发生I/O等待，流的延迟性会让我们很难判断到底什么时候触发了等待。</li>
</ul>
<h1 id="4-对多个异步任务进行流水线操作"><a href="#4-对多个异步任务进行流水线操作" class="headerlink" title="4. 对多个异步任务进行流水线操作"></a>4. 对多个异步任务进行流水线操作</h1><h2 id="4-1-案例"><a href="#4-1-案例" class="headerlink" title="4.1 案例"></a>4.1 案例</h2><p>通过在shop构成的流上采用流水线方式执行三次map操作，我们得到了结果。</p>
<ul>
<li>第一个操作将每个shop对象转换成了一个字符串，该字符串包含了该 shop中指定商品的价格和折扣代码。</li>
<li>第二个操作对这些字符串进行了解析，在Quote对象中对它们进行转换。</li>
<li>第三个map会操作联系远程的Discount服务，计算出最终的折扣价格，并返回该价格及提供该价格商品的shop。</li>
</ul>
<p>代码如图:<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.4/Discount.png" alt=""><br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.4/Quote.png" alt=""><br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.4/Shop11_4.png" alt=""><br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.4/Test.png" alt=""></p>
<p>原理图：<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.4/Discount%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt=""></p>
<p>Java 8的CompletableFuture API提供了名为thenCompose的方法，它就是专门为这一目的而设计的，thenCompose方法允许你对两个异步操作进行流水线，第一个操作完成时，将其结果作为参数传递给第二个操作。换句话说，你可以创建两个CompletableFutures对象，对第一个CompletableFuture对象调用thenCompose，并向其传递一个函数。当第一个 CompletableFuture执行完毕后，它的结果将作为该函数的参数，这个函数的返回值是以第一 个CompletableFuture的返回做输入计算出的第二个CompletableFuture对象。thenCompose方法像CompletableFuture类中的其他方法一样，也提供了一个以Async后缀结尾的版本thenComposeAsync。通常而言，名称中不带Async的方法和它的前一个任务一样，在同一个线程中运行;而名称以Async结尾的方法会将后续的任务提交到一个线程池，所以每个任务是由不同的线程处理的。</p>
<h2 id="4-2-thenCombine方法"><a href="#4-2-thenCombine方法" class="headerlink" title="4.2 thenCombine方法"></a>4.2 thenCombine方法</h2><p>将两个CompletableFuture对象结合起来，无论他们是否存在依赖。thenCombine方法，它接收名为BiFunction的第二参数，这个参数 定义了当两个CompletableFuture对象完成计算后，结果如何合并。同thenCompose方法一样， thenCombine方法也提供有一个Async的版本。这里，如果使用thenCombineAsync会导致BiFunction中定义的合并操作被提交到线程池中，由另一个任务以异步的方式执行。</p>
<p>代码图：<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.5/thenCombine.png" alt=""></p>
<p>原理图：<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.5/thenCombine%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt=""></p>
<h2 id="4-3-响应CompletableFuture的completion事件"><a href="#4-3-响应CompletableFuture的completion事件" class="headerlink" title="4.3 响应CompletableFuture的completion事件"></a>4.3 响应CompletableFuture的completion事件</h2><p>Java 8的CompletableFuture通过thenAccept方法提供了这一功能，它接收 CompletableFuture执行完毕后的返回值做参数。thenAccept方法也提供 了一个异步版本，名为thenAcceptAsync。异步版本的方法会对处理结果的消费者进行调度， 从线程池中选择一个新的线程继续执行，不再由同一个线程完成CompletableFuture的所有任 务。因为你想要避免不必要的上下文切换，更重要的是你希望避免在等待线程上浪费时间，尽快响应CompletableFuture的completion事件，所以这里没有采用异步版本。</p>
<h2 id="4-3-1-实战"><a href="#4-3-1-实战" class="headerlink" title="4.3.1 实战"></a>4.3.1 实战</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/11.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2011%EF%BC%9ACompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/11.5/thenAccept%E5%AE%9E%E6%88%98.png" alt=""></p>
<h1 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h1><ul>
<li>执行比较操作时,尤其是那些依赖一个或多个远程服务的操作，使用异步任务可以改善程序的性能，加快程序的响应速度。</li>
<li>你应该尽可能地为客户提供异步API。使用CompletableFuture类提供的特性，你能够轻松地实现这一目标。</li>
<li>CompletableFuture类还提供了异常管理的机制，让你有机会抛出/管理异步任务执行中发生的异常。</li>
<li>将同步API的调用封装到一个CompletableFuture中，你能够以异步的方式使用其结果。</li>
<li>如果异步任务之间相互独立，或者它们之间某一些的结果是另一些的输入，你可以将这些异步任务构造或者合并成一个。</li>
<li>你可以为CompletableFuture注册一个回调函数，在Future执行完毕或者它们计算的结果可用时，针对性地执行一些程序。</li>
<li>你可以决定在什么时候结束程序的运行，是等待由CompletableFuture对象构成的列表中所有的对象都执行完毕，还是只要其中任何一个首先完成就中止程序的运行。</li>
</ul>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我的公众号：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-22T03:34:52.000Z" title="2019-03-22T03:34:52.000Z">2019-03-22</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">18 分钟 读完 (大约 2641 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/22/%E3%80%8AJava%208%20in%20Action%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2010%EF%BC%9A%E7%94%A8Optional%E5%8F%96%E4%BB%A3null/">《Java 8 in Action》Chapter 10：用Optional取代null</a></h1><div class="content"><blockquote>
<p>1965年，英国一位名为Tony Hoare的计算机科学家在设计ALGOL W语言时提出了null引用的想法。ALGOL W是第一批在堆上分配记录的类型语言之一。Hoare选择null引用这种方式，“只是因为这种方法实现起来非常容易”。虽然他的设计初衷就是要“通过编译器的自动检测机制，确保所有使用引用的地方都是绝对安全的”，他还是决定为null引用开个绿灯，因为他认为这是为“不存在的值”建模最容易的方式。很多年后，他开始为自己曾经做过这样的决定而后悔不已，把它称为“我价值百万的重大事物”。实际上，Hoare的这段话低估了过去五十年来数百万程序员为修复空引用所耗费的代价。近十年出现的大多数现代程序设计语言1，包括Java，都采用了同样的设计方式，其原因是为了与更老的语言保持兼容，或者就像Hoare曾经陈述的那样，“仅仅是因为这样实现起来更加容易”。</p>
</blockquote>
<h1 id="1-如何为确实的值建模"><a href="#1-如何为确实的值建模" class="headerlink" title="1. 如何为确实的值建模"></a>1. 如何为确实的值建模</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Car car;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> car; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Insurance insurance;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Insurance <span class="title">getInsurance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> insurance; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insurance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCarInsuranceName</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> person.getCar().getInsurance().getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码的问题就在于，如果person没有车，就会造成空指针异常。</p>
<h2 id="1-1-采用防御式检查减少NullPointerException"><a href="#1-1-采用防御式检查减少NullPointerException" class="headerlink" title="1.1 采用防御式检查减少NullPointerException"></a>1.1 采用防御式检查减少NullPointerException</h2><h3 id="1-1-1-深层质疑"><a href="#1-1-1-深层质疑" class="headerlink" title="1.1.1 深层质疑"></a>1.1.1 深层质疑</h3><p>简单来说就是在需要的地方添加null检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCarInsuranceName</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (person != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Car car = person.getCar();</span><br><span class="line">        <span class="keyword">if</span> (car != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Insurance insurance = car.getInsurance();</span><br><span class="line">            <span class="keyword">if</span> (insurance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> insurance.getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Unknown"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码不具备扩展性，同时还牺牲了代码的可读性。</p>
<h3 id="1-1-2-过多的退出语句"><a href="#1-1-2-过多的退出语句" class="headerlink" title="1.1.2 过多的退出语句"></a>1.1.2 过多的退出语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCarInsuranceName</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (person == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Unknown"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Car car = person.getCar();</span><br><span class="line">    <span class="keyword">if</span> (car == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Unknown"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Insurance insurance = car.getInsurance();</span><br><span class="line">    <span class="keyword">if</span> (insurance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Unknown"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> insurance.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模式中方法的退出点有四处，使得代码的维护异常艰难。</p>
<h2 id="1-2-null带来的种种问题"><a href="#1-2-null带来的种种问题" class="headerlink" title="1.2 null带来的种种问题"></a>1.2 null带来的种种问题</h2><ul>
<li>它是错误之源。 NullPointerException是目前Java程序开发中最典型的异常。它会使你的代码膨胀。</li>
<li>它让你的代码充斥着深度嵌套的null检查，代码的可读性糟糕透顶。</li>
<li>它自身是毫无意义的。 null自身没有任何的语义，尤其是是它代表的是在静态类型语言中以一种错误的方式对缺失变量值的建模。</li>
<li>它破坏了Java的哲学。 Java一直试图避免让程序员意识到指针的存在，唯一的例外是:null指针。</li>
<li>它在Java的类型系统上开了个口子。 null并不属于任何类型，这意味着它可以被赋值给任意引用类型的变量。这会导致问题， 原因是当这个变量被传递到系统中的另一个部分后，你将无法获知这个null变量最初赋值到底是什么类型。</li>
</ul>
<h2 id="1-3-其他语言中null的替代品"><a href="#1-3-其他语言中null的替代品" class="headerlink" title="1.3 其他语言中null的替代品"></a>1.3 其他语言中null的替代品</h2><ul>
<li>Groovy中的安全导航操作符</li>
<li>Haskell中的Maybe类型</li>
<li>Scala中的Option[T]</li>
</ul>
<h1 id="2-Optional类入门"><a href="#2-Optional类入门" class="headerlink" title="2. Optional类入门"></a>2. Optional类入门</h1><p>变量存在时，Optional类只是对类简单封装。变量不存在时，缺失的值会被建模成一个“空”的Optional对象，由方法Optional.empty()返回。Optional.empty()方法是一个静态工厂方法，它返回Optional类的特定单一实例。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/10.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2010%EF%BC%9A%E7%94%A8Optional%E5%8F%96%E4%BB%A3null/1.png" alt=""></p>
<p>引入Optional类的意图并非要消除每一个null引用，相反的是，它的目标是帮助开发者更好地设计出普适的API。</p>
<h1 id="3-应用Optional的几种模式"><a href="#3-应用Optional的几种模式" class="headerlink" title="3. 应用Optional的几种模式"></a>3. 应用Optional的几种模式</h1><h2 id="3-1-创建Optional对象"><a href="#3-1-创建Optional对象" class="headerlink" title="3.1 创建Optional对象"></a>3.1 创建Optional对象</h2><h3 id="3-1-1-声明一个空的Optional"><a href="#3-1-1-声明一个空的Optional" class="headerlink" title="3.1.1 声明一个空的Optional"></a>3.1.1 声明一个空的Optional</h3><p>正如前文已经提到，你可以通过静态工厂方法Optional.empty，创建一个空的Optional对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Car&gt; optCar = Optional.empty();</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-依据一个非空值创建Optional"><a href="#3-1-2-依据一个非空值创建Optional" class="headerlink" title="3.1.2 依据一个非空值创建Optional"></a>3.1.2 依据一个非空值创建Optional</h3><p>你还可以使用静态工厂方法Optional.of，依据一个非空值创建一个Optional对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Car&gt; optCar = Optional.of(car);</span><br></pre></td></tr></table></figure>
<p>如果car是一个null，这段代码会立即抛出一个NullPointerException，而不是等到你试图访问car的属性值时才返回一个错误。</p>
<h3 id="3-2-3-可接受null的Optional"><a href="#3-2-3-可接受null的Optional" class="headerlink" title="3.2.3 可接受null的Optional"></a>3.2.3 可接受null的Optional</h3><p>最后，使用静态工厂方法Optional.ofNullable，你可以创建一个允许null值的Optional对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Car&gt; optCar = Optional.ofNullable(car);</span><br></pre></td></tr></table></figure>
<p>如果car是null，那么得到的Optional对象就是个空对象。</p>
<h2 id="3-2-使用map从Optional对象中提取和转换值"><a href="#3-2-使用map从Optional对象中提取和转换值" class="headerlink" title="3.2 使用map从Optional对象中提取和转换值"></a>3.2 使用map从Optional对象中提取和转换值</h2><p>从对象中提取信息是一种比较常见的模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(insurance != <span class="keyword">null</span>)&#123;</span><br><span class="line">        name = insurance.getName();</span><br><span class="line">    &#125;</span><br><span class="line">为了支持这种模式，Optional提供了一个map方法。</span><br><span class="line">Optional&lt;Insurance&gt; optInsurance = Optional.ofNullable(insurance); </span><br><span class="line">Optional&lt;String&gt; name = optInsurance.map(Insurance::getName);</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/10.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2010%EF%BC%9A%E7%94%A8Optional%E5%8F%96%E4%BB%A3null/2.png" alt=""></p>
<h2 id="3-3-使用flatMap链接Optional对象"><a href="#3-3-使用flatMap链接Optional对象" class="headerlink" title="3.3 使用flatMap链接Optional对象"></a>3.3 使用flatMap链接Optional对象</h2><p>使用流时，flatMap方法接受一个函数作为参数，这个函数的返回值是另一个流。 这个方法会应用到流中的每一个元素，最终形成一个新的流的流。但是flagMap会用流的内容替换每个新生成的流。换句话说，由方法生成的各个流会被合并或者扁平化为一个单一的流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCarInsuranceName</span><span class="params">(Optional&lt;Person&gt; person)</span> </span>&#123; <span class="keyword">return</span> person.flatMap(Person::getCar)</span><br><span class="line">                     .flatMap(Car::getInsurance)</span><br><span class="line">                     .map(Insurance::getName)</span><br><span class="line">                     .orElse(<span class="string">"Unknown"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/10.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2010%EF%BC%9A%E7%94%A8Optional%E5%8F%96%E4%BB%A3null/3.png" alt=""></p>
<h2 id="3-4-默认行为及解引用Optional对象"><a href="#3-4-默认行为及解引用Optional对象" class="headerlink" title="3.4 默认行为及解引用Optional对象"></a>3.4 默认行为及解引用Optional对象</h2><ol>
<li>get()是这些方法中最简单但又最不安全的方法。如果变量存在，它直接返回封装的变量值，否则就抛出一个NoSuchElementException异常。所以，除非你非常确定Optional变量一定包含值，否则使用这个方法是个相当糟糕的主意。此外，这种方式即便相对于嵌套式的null检查，也并未体现出多大的改进。</li>
<li>orElse(T other)是我们在代码清单10-5中使用的方法，正如之前提到的，它允许你在 Optional对象不包含值时提供一个默认值。</li>
<li>orElseGet(Supplier&lt;? extends T&gt; other)是orElse方法的延迟调用版，Supplier 方法只有在Optional对象不含值时才执行调用。如果创建默认值是件耗时费力的工作，你应该考虑采用这种方式(借此提升程序的性能)，或者你需要非常确定某个方法仅在 Optional为空时才进行调用，也可以考虑该方式(这种情况有严格的限制条件)。</li>
<li>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)和get方法非常类似，它们遭遇Optional对象为空时都会抛出一个异常，但是使用orElseThrow你可以定制􏳵希望抛出的异常类型。</li>
<li>ifPresent(Consumer&lt;? super T&gt;)让你能在变量值存在时执行一个作为参数传入的方法，否则就不进行任何操作。</li>
</ol>
<h2 id="3-5-两个Optional对象的组合"><a href="#3-5-两个Optional对象的组合" class="headerlink" title="3.5 两个Optional对象的组合"></a>3.5 两个Optional对象的组合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Insurance&gt; <span class="title">nullSafeFindCheapestInsurance</span><span class="params">(Optional&lt;Person&gt; person, Optional&lt;Car&gt; car)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (person.isPresent() &amp;&amp; car.isPresent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.of(findCheapestInsurance(person.get(), car.get())); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-使用filter剔除特定的值"><a href="#3-6-使用filter剔除特定的值" class="headerlink" title="3.6 使用filter剔除特定的值"></a>3.6 使用filter剔除特定的值</h2><p>filter方法接受一个谓词作为参数。如果Optional对象的值存在，并且它符合谓词的条件， filter方法就返回其值;否则它就返回一个空的Optional对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Insurance insurance = ...;</span><br><span class="line"><span class="keyword">if</span>(insurance != <span class="keyword">null</span> &amp;&amp; <span class="string">"CambridgeInsurance"</span>.equals(insurance.getName()))&#123;</span><br><span class="line">       System.out.println(<span class="string">"ok”);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">Optional&lt;Insurance&gt; optInsurance = ...;</span></span><br><span class="line"><span class="string">optInsurance.filter(insurance -&gt;</span></span><br><span class="line"><span class="string">                        "</span>CambridgeInsurance<span class="string">".equals(insurance.getName()))</span></span><br><span class="line"><span class="string">            .ifPresent(x -&gt; System.out.println("</span>ok<span class="string">"));</span></span><br></pre></td></tr></table></figure>

<p>Optional类中的方法进行了分类和概括:<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/10.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2010%EF%BC%9A%E7%94%A8Optional%E5%8F%96%E4%BB%A3null/4.png" alt=""><br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/10.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%2010%EF%BC%9A%E7%94%A8Optional%E5%8F%96%E4%BB%A3null/5.png" alt=""></p>
<h1 id="4-使用Optional的实战示例"><a href="#4-使用Optional的实战示例" class="headerlink" title="4. 使用Optional的实战示例"></a>4. 使用Optional的实战示例</h1><h2 id="4-1-用Optional封装可能为null的值"><a href="#4-1-用Optional封装可能为null的值" class="headerlink" title="4.1 用Optional封装可能为null的值"></a>4.1 用Optional封装可能为null的值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Object&gt; value = Optional.ofNullable(map.get(<span class="string">"key"</span>));</span><br></pre></td></tr></table></figure>
<p>每次你希望安全地对潜在为null的对象进行转换，将其替换为Optional对象时，都可以考虑使用这种方法。</p>
<h2 id="4-2-异常与Optional的对比"><a href="#4-2-异常与Optional的对比" class="headerlink" title="4.2 异常与Optional的对比"></a>4.2 异常与Optional的对比</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;Integer&gt; <span class="title">stringToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Optional.of(Integer.parseInt(s));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的建议是，你可以将多个类似的方法封装到一个工具类中，让我们称之为OptionalUtility。通过这种方式，你以后就能直接调用OptionalUtility.stringToInt方法，将String转换为一个Optional<Integer>对象，而不再需要记得你在其中封装了笨拙的 try/catch的逻辑了。</p>
<h2 id="4-3-把所有内容结合起来"><a href="#4-3-把所有内容结合起来" class="headerlink" title="4.3 把所有内容结合起来"></a>4.3 把所有内容结合起来</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readDuration</span><span class="params">(Properties props, String name)</span> </span>&#123;</span><br><span class="line">    String value = props.getProperty(name);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = Integer.parseInt(value);</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化版本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readDuration</span><span class="params">(Properties props, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(props.getProperty(name))</span><br><span class="line">                        .flatMap(OptionalUtility::stringToInt)</span><br><span class="line">                        .filter(i -&gt; i &gt; <span class="number">0</span>)</span><br><span class="line">                        .orElse(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h1><p>这一章中，你学到了以下的内容。</p>
<ol>
<li>null引用在上被引入到程序设计语言中，目的是为了表示变量值的。</li>
<li>Java 8中引入了一个新的类java.util.Optional<T>，对存在或缺失的变量值进行建模。</li>
<li>你可以使用静态工厂方法Optional.empty、Optional.of以及Optional.ofNullable创建Optional对象。</li>
<li>Optional类支持多种方法，比如map、flatMap、filter，它们在概念上与Stream类中对应的方法十分相似。</li>
<li>使用Optional会使你更积极地解引用Optional对象，以应对变量值缺失的问题，最终，你能更有效地止代码中出现不而至的空指针异常。</li>
<li>使用Optional能帮助你设计更好的API，用户只需要阅读方法签名，就能了解该方法是否接受一个Optional类型的值。</li>
</ol>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我的公众号：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-19T03:34:52.000Z" title="2019-03-19T03:34:52.000Z">2019-03-19</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">28 分钟 读完 (大约 4159 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/19/%E3%80%8AJava%208%20in%20Action%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%209%EF%BC%9A%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/">《Java 8 in Action》Chapter 9：默认方法</a></h1><div class="content"><blockquote>
<p>传统上，Java程序的接口是将相关方法按照约定组合到一起的方式。实现接口的类必须为接口中定义的每个方法提供一个实现，或者从父类中继承它的实现。<br>但是，一旦类库的设计者需要更新接口，向其中加入新的方法，这种方式就会出现问题。现实情况是，现存的实体类往往不在接口设计者的控制范围之内，这些实体类为了适配新的接口约定也需要进行修改。<br>由于Java 8的API在现存的接口上引入了非常多的新方法，这种变化带来的问题也愈加严重，一个例子就是前几章中使用过的 List 接口上的 sort 方法。<br>想象一下其他备选集合框架的维护人员会多么抓狂吧，像Guava和Apache Commons这样的框架现在都需要修改实现了 List 接口的所有类，为其添加sort 方法的实现。<br>Java 8为了解决这一问题引入了一种新的机制。Java 8中的接口现在支持在声明方法的同时提供实现，通过两种方式可以完成这种操作。其一，Java 8允许在接口内声明静态方法。<br>其二，Java 8引入了一个新功能，叫默认方法，通过默认方法你可以指定接口方法的默认实现。换句话说，接口能提供方法的具体实现。因此，实现接口的类如果不显式地提供该方法的具体实现，<br>就会自动继承默认的实现。这种机制可以使你平滑地进行接口的优化和演进。实际上，到目前为止你已经使用了多个默认方法。两个例子就是你前面已经见过的 List 接口中的 sort ，以及 Collection 接口中的 stream 。</p>
</blockquote>
<p>第1章中 List 接口中的 sort 方法是Java 8中全新的方法，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span></span>&#123;</span><br><span class="line">    Collections.sort(<span class="keyword">this</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意返回类型之前的新 default 修饰符。通过它，我们能够知道一个方法是否为默认方法。这里 sort 方法调用了 Collections.sort 方法进行排序操作。由于有了这个新的方法，我们现在可以直接通过调用 sort ，对列表中的元素进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">numbers.sort(Comparator.naturalOrder());</span><br></pre></td></tr></table></figure>
<p>不过除此之外，这段代码中还有些其他的新东西。我们调用了Comparator.naturalOrder 方法。这是 Comparator 接口的一个全新的静态方法，它返回一个Comparator 对象，并按自然序列对其中的元素进行排序（即标准的字母数字方式排序）。<br>第4章中的 Collection 中的 stream 方法的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在之前的几章中大量使用了该方法来处理集合，这里 stream 方法中调用了SteamSupport.stream 方法来返回一个流。你注意到 stream 方法的主体是如何调用 spliterator 方法的了吗？它也是 Collection 接口的一个默认方法。<br>接口和抽象类还是有一些本质的区别，我们在这一章中会针对性地进行讨论。<br>简而言之，向接口添加方法是诸多问题的罪恶之源；一旦接口发生变化，实现这些接口的类往往也需要更新，提供新添方法的实现才能适配接口的变化。如果你对接口以及它所有相关的实现有完全的控制，这可能不是个大问题。但是这种情况是极少的。这就是引入默认方法的目的：它让类可以自动地继承接口的一个默认实现。</p>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/09.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%209%EF%BC%9A%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/1.png" alt=""></p>
<h1 id="1-不断演进的-API"><a href="#1-不断演进的-API" class="headerlink" title="1. 不断演进的 API"></a>1. 不断演进的 API</h1><h2 id="1-1-初始版本的-API"><a href="#1-1-初始版本的-API" class="headerlink" title="1.1 初始版本的 API"></a>1.1 初始版本的 API</h2><p>Resizable 接口的最初版本提供了下面这些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resizable</span> <span class="keyword">extends</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> height)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAbsoluteSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">用户根据自身的需求实现了 Resizable 接口，创建了 Ellipse 类：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span> <span class="keyword">implements</span> <span class="title">Resizable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">他实现了一个处理各种 Resizable 形状（包括 Ellipse ）的游戏：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Resizable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">implements</span> <span class="title">Resizable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Resizable&gt; resizableShapes =</span><br><span class="line">                Arrays.asList(<span class="keyword">new</span> Square(), <span class="keyword">new</span> Triangle(), <span class="keyword">new</span> Ellipse());</span><br><span class="line">        Utils.paint(resizableShapes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(List&lt;Resizable&gt; list)</span> </span>&#123;</span><br><span class="line">        list.forEach(r -&gt; &#123;</span><br><span class="line">            r.setAbsoluteSize(<span class="number">42</span>, <span class="number">42</span>);</span><br><span class="line">            r.draw();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-第二版-API"><a href="#1-2-第二版-API" class="headerlink" title="1.2 第二版 API"></a>1.2 第二版 API</h2><p>库上线使用几个月之后，你收到很多请求，要求你更新 Resizable 的实现，让 Square Triangle 以及其他的形状都能支持 setRelativeSize 方法。为了满足这些新的需求，你发布了第二版API。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resizable</span> <span class="keyword">extends</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> height)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAbsoluteSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRelativeSize</span><span class="params">(<span class="keyword">int</span> wFactor, <span class="keyword">int</span> hFactor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 Resizable 接口的更新导致了一系列的问题。首先，接口现在要求它所有的实现类添加setRelativeSize 方法的实现。但是用户最初实现的 Ellipse 类并未包含 setRelativeSize方法。向接口添加新方法是二进制兼容的，这意味着如果不重新编译该类，即使不实现新的方法，现有类的实现依旧可以运行。不过，用户可能修改他的游戏，在他的 Utils.paint 方法中调用setRelativeSize 方法，因为 paint 方法接受一个 Resizable 对象列表作为参数。如果传递的是一个 Ellipse 对象，程序就会抛出一个运行时错误，因为它并未实现 setRelativeSize 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.AbstractMethodError:lambdasinaction.chap9.Ellipse.setRelativeSize(II)V</span><br></pre></td></tr></table></figure>
<p>其次，如果用户试图重新编译整个应用（包括 Ellipse 类），他会遭遇下面的编译错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error:(<span class="number">9</span>, <span class="number">8</span>) java: com.lujiahao.learnjava8.chapter9.Ellipse不是抽象的, 并且未覆盖</span><br><span class="line">com.lujiahao.learnjava8.chapter9.Resizable中的抽象方法setRelativeSize(<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>这就是默认方法试图解决的问题。它让类库的设计者放心地改进应用程序接口，无需担忧对遗留代码的影响，这是因为实现更新接口的类现在会自动继承一个默认的方法实现。</p>
<p>变更对Java程序的影响大体可以分成三种类型的兼容性，分别是:</p>
<ul>
<li>二进制级的兼容</li>
<li>源代码级的兼容</li>
<li>函数行为的兼容</li>
</ul>
<h1 id="2-概述默认方法"><a href="#2-概述默认方法" class="headerlink" title="2. 概述默认方法"></a>2. 概述默认方法</h1><p>默认方法由 default 修饰符修饰，并像类中声明的其他方法一样包含方法体。比如，你可以像下面这样在集合库中定义一个名为Sized 的接口，在其中定义一个抽象方法 size ，以及一个默认方法 isEmpty ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sized</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样任何一个实现了 Sized 接口的类都会自动继承 isEmpty 的实现。因此，向提供了默认实现的接口添加方法就不是源码兼容的。<br>默认方法在Java 8的API中已经大量地使用了。本章已经介绍过我们前一章中大量使用的 Collection 接口的 stream 方法就是默认方法。 List 接口的 sort 方法也是默认方法。第3章介绍的很多函数式接口，比如 Predicate 、 Function 以及 Comparator 也引入了新的默认方法，比如 Predicate.and 或者 Function.andThen （记住，函数式接口只包含一个抽象方法，默认方法是种非抽象方法）。</p>
<h1 id="3-默认方法的使用模式"><a href="#3-默认方法的使用模式" class="headerlink" title="3. 默认方法的使用模式"></a>3. 默认方法的使用模式</h1><h2 id="3-1-可选方法"><a href="#3-1-可选方法" class="headerlink" title="3.1 可选方法"></a>3.1 可选方法</h2><p>类实现了接口，不过却刻意地将一些方法的实现留白。我们以Iterator 接口为例来说。 Iterator 接口定义了 hasNext 、 next ，还定义了 remove 方法。Java 8之前，由于用户通常不会使用该方法， remove 方法常被忽略。因此，实现 Interator 接口的类通常会为 remove 方法放置一个空的实现，这些都是些毫无用处的模板代码。采用默认方法之后，你可以为这种类型的方法提供一个默认的实现，这样实体类就无需在自己的实现中显式地提供一个空方法。比如，在Java 8中， Iterator 接口就为 remove 方法提供了一个默认实现，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-行为的多继承"><a href="#3-2-行为的多继承" class="headerlink" title="3.2 行为的多继承"></a>3.2 行为的多继承</h2><p>默认方法让之前无法想象的事儿以一种优雅的方式得以实现，即行为的多继承。这是一种让类从多个来源重用代码的能力。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/09.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%209%EF%BC%9A%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/2.png" alt=""></p>
<p>Java的类只能继承单一的类，但是一个类可以实现多接口。要确认也很简单，下面是Java API中对 ArrayList 类的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-1-类型的多继承"><a href="#3-2-1-类型的多继承" class="headerlink" title="3.2.1 类型的多继承"></a>3.2.1 类型的多继承</h3><p>这个例子中 ArrayList 继承了一个类，实现了六个接口。因此 ArrayList 实际是七个类型的直接子类，分别是： AbstractList 、 List 、 RandomAccess 、 Cloneable 、 Serializable 、Iterable 和 Collection 。所以，在某种程度上，我们早就有了类型的多继承。<br>由于Java 8中接口方法可以包含实现，类可以从多个接口中继承它们的行为（即实现的代码）。让我们从一个例子入手，看看如何充分利用这种能力来为我们服务。保持接口的精致性和正交性能帮助你在现有的代码基上最大程度地实现代码复用和行为组合。</p>
<h3 id="3-2-2-利用正交方法的精简接口"><a href="#3-2-2-利用正交方法的精简接口" class="headerlink" title="3.2.2 利用正交方法的精简接口"></a>3.2.2 利用正交方法的精简接口</h3><p>假设你需要为你正在创建的游戏定义多个具有不同特质的形状。有的形状需要调整大小，但是不需要有旋转的功能；有的需要能旋转和移动，但是不需要调整大小。这种情况下，你怎么设计才能尽可能地重用代码？<br>你可以定义一个单独的 Rotatable 接口，并提供两个抽象方法 setRotationAngle 和getRotationAngle ，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rotatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRotationAngle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationAngle</span><span class="params">(<span class="keyword">int</span> angleInDegrees)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">rotateBy</span><span class="params">(<span class="keyword">int</span> angleInDegrees)</span> </span>&#123;</span><br><span class="line">        setRotationAngle((getRotationAngle() + angleInDegrees) % <span class="number">360</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式和模板设计模式有些相似，都是以其他方法需要实现的方法定义好框架算法。<br>现在，实现了 Rotatable 的所有类都需要提供 setRotationAngle 和 getRotationAngle的实现，但与此同时它们也会天然地继承 rotateBy 的默认实现。<br>类似地，你可以定义之前看到的两个接口 Moveable 和 Resizable 。它们都包含了默认实现。下面是 Moveable 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">moveHorizontally</span><span class="params">(<span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        setX(getX() + distance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">moveVertically</span><span class="params">(<span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        setY(getY() + distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">下面是 Resizable 的代码：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resizable</span> <span class="keyword">extends</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> height)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAbsoluteSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setRelativeSize</span><span class="params">(<span class="keyword">int</span> wFactor, <span class="keyword">int</span> hFactor)</span></span>&#123;</span><br><span class="line">        setAbsoluteSize(getWidth() / wFactor, getHeight() / hFactor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-组合接口"><a href="#3-2-3-组合接口" class="headerlink" title="3.2.3 组合接口"></a>3.2.3 组合接口</h3><p>通过组合这些接口，你现在可以为你的游戏创建不同的实体类。比如， Monster 可以移动、旋转和缩放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monster</span> <span class="keyword">implements</span> <span class="title">Rotatable</span>, <span class="title">Moveable</span>, <span class="title">Resizable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Monster 类会自动继承 Rotatable 、 Moveable 和 Resizable 接口的默认方法。这个例子中，Monster 继承了 rotateBy 、 moveHorizontally 、 moveVertically 和 setRelativeSize 的实现。<br>你现在可以直接调用不同的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Monster m = <span class="keyword">new</span> Monster();</span><br><span class="line">m.rotateBy(<span class="number">180</span>);</span><br><span class="line">m.moveVertically(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>像你的游戏代码那样使用默认实现来定义简单的接口还有另一个好处。假设你需要修改moveVertically 的实现，让它更高效地运行。你可以在 Moveable 接口内直接修改它的实现，所有实现该接口的类会自动继承新的代码（这里我们假设用户并未定义自己的方法实现）。<br>通过前面的介绍，你已经了解了默认方法多种强大的使用模式。不过也可能还有一些疑惑：如果一个类同时实现了两个接口，这两个接口恰巧又提供了同样的默认方法签名，这时会发生什么情况？类会选择使用哪一个方法？这些问题，我们会在接下来的一节进行讨论。</p>
<h1 id="4-解决冲突的规则"><a href="#4-解决冲突的规则" class="headerlink" title="4. 解决冲突的规则"></a>4. 解决冲突的规则</h1><p>随着默认方法在Java 8中引入，有可能出现一个类继承了多个方法而它们使用的却是同样的函数签名。这种情况下，类会选择使用哪一个函数？接下来的例子主要用于说明容易出问题的场景，并不表示这些场景在实际开发过程中会经常发生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello from A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello from B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 猜猜打印的是什么？</span></span><br><span class="line">        <span class="keyword">new</span> C().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，你可能早就对C++语言中著名的菱形继承问题有所了解，菱形继承问题中一个类同时继承了具有相同函数签名的两个方法。到底该选择哪一个实现呢？ Java 8也提供了解决这个问题的方案。请接着阅读下面的内容。</p>
<h2 id="4-1-解决问题的三条规则"><a href="#4-1-解决问题的三条规则" class="headerlink" title="4.1 解决问题的三条规则"></a>4.1 解决问题的三条规则</h2><p>如果一个类使用相同的函数签名从多个地方（比如另一个类或接口）继承了方法，通过三条规则可以进行判断。</p>
<ol>
<li>类中的方法优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。</li>
<li>如果无法依据第一条进行判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果 B 继承了 A ，那么 B 就比 A 更加具体。</li>
<li>最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法，显式地选择使用哪一个默认方法的实现。</li>
</ol>
<h2 id="4-2-菱形继承问题"><a href="#4-2-菱形继承问题" class="headerlink" title="4.2 菱形继承问题"></a>4.2 菱形继承问题</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/09.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%209%EF%BC%9A%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/3.png" alt=""></p>
<p>了解即可</p>
<h1 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h1><ol>
<li>Java 8中的接口可以通过默认方法和静态方法提供方法的代码实现。</li>
<li>默认方法的开头以关键字 default 修饰，方法体与常规的类方法相同。</li>
<li>向发布的接口添加抽象方法不是源码兼容的。</li>
<li>默认方法的出现能帮助库的设计者以后向兼容的方式演进API。</li>
<li>默认方法可以用于创建可选方法和行为的多继承。</li>
<li>我们有办法解决由于一个类从多个接口中继承了拥有相同函数签名的方法而导致的冲突。</li>
<li>类或者父类中声明的方法的优先级高于任何默认方法。如果前一条无法解决冲突，那就选择同函数签名的方法中实现得最具体的那个接口的方法。</li>
<li>两个默认方法都同样具体时，你需要在类中覆盖该方法，显式地选择使用哪个接口中提供的默认方法。</li>
</ol>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我的公众号：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-18T03:34:52.000Z" title="2019-03-18T03:34:52.000Z">2019-03-18</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">21 分钟 读完 (大约 3128 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/18/%E3%80%8AJava%208%20in%20Action%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%208%EF%BC%9A%E9%87%8D%E6%9E%84%E3%80%81%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B0%83%E8%AF%95/">《Java 8 in Action》Chapter 8：重构、测试和调试</a></h1><div class="content"><blockquote>
<p>我们会介绍几种方法，帮助你重构代码，以适配使用Lambda表达式，让你的代码具备更好的可读性和灵活性。除此之外，我们还会讨论目前比较流行的几种面向对象的设计模式，<br>包括策略模式、模板方法模式、观察者模式、责任链模式，以及工厂模式，在结合Lambda表达式之后变得更简洁的情况。最后，我们会介绍如何测试和调试使用Lambda表达式和Stream API的代码。</p>
</blockquote>
<h1 id="1-为改善可读性和灵活性重构代码"><a href="#1-为改善可读性和灵活性重构代码" class="headerlink" title="1. 为改善可读性和灵活性重构代码"></a>1. 为改善可读性和灵活性重构代码</h1><h2 id="1-1-改善代码的可读性"><a href="#1-1-改善代码的可读性" class="headerlink" title="1.1 改善代码的可读性"></a>1.1 改善代码的可读性</h2><p>Java 8的新特性也可以帮助提升代码的可读性: </p>
<ul>
<li>使用Java 8，你可以减少冗长的代码，让代码更易于理解</li>
<li>通过方法引用和Stream API，你的代码会变得更直观</li>
</ul>
<p>利用Lambda表达式、方法引用以及Stream改善程序代码的可读性:</p>
<ul>
<li>重构代码，用Lambda表达式取代匿名类</li>
<li>用方法引用重构Lambda表达式</li>
<li>用Stream API重构命令式的数据处理 </li>
</ul>
<h2 id="1-2-从匿名内部类到Lambda表达式的转换"><a href="#1-2-从匿名内部类到Lambda表达式的转换" class="headerlink" title="1.2 从匿名内部类到Lambda表达式的转换"></a>1.2 从匿名内部类到Lambda表达式的转换</h2><p>将实现单一抽象方法的匿名类转换为Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统的方式，使用匿名类</span></span><br><span class="line">Runnable r1 = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新的方式，使用Lambda表达式</span></span><br><span class="line">Runnable r2 = () -&gt; System.out.println(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure>

<p>匿名 类和Lambda表达式中的this和super的含义是不同的。在匿名类中，this代表的是类自身，但是在Lambda中，它代表的是包含类。其次，匿名类可以屏蔽包含类的变量，而Lambda表达式不能(它们会导致编译错误)，如下面这段代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">Runnable r1 = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;                    <span class="comment">// 编译错误</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;;</span><br><span class="line">Runnable r2 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2</span>;                <span class="comment">// 正常</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在涉及重􏰴的上下文里，将匿名类转换为Lambda表达式可能导致最终的代码更加晦涩。实际上，匿名类的类型是在初始化时确定的，而Lambda的类型取决于它的上下文。通过下面这个例子，我们可以了解问题是如何发生的。我们假设你用与Runnable同样的签名声明了一个函数接口，我们称之为Task:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Runnable r)</span></span>&#123; r.run(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Task a)</span></span>&#123; a.execute(); &#125;</span><br><span class="line">doSomething(<span class="keyword">new</span> Task() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Danger danger!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// doSomething(Runnable) 和 doSomething(Task) 都匹配该类型</span></span><br><span class="line">doSomething(() -&gt; System.out.println(<span class="string">"Danger danger!!"</span>));</span><br><span class="line"><span class="comment">// 使用显式的类型转换来解决这种模棱两可的情况</span></span><br><span class="line">doSomething((Task)() -&gt; System.out.println(<span class="string">"Danger danger!!"</span>));</span><br></pre></td></tr></table></figure>
<p>目前大多数的集成开发环境，比如NetBeans和IntelliJ都支持这种重构，它们能自动地帮你检查，避免发生这些问题。</p>
<h2 id="1-3-从Lambda表达式到方法引用的转换"><a href="#1-3-从Lambda表达式到方法引用的转换" class="headerlink" title="1.3 从Lambda表达式到方法引用的转换"></a>1.3 从Lambda表达式到方法引用的转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByCaloricLevel =</span><br><span class="line">        menu.stream()</span><br><span class="line">            .collect(</span><br><span class="line">                groupingBy(dish -&gt; &#123;</span><br><span class="line">                     <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>将Lambda表达式的内容抽取到一个单独的方法中，将其作为参数传递给groupingBy方法。变换之后，代码变得更加简洁，程序的意图也更加清晰了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByCaloricLevel = menu.stream().collect(groupingBy(Dish::getCaloricLevel));</span><br></pre></td></tr></table></figure>

<h2 id="1-4-从命令式的数据处理切换到Stream"><a href="#1-4-从命令式的数据处理切换到Stream" class="headerlink" title="1.4 从命令式的数据处理切换到Stream"></a>1.4 从命令式的数据处理切换到Stream</h2><p>我们建议你将所有使用迭代器这种数据处理模式处理集合的代码都转换成Stream API的方式。为什么呢?<br>Stream API能更清晰地表达数据处理管道的意图。除此之外，通过短路和延迟载入以及利用第7章介绍的现代计算机的多核架构，我们可以对Stream进行优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令式版本</span></span><br><span class="line">List&lt;String&gt; dishNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Dish dish: menu)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dish.getCalories() &gt; <span class="number">300</span>)&#123;</span><br><span class="line">            dishNames.add(dish.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用Stream API</span></span><br><span class="line">menu.parallelStream()</span><br><span class="line">        .filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)</span><br><span class="line">        .map(Dish::getName)</span><br><span class="line">        .collect(toList());</span><br></pre></td></tr></table></figure>

<h2 id="1-5-增加代码的灵活性"><a href="#1-5-增加代码的灵活性" class="headerlink" title="1.5 增加代码的灵活性"></a>1.5 增加代码的灵活性</h2><p>没有函数式接口就无法使用Lambda表达式，因此代码中需要引入函数式接口。引入函数式接口的两种通用模式：</p>
<ul>
<li>有条件的延迟执行</li>
<li>环绕执行</li>
</ul>
<h2 id="2-使用Lambda重构面向对象的设计模式"><a href="#2-使用Lambda重构面向对象的设计模式" class="headerlink" title="2. 使用Lambda重构面向对象的设计模式"></a>2. 使用Lambda重构面向对象的设计模式</h2><p>使用Lambda表达式后，很多现存的略显臃肿的面向对象设计模式能够用更精简的方式实现了。这一节中，我们会针对五个设计模式展开讨论，它们分别是:</p>
<ul>
<li>策略模式</li>
<li>模板方法</li>
<li>观察者模式</li>
<li>责任链模式</li>
<li>工厂模式</li>
</ul>
<h2 id="2-1-策略模式"><a href="#2-1-策略模式" class="headerlink" title="2.1 策略模式"></a>2.1 策略模式</h2><p>策略模式代表了解决一类算法的通用解决方案，你可以在运行时选择使用哪种方案。策略模式包含三部分内容，如图所示。</p>
<ul>
<li>一个代表某个算法的接口(它是策略模式的接口)。 </li>
<li>一个或多个该接口的具体实现，它们代表了算法的多种实现(比如，实体类ConcreteStrategyA或者ConcreteStrategyB)。</li>
<li>一个或多个使用策略对象的客户。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/08.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%208%EF%BC%9A%E9%87%8D%E6%9E%84%E3%80%81%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B0%83%E8%AF%95/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValidationStrategy</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsAllLowerCase</span> <span class="keyword">implements</span> <span class="title">ValidationStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(<span class="string">"[a-z]+"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsNumber</span> <span class="keyword">implements</span> <span class="title">ValidationStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(<span class="string">"\\d+"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ValidationStrategy strategy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Validator</span><span class="params">(ValidationStrategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.execute(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Validator numericValidator = <span class="keyword">new</span> Validator(<span class="keyword">new</span> IsNumber());</span><br><span class="line">        <span class="keyword">boolean</span> b1 = numericValidator.validate(<span class="string">"aaaa"</span>);</span><br><span class="line">        Validator lowerCaseValidator = <span class="keyword">new</span> Validator(<span class="keyword">new</span> IsAllLowerCase());</span><br><span class="line">        <span class="keyword">boolean</span> b2 = lowerCaseValidator.validate(<span class="string">"bbbb"</span>);</span><br><span class="line">        System.out.println(b1 + <span class="string">" "</span> + b2);</span><br><span class="line">        Validator numericValidator1 = <span class="keyword">new</span> Validator((String s) -&gt; s.matches(<span class="string">"[a-z]+"</span>));</span><br><span class="line">        <span class="keyword">boolean</span> b11 = numericValidator1.validate(<span class="string">"aaaa"</span>);</span><br><span class="line">        Validator lowerCaseValidator1 = <span class="keyword">new</span> Validator((String s) -&gt; s.matches(<span class="string">"\\d+"</span>));</span><br><span class="line">        <span class="keyword">boolean</span> b21 = lowerCaseValidator.validate(<span class="string">"bbbb"</span>);</span><br><span class="line">        System.out.println(b11 + <span class="string">" "</span> + b21);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-模板方法"><a href="#2-2-模板方法" class="headerlink" title="2.2 模板方法"></a>2.2 模板方法</h2><p>模板 方法模式在你“希望使用这个算法，但是需要对其中的某些行进行改进，才能达到希望的效果” 时是非常有用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlineBanking</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processCustomer</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Customer c = DataUtil.getCustomerWithId(id);</span><br><span class="line">        makeCustomerHappy(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeCustomerHappy</span><span class="params">(Customer c)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlineBankingLambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processCustomer</span><span class="params">(<span class="keyword">int</span> id, Consumer&lt;Customer&gt; consumer)</span> </span>&#123;</span><br><span class="line">        Customer c = DataUtil.getCustomerWithId(id);</span><br><span class="line">        consumer.accept(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> OnlineBanking() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">makeCustomerHappy</span><span class="params">(Customer c)</span> </span>&#123;</span><br><span class="line">                System.out.println(c.getName() + <span class="string">" happy!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.processCustomer(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> OnlineBankingLambda().processCustomer(<span class="number">1</span>, (Customer c) -&gt; System.out.println(c.getName() + <span class="string">" happy!"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-观察者模式"><a href="#2-3-观察者模式" class="headerlink" title="2.3 观察者模式"></a>2.3 观察者模式</h2><p>观察者模式是一种比较常见的方案，某些事件发生时(比如状态转变)，如果一个对象(通常我们称之为主题)需要自动地通知其他多个对象(称为观察者)，就会采用该方案。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/08.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%208%EF%BC%9A%E9%87%8D%E6%9E%84%E3%80%81%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B0%83%E8%AF%95/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(String tweet)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYTime</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String tweet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tweet != <span class="keyword">null</span> &amp;&amp; tweet.contains(<span class="string">"money"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Breaking news in NY! "</span> + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Guardian</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String tweet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tweet != <span class="keyword">null</span> &amp;&amp; tweet.contains(<span class="string">"queen"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Yet another news in London... "</span> + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeMonde</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String tweet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tweet != <span class="keyword">null</span> &amp;&amp; tweet.contains(<span class="string">"wine"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Today cheese, wine and news! "</span> + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nofityObservers</span><span class="params">(String tweet)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Feed</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nofityObservers</span><span class="params">(String tweet)</span> </span>&#123;</span><br><span class="line">        observers.forEach(o -&gt; o.notify(tweet));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Feed f = <span class="keyword">new</span> Feed();</span><br><span class="line">        f.registerObserver(<span class="keyword">new</span> NYTime());</span><br><span class="line">        f.registerObserver(<span class="keyword">new</span> Guardian());</span><br><span class="line">        f.registerObserver(<span class="keyword">new</span> LeMonde());</span><br><span class="line">        f.nofityObservers(<span class="string">"The queen said her favourite book is Java 8 in Action!"</span>);</span><br><span class="line">        f.registerObserver((String tweet) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (tweet != <span class="keyword">null</span> &amp;&amp; tweet.contains(<span class="string">"money"</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Breaking news in NY! "</span> + tweet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        f.registerObserver((String tweet) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (tweet != <span class="keyword">null</span> &amp;&amp; tweet.contains(<span class="string">"queen"</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Yet another news in London... "</span> + tweet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-责任链模式"><a href="#2-4-责任链模式" class="headerlink" title="2.4 责任链模式"></a>2.4 责任链模式</h2><p>责任链模式是一种创建处理对象序列(比如操作序列)的通用方案。一个处理对象可能需要在完成一些工作之后，将结果传递给另一个对象，这个对象接着做一些工作，再转交给下一个处理对象，以此类推。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/08.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%208%EF%BC%9A%E9%87%8D%E6%9E%84%E3%80%81%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B0%83%E8%AF%95/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessingObject</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> ProcessingObject&lt;T&gt; successor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(ProcessingObject&lt;T&gt; successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">handle</span><span class="params">(T input)</span> </span>&#123;</span><br><span class="line">        T r = handleWork(input);</span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> successor.handle(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> T <span class="title">handleWork</span><span class="params">(T input)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderTextProcessing</span> <span class="keyword">extends</span> <span class="title">ProcessingObject</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">handleWork</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"From Raoul, Mario and Alan: "</span> + input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellCheckerProcessing</span> <span class="keyword">extends</span> <span class="title">ProcessingObject</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">handleWork</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.replaceAll(<span class="string">"labda"</span>, <span class="string">"lambda"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainOfResponsibilityDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProcessingObject&lt;String&gt; p1 = <span class="keyword">new</span> HeaderTextProcessing();</span><br><span class="line">        ProcessingObject&lt;String&gt; p2 = <span class="keyword">new</span> SpellCheckerProcessing();</span><br><span class="line">        p1.setSuccessor(p2);</span><br><span class="line">        String result = p1.handle(<span class="string">"Aren't labdas really sexy?!!"</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        UnaryOperator&lt;String&gt; headerProcessing = (String text) -&gt; <span class="string">"From Raoul, Mario and Alan: "</span> + text;</span><br><span class="line">        UnaryOperator&lt;String&gt; spellCheckerProcessing = (String text) -&gt; text.replaceAll(<span class="string">"labda"</span>, <span class="string">"lambda"</span>);</span><br><span class="line">        Function&lt;String, String&gt; pipeline = headerProcessing.andThen(spellCheckerProcessing);</span><br><span class="line">        String result1 = pipeline.apply(<span class="string">"Aren't labdas really sexy?!!"</span>);</span><br><span class="line">        System.out.println(result1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-工厂模式"><a href="#2-5-工厂模式" class="headerlink" title="2.5 工厂模式"></a>2.5 工厂模式</h2><p>使用工厂模式，你无需向客户暴露实例化的逻辑就能完成对象的创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Loan</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stock</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bond</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"loan"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Loan();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"stock"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Stock();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"bond"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Bond();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No such product "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product p = ProductFactory.createProduct(<span class="string">"loan"</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactoryLambda</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, Supplier&lt;Product&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">"loan"</span>, Loan::<span class="keyword">new</span>);</span><br><span class="line">        map.put(<span class="string">"stock"</span>, Stock::<span class="keyword">new</span>);</span><br><span class="line">        map.put(<span class="string">"bond"</span>, Bond::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Product&gt; p = map.get(name);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> p.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No such product "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product p = ProductFactoryLambda.createProduct(<span class="string">"loan"</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-测试Lambda表达式"><a href="#3-测试Lambda表达式" class="headerlink" title="3. 测试Lambda表达式"></a>3. 测试Lambda表达式</h1><p>略</p>
<h1 id="4-调试Lambda表达式"><a href="#4-调试Lambda表达式" class="headerlink" title="4. 调试Lambda表达式"></a>4. 调试Lambda表达式</h1><h2 id="4-1-查看栈跟踪"><a href="#4-1-查看栈跟踪" class="headerlink" title="4.1 查看栈跟踪"></a>4.1 查看栈跟踪</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Debugging</span></span>&#123; <span class="number">11</span> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Point&gt; points = Arrays.asList(<span class="keyword">new</span> Point(<span class="number">12</span>, <span class="number">2</span>), <span class="keyword">null</span>);</span><br><span class="line">        points.stream().map(p -&gt; p.getX()).forEach(System.out::println); &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行这段代码会产生下面的栈跟踪:</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NullPointerException</span><br><span class="line">at Debugging.lambda$main$<span class="number">0</span>(Debugging.java:<span class="number">6</span>)</span><br><span class="line">at Debugging$$Lambda$<span class="number">5</span>/<span class="number">284720968</span>.apply(Unknown Source)</span><br><span class="line">at java.util.stream.ReferencePipeline$<span class="number">3</span>$<span class="number">1</span>.accept(ReferencePipeline</span><br><span class="line">.java:<span class="number">193</span>)</span><br><span class="line">at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators</span><br><span class="line">.java:<span class="number">948</span>)</span><br></pre></td></tr></table></figure>
<p>我们需要特别注意，涉及Lambda表达式的栈􏱡􏴭可能非常难理解。这是Java编译器未来版本可以改进的一个方面。</p>
<h2 id="4-2-使用日志调试"><a href="#4-2-使用日志调试" class="headerlink" title="4.2 使用日志调试"></a>4.2 使用日志调试</h2><p>peek的设计初衷就是在流的每个元素恢复运行之前，插入执行一个动作。但是它不像forEach那样恢复整个流的运行，而是在一个元素上完成操作之后，它只会将操作顺承到流水线中的下一个操作。图8-4解释了peek的操作流程。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/08.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%208%EF%BC%9A%E9%87%8D%E6%9E%84%E3%80%81%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B0%83%E8%AF%95/peek.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; result = numbers.stream()</span><br><span class="line">         .peek(x -&gt; System.out.println(<span class="string">"from stream: "</span> + x))</span><br><span class="line">         .map(x -&gt; x + <span class="number">17</span>)</span><br><span class="line">         .peek(x -&gt; System.out.println(<span class="string">"after map: "</span> + x))</span><br><span class="line">         .filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">         .peek(x -&gt; System.out.println(<span class="string">"after filter: "</span> + x))</span><br><span class="line">         .limit(<span class="number">3</span>)</span><br><span class="line">         .peek(x -&gt; System.out.println(<span class="string">"after limit: "</span> + x))</span><br><span class="line">         .collect(toList());</span><br><span class="line">输出结果：</span><br><span class="line">from stream: <span class="number">2</span></span><br><span class="line">after map: <span class="number">19</span></span><br><span class="line">from stream: <span class="number">3</span></span><br><span class="line">after map: <span class="number">20</span></span><br><span class="line">after filter: <span class="number">20</span></span><br><span class="line">after limit: <span class="number">20</span></span><br><span class="line">from stream: <span class="number">4</span></span><br><span class="line">after map: <span class="number">21</span></span><br><span class="line">from stream: <span class="number">5</span></span><br><span class="line">after map: <span class="number">22</span></span><br><span class="line">after filter: <span class="number">22</span></span><br><span class="line">after limit: <span class="number">22</span></span><br></pre></td></tr></table></figure>

<h1 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h1><ul>
<li>Lambda表达式能提升代码的可读性和灵活性。</li>
<li>如果你的代码中使用了匿名类，尽量用Lambda表达式替换它们，但是要注意二者间语义的微妙差别，比如关键字this，以及变量隐藏。</li>
<li>Lambda表达式比起来，方法引用的可读性更好。</li>
<li>尽量使用Stream API替换迭代式的集合处理。</li>
<li>Lambda表达式有助于避免使用面向对象设计模式时容易出现的􏳂化的模板代码，典型的比如策略模式、模板方法、观察者模式、责任链模式，以及工厂模式。</li>
<li>即使采用了Lambda表达式，也同样可以进行单元测试，但是通常你应该关注使用了Lambda表达式的方法的行为。</li>
<li>尽量将复杂的Lambda表达式抽象到普通方法中。</li>
<li>Lambda表达式会让栈跟踪的分析变得更为复杂。</li>
<li>流提供的peek方法在分析Stream流水线时，能将中间变量的值输出到日志中，是非常有用的工具。</li>
</ul>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我的公众号：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-17T03:34:52.000Z" title="2019-03-17T03:34:52.000Z">2019-03-17</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">36 分钟 读完 (大约 5472 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/17/%E3%80%8AJava%208%20in%20Action%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%207%EF%BC%9A%E5%B9%B6%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/">《Java 8 in Action》Chapter 7：并行数据处理与性能</a></h1><div class="content"><blockquote>
<p>在Java 7之前，并行处理数据集合非常麻烦。第一，你得明确地把包含数据的数据结构分成若干子部分。第二，你要给每个子部分分配一个独立的线程。第三，你需要在恰当的时候对它们进行同步来避免不希望出现的竞争条件，等待所有线程完成，最后把这些部分结果合并起来。Java 7引入了一个叫作分支/合并的框架，让这些操作更稳定、更不易出错。<br>Stream接口让你不用太费力气就能对数据集执行并行操作。它允许你声明性地将顺序流变为并行流。此外，你将看到Java是如何变戏法的，或者更实际地来说， 流是如何在幕后应用Java 7引入的分支/合并框架的。</p>
</blockquote>
<h1 id="1-并行流"><a href="#1-并行流" class="headerlink" title="1. 并行流"></a>1. 并行流</h1><p>并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sequentialSum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> Stream.iterate(<span class="number">1L</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">                          .limit(n)</span><br><span class="line">                          .reduce(<span class="number">0L</span>, Long::sum);</span><br><span class="line">&#125;</span><br><span class="line">传统写法：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">iterativeSum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1L</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            result += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-1-将顺序流转换为并行流"><a href="#1-1-将顺序流转换为并行流" class="headerlink" title="1.1 将顺序流转换为并行流"></a>1.1 将顺序流转换为并行流</h2><p>可以把流转换成并行流，从而让前面的函数归约过程(也就是求和)并行运行——对顺序流调用parallel方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">parallelSum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.iterate(<span class="number">1L</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">                     .limit(n)</span><br><span class="line">                     .parallel()</span><br><span class="line">                     .reduce(<span class="number">0L</span>, Long::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在现实中，对顺序流调用parallel方法并不意味着流本身有任何实际的变化。它在内部实际上就是设了一个boolean标志，表示你想让调用parallel之后进行的所有操作都并行执行。类似地，你只需要对并行流调用sequential方法就可以把它变成顺序流。请注意，你可能以为把这两个方法结合起来，就可以更细化地控制在遍历流时哪些操作要并行执行，哪些要顺序执行。</p>
<blockquote>
<p>配置并行流使用的线程池<br>看看流的parallel方法，你可能会想，并行流用的线程是从哪来的?有多少个?怎么自定义这个过程呢?<br>并行流内部使用了默认的ForkJoinPool，它默认的线程数量就是你的处理器数量，这个值是由Runtime.getRuntime().available- Processors()得到的。<br>但是你可以通过系统属性 java.util.concurrent.ForkJoinPool.common.parallelism来改变线程池大小，如下所示:<br>System.setProperty(“java.util.concurrent.ForkJoinPool.common.parallelism”,”12”);<br>这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个并行流指定这个值。一般而言，让ForkJoinPool的大小等于处理器数量是个不错的默认值，<br>除非你有很好的理由，否则我们强烈建议你不要修改它。</p>
</blockquote>
<h2 id="1-2-测量流性能"><a href="#1-2-测量流性能" class="headerlink" title="1.2 测量流性能"></a>1.2 测量流性能</h2><p>并行编程可能很复杂，有时候甚至有点违反直觉。如果用得不对(比如采用了一 个不易并行化的操作，如iterate)，它甚至可能让程序的整体性能更差，所以在调用那个看似神奇的parallel操作时，了解背后到底发生了什么是很有必要的。<br>并行化并不是没有代价的。并行化过程本身需要对流做递归划分，把每个子流的归纳操作分配到不同的线程，然后把这些操作的结果合并成一个值。但在多个内核之间移动数据的代价也可能比你想的要大，所以很重要的一点是要保证在内核中并行执行工作的时间比在内核之间传输数据的时间长。总而言之，很多情况下不可能或不方便并行化。然而，在使用 并行Stream加速代码之前，你必须确保用得对;如果结果错了，算得快就毫无意义了。 </p>
<h2 id="1-3-正确使用并行流"><a href="#1-3-正确使用并行流" class="headerlink" title="1.3 正确使用并行流"></a>1.3 正确使用并行流</h2><p>错用并行流而产生错误的首要原因，就是使用的算法改变了某些共享状态。下面是另一种实现对前n个自然数求和的方法，但这会改变一个共享累加器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sideEffectSum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    Accumulator accumulator = <span class="keyword">new</span> Accumulator();</span><br><span class="line">    LongStream.rangeClosed(<span class="number">1</span>, n).forEach(accumulator::add)</span><br><span class="line">    <span class="keyword">return</span> accumulator.total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Accumulator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123; total += value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码本身上就是顺序的，因为每次访问total都会出现数据竞争。接下来将这段代码改为并行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sideEffectParallelSum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    Accumulator accumulator = <span class="keyword">new</span> Accumulator();</span><br><span class="line">    LongStream.rangeClosed(<span class="number">1</span>, n).parallel().forEach(accumulator::add);</span><br><span class="line">    <span class="keyword">return</span> accumulator.total;&#125;</span><br><span class="line">System.out.println(<span class="string">"SideEffect parallel sum done in: "</span> + measurePerf(ParallelStreams::sideEffectParallelSum, <span class="number">10_000_000L</span>) +<span class="string">" msecs"</span> );</span><br><span class="line">Result: <span class="number">5959989000692</span></span><br><span class="line">Result: <span class="number">7425264100768</span></span><br><span class="line">Result: <span class="number">6827235020033</span></span><br><span class="line">Result: <span class="number">7192970417739</span></span><br><span class="line">Result: <span class="number">6714157975331</span></span><br><span class="line">Result: <span class="number">7715125932481</span></span><br><span class="line">SideEffect parallel sum done in: <span class="number">49</span> msecs</span><br></pre></td></tr></table></figure>
<p>这回方法的性能无关紧要了，唯一要紧的是每次执行都会返回不同的结果，都离正确值50000005000000差很远。这是由于多个线程在同时访问累加器，执行total += value，而这一句􏱵然看似简单，却不是一个原子操作。问题的根源在于，forEach中调用的方法有副作用，它会改变多个线程共享的对象的可变状态。要是你想用并行Stream又不想引发类似的意外，就必须避免这种情况。现在你知道了，共享可变状态会影响并行流以及并行计算。</p>
<h2 id="1-4-高效使用并行流"><a href="#1-4-高效使用并行流" class="headerlink" title="1.4 高效使用并行流"></a>1.4 高效使用并行流</h2><ul>
<li>如果有疑问，测量。把顺序流转成并行流轻而易举，但却不一定是好事。我们在本节中已经指出，并行流并不总是比顺序流快。此外，并行流有时候会和你的直觉不一致，所以在考虑选择顺序流还是并行流时，第一个也是最重要的建议就是用适当的基准来检查其性能。</li>
<li>留意装箱。自动装箱和拆箱操作会大大降低性能。Java 8中有原始类型流(IntStream、 LongStream、DoubleStream)来避免这种操作，但凡有可能都应该用这些流。</li>
<li>有些操作本身在并行流上的性能就比顺序流差。特别是limit和findFirst等依赖于元素顺序的操作，它们在并行流上执行的代价非常大。例如，findAny会比findFirst性能好，因为它不一定要按顺序来执行。你总是可以调用unordered方法来把有序流变成无序流。那么，如果你需要流中的n个元素而不是专门要前n个的话，对无序并行流调用 limit可能会比单个有序流(比如数据源是一个List)更高效。</li>
<li>还要考虑流的操作流水线的总计算成本。设N是要处理的元素的总数，Q是一个元素通过 流水线的大致处理成本，则N*Q就是这个对成本的一个粗略的定性估计。Q值较高就意味着使用并行流时性能好的可能性比较大。</li>
<li>对于较小的数据量，选择并行流几乎从来都不是一个好的决定。并行处理少数几个元素的好处还抵不上并行化造成的额外开销。</li>
<li>要考虑流背后的数据结构是否易于分解。例如，ArrayList的拆分效􏶲比LinkedList 高得多，因为前者用不着遍历就可以平均拆分，而后者则必须遍历。另外，用range工厂方法创建的原始类型流也可以快速分解。最后，你将在7.3节中学到，你可以自己实现Spliterator来完全掌握分解过程。</li>
<li>流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能。例如，一个SIZED流可以分成大小相等的两部分，这样每个部分都可以比较高效地并行处理，但筛选操作可能丢弃的元素个数却无法预测，导致流本身的大小未知。</li>
<li>还要考虑终􏲧操作中合并步骤的代价是大是小(例如Collector中的combiner方法)。 如果这一步代价很大，那么组合每个子流产生的部分结果所付出的代价就可能会超出通过并行流得到的性能提升。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/07.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%207%EF%BC%9A%E5%B9%B6%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/1.png" alt=""></p>
<blockquote>
<p>并行流背后使用的基础架构是Java 7中引入的分支/合并框架。</p>
</blockquote>
<h1 id="2-分支-合并框架"><a href="#2-分支-合并框架" class="headerlink" title="2. 分支/合并框架"></a>2. 分支/合并框架</h1><p>分支/合并框架的目的是以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果。它是ExecutorService接口的一个实现，它把子任务分配给线程池(称为ForkJoinPool)中的工作线程。</p>
<h2 id="2-1-使用RecursiveTask"><a href="#2-1-使用RecursiveTask" class="headerlink" title="2.1 使用RecursiveTask"></a>2.1 使用RecursiveTask</h2><p>要把任务提交到这个池，必须创建RecursiveTask<R>的一个子类，其中R是并行化任务(以 及所有子任务)产生的结果类型，或者如果任务不返回结果，则是RecursiveAction类型(当然它可能会更新其他非局部机构)。要定义RecursiveTask，只需实现它唯一的抽象方法 compute:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> R <span class="title">compute</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个方法同时定义了将任务拆分成子任务的逻辑，以及无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑。下图表示了递归任务的拆分过程：<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/07.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%207%EF%BC%9A%E5%B9%B6%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/2.png" alt=""></p>
<p>让我们试着用这个框架为一个数字范围(这里用一个 long[]数组表示)求和。如前所述，你需要先为RecursiveTask类做一个实现，就是下面代码清单中的ForkJoinSumCalculator。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinSumCalculator</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] numbers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THRESHOLD = <span class="number">10_000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculator</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(numbers, <span class="number">0</span>, numbers.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculator</span><span class="params">(<span class="keyword">long</span>[] numbers, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numbers = numbers;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = end - start;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">return</span> computeSequentially();</span><br><span class="line">        &#125;</span><br><span class="line">        ForkJoinSumCalculator leftTask = <span class="keyword">new</span> ForkJoinSumCalculator(numbers, start, start + length / <span class="number">2</span>);</span><br><span class="line">        leftTask.fork();</span><br><span class="line"></span><br><span class="line">        ForkJoinSumCalculator rightTask = <span class="keyword">new</span> ForkJoinSumCalculator(numbers, start + length / <span class="number">2</span>, end);</span><br><span class="line">        Long rightResult = rightTask.compute();</span><br><span class="line">        Long leftResult = leftTask.join();</span><br><span class="line">        <span class="keyword">return</span> leftResult + rightResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">computeSequentially</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            sum += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用了一个LongStream来生成包含前n个自然数的数组，然后创建一个ForkJoinTask (RecursiveTask的父类)，并把数组传递给代码清单7-2所示ForkJoinSumCalculator的公共构造函数。最后，你创建了一个新的ForkJoinPool，并把任务传给它的调用方法 。在ForkJoinPool中执行时，最后一个方法返回的值就是ForkJoinSumCalculator类定义的任务结果。<br>请注意在实际应用时，使用多个ForkJoinPool是没有什么意义的。正是出于这个原因，一般来说把它实例化一次，然后把实例保存在静态字段中，使之成为单例，这样就可以在软件中任何部分方便地重用了。这里创建时用了其默认的无参数构造函数，这意味着想让线程池使用JVM能够使用的所有处理器。更确切地说，该构造函数将使用Runtime.availableProcessors的返回值来决定线程􏶈使用的线程数。请注意availableProcessors方法虽然看起来是处理器， 但它实际上返回的是可用内核的数量，包括超线程生成的虚拟内核。<br>当把ForkJoinSumCalculator任务传给ForkJoinPool时，这个任务就由􏶈中的一个线程 执行，这个线程会调用任务的compute方法。该方法会检查任务是否小到足以顺序执行，如果不够小则会把要求和的数组分成两半，分给两个新的ForkJoinSumCalculator，而它们也由ForkJoinPool安排执行。因此，这一过程可以递归重复，把原任务分为更小的任务，直到满足不方便或不可能再进一步拆分的条件(本例中是求和的项目数小于等于10000)。这时会顺序计算每个任务的结果，然后由分支过程创建的(隐含的)任务二叉树遍历回到它的根。接下来会合并每个子任务的部分结果，从而得到总任务的结果。这一过程如下图所示。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/07.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%207%EF%BC%9A%E5%B9%B6%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/3.png" alt=""></p>
<h2 id="2-2-使用分支-合并框架的最佳做法"><a href="#2-2-使用分支-合并框架的最佳做法" class="headerlink" title="2.2 使用分支/合并框架的最佳做法"></a>2.2 使用分支/合并框架的最佳做法</h2><ul>
<li>对一个任务调用join方法会阻塞调用方，直到该任务做出结果。因此，有必要在两个子任务的计算都开始之后再调用它。否则，你得到的版本会比原始的顺序算法更慢更复杂，因为每个子任务都必须等待另一个子任务完成才能启动。</li>
<li>不应该在RecursiveTask内部使用ForkJoinPool的invoke方法。相反，你应该始终直接调用compute或fork方法，只有顺序代码才应该用invoke来启动并行计算。</li>
<li>对子任务调用fork方法可以把它排进ForkJoinPool。同时对左边和右边的子任务调用它似乎很自然，但这样做的效􏶲要比直接对其中一个调用compute低。这样做你可以为其中一个子任务重用同一线程，从而避免在线程池中多分配一个任务造成的开销。</li>
<li>调试使用分支/合并框架的并行计算可能有点棘手。特别是你平常都在你喜欢的IDE里面看栈跟踪(stack trace)来找问题，但放在分支-合并并计算上就不行了，因为调用compute的线程并不是概念上的调用方，后者是调用fork的那个。</li>
<li>和并行流一样，你不应理所当然地认为在多核处理器上使用分支/合并框架就比顺序计算快。我们已经说过，一个任务可以分解成多个独立的子任务，才能让性能在并行化时有所提升。所有这些子任务的运行时间都应该比分出新任务所花的时间长;一个惯用方法是把输入/输出放在一个子任务里，计算放在另一个里，这样计算就可以和输入/输出同时进行。此外，在比较同一算法的顺序和并行版本的性能时还有别的因素要考虑。就像任何其他Java代码一样，分支/合并框架需要“预热”或者说要执行几遍才会被JIT编译器优化。这就是为什么在测量性能之前跑几遍程序很重要，我们的测试框架就是这么做的。同时还要知道，编译器内置的优化可能会为顺序版本带来一些优􏲵(例如执行死码分析——删去从未被使用的计算)。</li>
</ul>
<h2 id="2-3-工作窃取"><a href="#2-3-工作窃取" class="headerlink" title="2.3 工作窃取"></a>2.3 工作窃取</h2><p>实际中，每个子任务所花的时间可能天差地别，要么是因为划分策略效率低，要么是有不可预知的原因，比如磁盘访问慢，或是需要和外部任务协调执行。分支/合并框架工程用一种称为工作窃取(work stealing)的技术来解决这个问题。<br>在实际应用中，这意味着这些任务差不多被平均分配到ForkJoinPool中的所有线程上。每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列头上取出下一个任务开始执行。基于前面所述的原因，某个线程可能早早完成了分配给它的所有任务，也就是它的队列已经空了，而其他的线程还很忙。这时，这个线程并没有闲下来，而是随机选了一个别的线程，从队列的尾巴上“偷走”一个任务。这个过程一直继续下去，直到所有的任务都执行完毕，所有的队列都清空。这就是为什么要划成许多小任务而不是少数几个大任务，这有助于更好地在工作线程之间平衡负载。一般来说，这种工作窃取算法用于在池中的工作线程之间重新分配和平衡任务。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/07.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%207%EF%BC%9A%E5%B9%B6%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/4.png" alt=""></p>
<h1 id="3-Spliterator"><a href="#3-Spliterator" class="headerlink" title="3. Spliterator"></a>3. Spliterator</h1><p>Spliterator是Java 8中加入的另一个新接口;这个名字代表“可分迭代器”(splitable iterator)。和Iterator一样，Spliterator也用于遍历数据源中的元素，但它是为了并行执行而设计的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line">        <span class="function">Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与往常一样，T是Spliterator遍历的元素的类型。tryAdvance方法的行为类似于普通的 Iterator，因为它会按顺序一个一个使用Spliterator中的元素，并且如果还有其他元素要遍历就返回true。但trySplit是专为Spliterator接口设计的，因为它可以把一些元素划出去分给第二个Spliterator(由该方法返回)，让它们两个并行处理。Spliterator还可通过 estimateSize方法估计还剩下多少元素要遍历，因为即使不那么确切，能快速算出来是一个值也有助于让拆分均匀一点。</p>
<h2 id="3-1-拆分过程"><a href="#3-1-拆分过程" class="headerlink" title="3.1 拆分过程"></a>3.1 拆分过程</h2><p>将Stream拆分成多个部分的算法是一个递􏰒过程，如图7-6所示。第一步是对第一个 Spliterator调用trySplit，生成第二个Spliterator。第二步对这两个Spliterator调用 trysplit，这样总共就有了四个Spliterator。这个框架不断对Spliterator调用trySplit直到它返回null，表明它处理的数据结构不能再分割，如第三步所示。最后，这个递归拆分过程到第四步就终止了，这时所有的Spliterator在调用trySplit时都返回了null。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/07.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%207%EF%BC%9A%E5%B9%B6%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/5.png" alt=""></p>
<pre><code>Spliterator的特性
Spliterator接口声明的最后一个抽象方法是characteristics，它将返回一个int，代 表Spliterator本身特性集的编码。
使用Spliterator的客户可以用这些特性来更好地控制和优化它的使用。
表7-2总结了这些特性。(不幸的是，虽然它们在概念上与收集器的特性有重叠，编码却不一样。)</code></pre><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/07.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%207%EF%BC%9A%E5%B9%B6%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/6.png" alt=""></p>
<h2 id="3-2-实现自定义Spliterator"><a href="#3-2-实现自定义Spliterator" class="headerlink" title="3.2 实现自定义Spliterator"></a>3.2 实现自定义Spliterator</h2><p>略</p>
<h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h1><p>在本章中，你了解了以下内容。</p>
<ul>
<li>内部迭代让你可以并行处理一个流，而无需在代码中显式使用和􏷡调不同的线程。</li>
<li>虽然并行处理一个流很容易，却不能保证程序在所有情况下都运行得更快。并行软件的行为和性能有时是违反直觉的，因此一定要测量，确保你并没有把程序拖得更慢。</li>
<li>像并行流那样对一个数据集并行执行操作可以提升性能，特别是要处理的元素数量庞大，或处理单个元素特别耗时的时候。</li>
<li>从性能角度来看，使用正确的数据结构，如尽可能利用原始流而不是一般化的流，几乎总是比尝试并行化某些操作更为重要。</li>
<li>分支/合并框架让你得以用递归方式将可以并行的任务拆分成更小的任务，在不同的线程上执行，然后将各个子任务的结果合并起来生成整体结果。</li>
<li>Spliterator定义了并行流如何拆分它要遍历的数据。</li>
</ul>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我的公众号：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-16T03:34:52.000Z" title="2019-03-16T03:34:52.000Z">2019-03-16</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">23 分钟 读完 (大约 3477 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/16/%E3%80%8AJava%208%20in%20Action%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%206%EF%BC%9A%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/">《Java 8 in Action》Chapter 6：用流收集数据</a></h1><div class="content"><h1 id="1-收集器简介"><a href="#1-收集器简介" class="headerlink" title="1. 收集器简介"></a>1. 收集器简介</h1><p>collect() 接收一个类型为 Collector 的参数，这个参数决定了如何把流中的元素聚合到其它数据结构中。Collectors 类包含了大量常用收集器的工厂方法，toList() 和 toSet() 就是其中最常见的两个，除了它们还有很多收集器，用来对数据进行对复杂的转换。</p>
<p>指令式代码和函数式对比：</p>
<blockquote>
<p>要是做多级分组，指令式和函数式之间的区别就会更加明显:由于需要好多层嵌套循环和条件，指令式代码很快就变得更难阅读、更难维护、更难修改。相比之下，函数式版本只要再加上 一个收集器就可以轻松地增强</p>
</blockquote>
<p>预定义收集器，也就是那些可以从Collectors类提供的工厂方法(例如groupingBy)创建的收集器。它们主要提供了三大功能:</p>
<ul>
<li>将流元素归约和汇总为一个值</li>
<li>元素分组</li>
<li>元素分区</li>
</ul>
<h1 id="2-使用收集器"><a href="#2-使用收集器" class="headerlink" title="2. 使用收集器"></a>2. 使用收集器</h1><p>在需要将流项目重组成集合时，一般会使用收集器(Stream方法collect 的参数)。再宽泛一点来说，但凡要把流中所有的项目合并成一个结果时就可以用。这个结果可以是任何类型，可以复杂如代表一棵树的多级映射，或是简单如一个整数。</p>
<h1 id="3-收集器实例"><a href="#3-收集器实例" class="headerlink" title="3. 收集器实例"></a>3. 收集器实例</h1><h2 id="3-1-流中最大值和最小值"><a href="#3-1-流中最大值和最小值" class="headerlink" title="3.1 流中最大值和最小值"></a>3.1 流中最大值和最小值</h2><p>Collectors.maxBy和 Collectors.minBy，来计算流中的最大或最小值。这两个收集器接收一个Comparator参数来比较流中的元素。你可以创建一个Comparator来根据所含热量对菜肴进行比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"找出热量最高的食物:"</span>);</span><br><span class="line">Optional&lt;Dish&gt; collect = DataUtil.genMenu().stream().collect(Collectors.maxBy(Comparator.comparingInt(Dish::getCalories)));</span><br><span class="line">collect.ifPresent(System.out::println);</span><br><span class="line">System.out.println(<span class="string">"找出热量最低的食物:"</span>);</span><br><span class="line">Optional&lt;Dish&gt; collect1 = DataUtil.genMenu().stream().collect(Collectors.minBy(Comparator.comparingInt(Dish::getCalories)));</span><br><span class="line">collect1.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>

<h2 id="3-2-汇总求和"><a href="#3-2-汇总求和" class="headerlink" title="3.2 汇总求和"></a>3.2 汇总求和</h2><p>Collectors类专门为汇总提供了一个工厂方法:Collectors.summingInt。它可接受一个把对象映射为求和所需int的函数，并返回一个收集器;该收集器在传递给普通的collect方法后即执行我们需要的汇总操作。举个例子来说，你可以这样求出菜单列表的总热量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer collect = DataUtil.genMenu().stream().collect(Collectors.summingInt(Dish::getCalories));</span><br><span class="line">System.out.println(<span class="string">"总热量:"</span> + collect);</span><br><span class="line">Double collect1 = Arrays.asList(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>).stream().collect(Collectors.summingDouble(Double::doubleValue));</span><br><span class="line">System.out.println(<span class="string">"double和:"</span> + collect1);</span><br><span class="line">Long collect2 = Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>).stream().collect(Collectors.summingLong(Long::longValue));</span><br><span class="line">System.out.println(<span class="string">"long和:"</span> + collect2);</span><br></pre></td></tr></table></figure>

<h2 id="3-3-汇总求平均值"><a href="#3-3-汇总求平均值" class="headerlink" title="3.3 汇总求平均值"></a>3.3 汇总求平均值</h2><p>Collectors.averagingInt，averagingLong和averagingDouble可以计算数值的平均数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Double collect = DataUtil.genMenu().stream().collect(Collectors.averagingInt(Dish::getCalories));</span><br><span class="line">System.out.println(<span class="string">"平均热量:"</span> + collect);</span><br><span class="line">Double collect1 = Arrays.asList(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>).stream().collect(Collectors.averagingDouble(Double::doubleValue));</span><br><span class="line">System.out.println(<span class="string">"double 平均值:"</span> + collect1);</span><br><span class="line">Double collect2 = Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>).stream().collect(Collectors.averagingLong(Long::longValue));</span><br><span class="line">System.out.println(<span class="string">"long 平均值:"</span> + collect2);</span><br></pre></td></tr></table></figure>
<h2 id="3-4-汇总合集"><a href="#3-4-汇总合集" class="headerlink" title="3.4 汇总合集"></a>3.4 汇总合集</h2><p>你可能想要得到两个或更多这样的结果，而且你希望只需一次操作就可以完成。在这种情况下，你可以使用summarizingInt工厂方法返回的收集器。例如，通过一次summarizing操作你可以就数出菜单中元素的个数，并得到热量总和、平均值、最大值和最小值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics collect = DataUtil.genMenu().stream().collect(Collectors.summarizingInt(Dish::getCalories));</span><br><span class="line">System.out.println(<span class="string">"int:"</span> + collect);</span><br><span class="line">DoubleSummaryStatistics collect1 = Arrays.asList(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>).stream().collect(Collectors.summarizingDouble(Double::doubleValue));</span><br><span class="line">System.out.println(<span class="string">"double:"</span> + collect1);</span><br><span class="line">LongSummaryStatistics collect2 = Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>).stream().collect(Collectors.summarizingLong(Long::longValue));</span><br><span class="line">System.out.println(<span class="string">"long:"</span> + collect2);</span><br></pre></td></tr></table></figure>

<h2 id="3-5-连接字符串"><a href="#3-5-连接字符串" class="headerlink" title="3.5 连接字符串"></a>3.5 连接字符串</h2><p>joining工厂方法返回的收集器会把对流中每一个对象应用toString方法得到的所有字符串连接成一个字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String collect = DataUtil.genMenu().stream().map(Dish::getName).collect(Collectors.joining());</span><br></pre></td></tr></table></figure>
<p>请注意，joining在内部使用了StringBuilder来把生成的字符串逐个追加起来。幸好，joining工厂方法有一个重载版本可以接受元素之间的分界符，这样你就可以得到一个都好分隔的名称列表:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String collect1 = DataUtil.genMenu().stream().map(Dish::getName).collect(Collectors.joining(<span class="string">","</span>));</span><br></pre></td></tr></table></figure>

<h1 id="4-广义的归约汇总"><a href="#4-广义的归约汇总" class="headerlink" title="4. 广义的归约汇总"></a>4. 广义的归约汇总</h1><p>所有收集器，都是一个可以用reducing工厂方法定义的归约过程的特殊情况而已。Collectors.reducing工厂方法是所有这些特殊情况的一般化。<br>它需要三个参数:</p>
<ul>
<li>第一个参数是归约操作的起始值，也是流中没有元素时的返回值，所以很显然对于数值和而言0是一个合适的值。</li>
<li>第二个参数就是你在6.2.2节中使用的函数，将菜肴转换成一个表示其所含热量的int。</li>
<li>第三个参数是一个BinaryOperator，将两个项目累积成一个同类型的值。这里它就是对两个int求和。</li>
</ul>
<p>下面两个是相同的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Dish&gt; collect = DataUtil.genMenu().stream().collect(Collectors.maxBy(Comparator.comparingInt(Dish::getCalories)));</span><br><span class="line">Optional&lt;Dish&gt; mostCalorieDish = menu.stream().collect(reducing((d1, d2) -&gt; d1.getCalories() &gt; d2.getCalories() ? d1 : d2));</span><br></pre></td></tr></table></figure>

<h2 id="5-分组"><a href="#5-分组" class="headerlink" title="5. 分组"></a>5. 分组</h2><p>用Collectors.groupingBy工厂方法返回的收集器就可以轻松地完成任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, List&lt;Dish&gt;&gt; collect = DataUtil.genMenu().stream().collect(Collectors.groupingBy(Dish::getType));</span><br></pre></td></tr></table></figure>
<p>给groupingBy方法传递了一个Function(以方法引用的形式)，它提取了流中每 一道Dish的Dish.Type。我们把这个Function叫作分类函数，因为它用来把流中的元素分成不同的组。分组操作的结果是一个Map，把分组函数返回的值作为映射的键，把流中所有具有这个分类值的项目的列表作为对应的映射值。</p>
<h2 id="5-1-多级分组"><a href="#5-1-多级分组" class="headerlink" title="5.1 多级分组"></a>5.1 多级分组</h2><p>要实现多级分组，我们可以使用一个由双参数版本的Collectors.groupingBy工厂方法创建的收集器，它除了普通的分类函数之外，还可以接受collector类型的第二个参数。那么要进行二级分组的话，我们可以把一个内层groupingBy传递给外层groupingBy，并定义一个为流中项目分类的二级标准：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; collect1 = DataUtil.genMenu().stream().collect(</span><br><span class="line">        Collectors.groupingBy(Dish::getType,</span><br><span class="line">                Collectors.groupingBy(dish -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">                &#125;))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="5-2-按子组收集数据"><a href="#5-2-按子组收集数据" class="headerlink" title="5.2 按子组收集数据"></a>5.2 按子组收集数据</h2><p>传递给第一个groupingBy的第二个收集器可以是任何类型，而不一定是另一个groupingBy。例如，要数一数菜单中每类菜有多少个，可以传递counting收集器作为groupingBy收集器的第二个参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Long&gt; collect2 = DataUtil.genMenu().stream().collect(Collectors.groupingBy(Dish::getType, Collectors.counting()));</span><br></pre></td></tr></table></figure>
<p>还要注意，普通的单参数groupingBy(f)(其中f是分类函数)实际上是groupingBy(f, toList())的简便写法。<br>把收集器返回的结果转换为另一种类型，你可以使用 Collectors.collectingAndThen工厂方法返回的收集器，接受两个参数：要转换的收集器以及转换函数，并返回另一个收集器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Dish&gt; collect3 = DataUtil.genMenu().stream().collect(Collectors.groupingBy(Dish::getType,</span><br><span class="line">        Collectors.collectingAndThen(</span><br><span class="line">                Collectors.maxBy(Comparator.comparingInt(Dish::getCalories)),</span><br><span class="line">                Optional::get</span><br><span class="line">        )));</span><br></pre></td></tr></table></figure>
<p>这个操作放在这里是安全的，因为reducing收集器永远都不会返回Optional.empty()。</p>
<p>常常和groupingBy联合使用的另一个收集器是mapping方法生成的。这个方法接受两个参数:一个函数对流中的元素做变换，另一个则将变换的结果对象收􏰁起来。其目的是在累加之前对每个输入元素应用一个映射函数，这样就可以让接受特定类型元素的收􏰁器适应不同类型的对象。我们来看一个使用这个收集器的实际例子。比方说你想要知道，对于每种类型的Dish， 菜单中都有哪些CaloricLevel。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; collect4 = DataUtil.genMenu().stream().collect(Collectors.groupingBy(</span><br><span class="line">        Dish::getType, Collectors.mapping(</span><br><span class="line">                dish -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">                &#125;, Collectors.toSet()</span><br><span class="line">        )</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<h1 id="6-分区"><a href="#6-分区" class="headerlink" title="6. 分区"></a>6. 分区</h1><p>分区是分组的特殊情况:由一个谓词(返回一个布尔值的函数)作为分类函数，它称分类函数。分区函数返回一个布尔值，这意味着得到的分组Map的键类型是Boolean，于是它最多可以 分为两组——true是一组，false是一组。例如，如果想要把菜按照素食和非素食分开:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; collect = DataUtil.genMenu().stream().collect(Collectors.partitioningBy(Dish::isVegetarian));</span><br><span class="line">System.out.println(collect.get(<span class="keyword">true</span>));</span><br><span class="line">partitioningBy 工厂方法有一个重载版本，可以像下面这样传递第二个收集器:</span><br><span class="line">Map&lt;Boolean, Map&lt;Dish.Type, List&lt;Dish&gt;&gt;&gt; collect1 = DataUtil.genMenu().stream().collect(Collectors.partitioningBy(</span><br><span class="line">        Dish::isVegetarian, Collectors.groupingBy(Dish::getType)</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分区看作分组一种特殊情况。</p>
</blockquote>
<h1 id="7-Collectors类的静态工厂方法"><a href="#7-Collectors类的静态工厂方法" class="headerlink" title="7. Collectors类的静态工厂方法"></a>7. Collectors类的静态工厂方法</h1><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/06.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%206%EF%BC%9A%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/1.png" alt=""><br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/06.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%206%EF%BC%9A%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/2.png" alt=""></p>
<h1 id="8-收集器接口"><a href="#8-收集器接口" class="headerlink" title="8. 收集器接口"></a>8. 收集器接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本列表适用以下定义:</p>
<ul>
<li>T是流中要收集的项目的泛型。</li>
<li>A是累加器的类型，累加器是在收集过程中用于累积部分结果的对象。</li>
<li>R是手机操作得到的对象(通常但并不一定是集合)的类型。</li>
</ul>
<h2 id="8-1-建立新的结果容器-supplier方法"><a href="#8-1-建立新的结果容器-supplier方法" class="headerlink" title="8.1 建立新的结果容器:supplier方法"></a>8.1 建立新的结果容器:supplier方法</h2><p>supplier方法必须返回一个结果为空的Supplier，也就是一个无参数函数，在调用时它会创建一个空的累加器实例，供数据收集过程使用。</p>
<h2 id="8-2-将元素添加到结果容器-accumulator方法"><a href="#8-2-将元素添加到结果容器-accumulator方法" class="headerlink" title="8.2 将元素添加到结果容器:accumulator方法"></a>8.2 将元素添加到结果容器:accumulator方法</h2><p>accumulator方法会返回执行归约操作的函数。当遍历到流中第n个元素时，这个函数执行时会有两个参数:保存归约结果的累加器(已收集了流中的前n-1个项目)，还有第n个元素本身。该函数将返回void，因为累加器是原位更新，即函数的执行改变了它的内部状态以体现遍历的元素的效果。</p>
<h2 id="8-3-对结果容器应用最终转换-finisher方法"><a href="#8-3-对结果容器应用最终转换-finisher方法" class="headerlink" title="8.3 对结果容器应用最终转换:finisher方法"></a>8.3 对结果容器应用最终转换:finisher方法</h2><p>在遍历完流后，finisher方法必须返回在累积过程的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的最终结果。<br>顺序归约过程的逻辑步骤:<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/06.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%206%EF%BC%9A%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/3.png" alt=""></p>
<h2 id="8-4-合并两个结果容器-combiner方法"><a href="#8-4-合并两个结果容器-combiner方法" class="headerlink" title="8.4 合并两个结果容器:combiner方法"></a>8.4 合并两个结果容器:combiner方法</h2><p>四个方法中的最后一个——combiner方法会返回一个供归约操作使用的函数，它定义了对流的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并:</p>
<ul>
<li>原始流会以递归方式拆分为子流，直到定义流是否需要进一步拆分的一个条件为非(如果分布式工作单位太小，并行计算往往比顺序计算要慢，而且要是生成的并行任务比处理器内核数多很多的话就毫无意义了)。</li>
<li>现在，所有的子流都可以并行处理，即对每个子流应用图6-7所示的顺序归约算法。</li>
<li>最后，使用收集器combiner方法返回的函数，将所有的部分结果两两合并。这时会把原始流每次拆分时得到的子流对应的结果合并起来</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/06.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%206%EF%BC%9A%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/4.png" alt=""></p>
<h2 id="8-5-characteristics方法"><a href="#8-5-characteristics方法" class="headerlink" title="8.5 characteristics方法"></a>8.5 characteristics方法</h2><p>最后一个方法——characteristics会返回一个不可变的Characteristics集合，它定义了收集器的行为——尤其是关于流是否可以并行归约，以及可以使用哪些优化的提示。<br>Characteristics是一个包含三个项目的枚举。</p>
<ul>
<li>UNORDERED——归约结果不受流中项目的遍历和累积顺序的影响。</li>
<li>CONCURRENT——accumulator函数可以从多个线程同时调用，且该收集器可以并行归约流。如果收集器没有标为UNORDERED，那它仅在用于无序数据源时才可以并行归约。 </li>
<li>IDENTITY_FINISH——这表明完成器方法返回的函数是一个恒等函数，可以跳过。这种情况下，累加器对象将会直接用作归约过程的最终结果。这也意味着，将累加器A不加检查地转换为结果R是安全的。</li>
</ul>
<h1 id="9-小结"><a href="#9-小结" class="headerlink" title="9. 小结"></a>9. 小结</h1><ul>
<li>collect是一个终端操作，它接受的参数是将流中元素累积到汇总结果的各种方式(称为收集器)。</li>
<li>预定义收集器包括将流元素归约和汇总到一个值，例如计算最小值、最大值或平均值。这些收集器总结在表6-1中。</li>
<li>预定义收集器可以用groupingBy对流中元素进行分组，或用partitioningBy进行分区。</li>
<li>收集器可以高效地复合起来，进行多级分组、分区和归约。</li>
<li>你可以实现Collector接口中定义的方法来开发你自己的收集器。</li>
</ul>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我的公众号：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-10T03:34:52.000Z" title="2019-03-10T03:34:52.000Z">2019-03-10</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">24 分钟 读完 (大约 3647 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/10/%E3%80%8AJava%208%20in%20Action%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%205%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%B5%81/">《Java 8 in Action》Chapter 5：使用流</a></h1><div class="content"><blockquote>
<p>流让你从外部迭代转向内部迭代，for循环显示迭代不用再写了，流内部管理对集合数据的迭代。这种处理数据的方式很有用，因为你让Stream API管理如何处理数据。这样Stream API就可以在背后进行多种优化。此外，使用内部迭代的话，Stream API可以决定并行运行你的代码。这要是用外部迭代的话就办不到了，因为你只能用单一线程挨个迭代。</p>
</blockquote>
<h1 id="1-筛选和切片"><a href="#1-筛选和切片" class="headerlink" title="1. 筛选和切片"></a>1. 筛选和切片</h1><h2 id="1-1-用谓词筛选"><a href="#1-1-用谓词筛选" class="headerlink" title="1.1 用谓词筛选"></a>1.1 用谓词筛选</h2><p>该操作会接受一个谓词(一个返回 boolean的函数)作为参数，并返回一个包括所有符合谓词的元素的流。筛选出所有素菜</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; vegetarianMenu = menu.stream()</span><br><span class="line">                                .filter(Dish::isVegetarian)</span><br><span class="line">                                .collect(toList());</span><br></pre></td></tr></table></figure>

<h2 id="1-2-筛选各异的元素"><a href="#1-2-筛选各异的元素" class="headerlink" title="1.2 筛选各异的元素"></a>1.2 筛选各异的元素</h2><p>返回一个元素各异(根据流所生成元素的 hashCode和equals方法实现)的流。筛选出列表中所有的偶数，并确保没有重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">numbers.stream()</span><br><span class="line">        .filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .distinct()</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h2 id="1-3-截短流"><a href="#1-3-截短流" class="headerlink" title="1.3 截短流"></a>1.3 截短流</h2><p>流支持limit(n)方法，该方法会返回一个不超过给定长度的流。所需的长度作为参数传递给limit。如果流是有序的，则最多会返回前n个元素。选出热量超过300卡路里的头三道菜</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; dishes = menu.stream()</span><br><span class="line">                        .filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)</span><br><span class="line">                        .limit(<span class="number">3</span>)</span><br><span class="line">                        .collect(toList());</span><br></pre></td></tr></table></figure>
<p>limit也可以用在无序流上，比如源是一个Set。这种情况下，limit的结果不会以 任何顺序排列。</p>
<h2 id="1-4-跳过元素"><a href="#1-4-跳过元素" class="headerlink" title="1.4 跳过元素"></a>1.4 跳过元素</h2><p>流还支持skip(n)方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流。跳过超过300卡路里的头两道菜，并返回剩下的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; dishes = menu.stream()</span><br><span class="line">                        .filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)</span><br><span class="line">                        .skip(<span class="number">2</span>)</span><br><span class="line">                        .collect(toList());</span><br></pre></td></tr></table></figure>

<h1 id="2-映射"><a href="#2-映射" class="headerlink" title="2. 映射"></a>2. 映射</h1><h2 id="2-1-对流中每一个元素应用函数"><a href="#2-1-对流中每一个元素应用函数" class="headerlink" title="2.1 对流中每一个元素应用函数"></a>2.1 对流中每一个元素应用函数</h2><p>流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素。提取流中菜肴的名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; dishNames = menu.stream()</span><br><span class="line">                             .map(Dish::getName)</span><br><span class="line">                             .collect(toList());</span><br></pre></td></tr></table></figure>

<h2 id="2-2-流的扁平化"><a href="#2-2-流的扁平化" class="headerlink" title="2.2 流的扁平化"></a>2.2 流的扁平化</h2><p>flatmap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。单个流都被合并起来，即扁平化为一个流。例如，给定单词列表 [“Hello”,”World”]，你想要返回列表[“H”,”e”,”l”, “o”,”W”,”r”,”d”]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">"Java 8"</span>, <span class="string">"Lambdas"</span>, <span class="string">"In"</span>, <span class="string">"Action”);</span></span><br><span class="line"><span class="string">List&lt;String&gt; uniqueCharacters = words.stream()</span></span><br><span class="line"><span class="string">         .map(w -&gt; w.split("</span><span class="string">"))</span></span><br><span class="line"><span class="string">         .flatMap(Arrays::stream)</span></span><br><span class="line"><span class="string">         .distinct()</span></span><br><span class="line"><span class="string">         .collect(Collectors.toList());</span></span><br></pre></td></tr></table></figure>
<h1 id="3-查找和匹配"><a href="#3-查找和匹配" class="headerlink" title="3. 查找和匹配"></a>3. 查找和匹配</h1><h2 id="3-1-检查谓词是否至少匹配一个元素"><a href="#3-1-检查谓词是否至少匹配一个元素" class="headerlink" title="3.1 检查谓词是否至少匹配一个元素"></a>3.1 检查谓词是否至少匹配一个元素</h2><p>anyMatch方法可以回答“流中是否有一个元素能匹配给定的谓词”。anyMatch方法返回一个boolean，因此是一个终端操作。比如，你可以用它来看看菜单里面是否有素食可选择:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(menu.stream().anyMatch(Dish::isVegetarian))&#123;</span><br><span class="line">System.out.println(<span class="string">"The menu is (somewhat) vegetarian friendly!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-检查谓词是否匹配所有元素"><a href="#3-2-检查谓词是否匹配所有元素" class="headerlink" title="3.2 检查谓词是否匹配所有元素"></a>3.2 检查谓词是否匹配所有元素</h2><p>allMatch方法的工作原理和anyMatch类似，但它会看看流中的元素是否都能匹配给定的谓词。比如，你可以用它来看看菜品是否有利健康(即所有菜的热量都低于1000卡路里):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isHealthy = menu.stream().allMatch(d -&gt; d.getCalories() &lt; <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>和allMatch相对的是noneMatch。它可以确保流中没有任何元素与给定的谓词匹配。比如， 你可以用noneMatch重写前面的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isHealthy = menu.stream().noneMatch(d -&gt; d.getCalories() &gt;= <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>anyMatch、allMatch和noneMatch这三个操作都用到了我们所谓的短路，这就是大家熟悉 的Java中&amp;&amp;和||运算符短路在流中的版本。</p>
<h2 id="3-3-查找元素"><a href="#3-3-查找元素" class="headerlink" title="3.3 查找元素"></a>3.3 查找元素</h2><p>findAny方法将返回当前流中的任意元素。它可以与其他流操作结合使用。比如，你可能想找到一道素食菜肴。你可以结合使用filter和findAny方法来实现这个查询:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Dish&gt; dish =menu.stream()</span><br><span class="line">            .filter(Dish::isVegetarian)</span><br><span class="line">            .findAny();</span><br></pre></td></tr></table></figure>
<p>Optional<T>类(java.util.Optional)是一个容器类，代表一个值存在或不存在。Optional里面几种可以迫使你显式地检查值是否存在或处理值不存在的情形的方法也不错。</p>
<ul>
<li>isPresent()将在Optional包含值的时候返回true, 否则返回false。</li>
<li>ifPresent(Consumer<T> block)会在值存在的时候执行给定的代码块。</li>
<li>T get()会在值存在时返回值，否则抛出一个NoSuchElement异常。</li>
<li>T orElse(T other)会在值存在时返回值，否则返回一个默认值。</li>
</ul>
<h2 id="3-4-查找第一个元素"><a href="#3-4-查找第一个元素" class="headerlink" title="3.4 查找第一个元素"></a>3.4 查找第一个元素</h2><p>为此有一个findFirst 方法，它的工作方式类似于findany。 例如，给定一个数字列表，下面的代码能找出第一个平方 能被3整除的数: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; someNumbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; firstSquareDivisibleByThree = someNumbers.stream()</span><br><span class="line">                                                           .map(x -&gt; x * x)</span><br><span class="line">                                                           .filter(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">                                                           .findFirst(); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<h1 id="4-归约"><a href="#4-归约" class="headerlink" title="4. 归约"></a>4. 归约</h1><p>归约操作 (将流归约成一个值)。用函数式编程语言的术语来说，这称为折叠(fold)，因为你可以将这个操作看成把一张长长的纸(你的流)反复折叠成一个小方块，而这就是折叠操作的结果。</p>
<h2 id="4-1-元素求和"><a href="#4-1-元素求和" class="headerlink" title="4.1 元素求和"></a>4.1 元素求和</h2><p>reduce操作是如何作用于一个流的:Lambda反复结合每个元素，直到流被归约成一个值。<br>reduce接受两个参数:</p>
<ul>
<li>一个初始值，这里是0;</li>
<li>一个BinaryOperator<T>来将两个元素结合起来产生一个新值，这里我们用的是 lambda (a, b) -&gt; a + b。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = numbers.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure>

<p>reduce还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; (a + b));</span><br></pre></td></tr></table></figure>

<h2 id="4-2-最大值和最小值"><a href="#4-2-最大值和最小值" class="headerlink" title="4.2 最大值和最小值"></a>4.2 最大值和最小值</h2><p>使用reduce来计算流中的最大值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);</span><br></pre></td></tr></table></figure>
<p>要计算最小值，你需要把Integer.min传给reduce来替换Integer.max:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; min = numbers.stream().reduce(Integer::min);</span><br></pre></td></tr></table></figure>

<h2 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/05.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%205%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%B5%81/%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E5%92%8C%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C.png" alt=""></p>
<h1 id="5-实战"><a href="#5-实战" class="headerlink" title="5. 实战"></a>5. 实战</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trader raoul = <span class="keyword">new</span> Trader(<span class="string">"Raoul"</span>, <span class="string">"Cambridge"</span>);</span><br><span class="line">        Trader mario = <span class="keyword">new</span> Trader(<span class="string">"Mario"</span>,<span class="string">"Milan"</span>);</span><br><span class="line">        Trader alan = <span class="keyword">new</span> Trader(<span class="string">"Alan"</span>,<span class="string">"Cambridge"</span>);</span><br><span class="line">        Trader brian = <span class="keyword">new</span> Trader(<span class="string">"Brian"</span>,<span class="string">"Cambridge"</span>);</span><br><span class="line">        List&lt;Transaction&gt; transactions = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> Transaction(brian, <span class="number">2011</span>, <span class="number">300</span>),</span><br><span class="line">                <span class="keyword">new</span> Transaction(raoul, <span class="number">2012</span>, <span class="number">1000</span>),</span><br><span class="line">                <span class="keyword">new</span> Transaction(raoul, <span class="number">2011</span>, <span class="number">400</span>),</span><br><span class="line">                <span class="keyword">new</span> Transaction(mario, <span class="number">2012</span>, <span class="number">710</span>),</span><br><span class="line">                <span class="keyword">new</span> Transaction(mario, <span class="number">2012</span>, <span class="number">700</span>),</span><br><span class="line">                <span class="keyword">new</span> Transaction(alan, <span class="number">2012</span>, <span class="number">950</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"(1) 找出2011年发生的所有交易，并按交易额排序(从低到高)。"</span>);</span><br><span class="line">        List&lt;Transaction&gt; collect = transactions.stream()</span><br><span class="line">                .filter(t -&gt; t.getYear() == <span class="number">2011</span>)</span><br><span class="line">                .sorted(Comparator.comparing(Transaction::getValue))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\n(2) 交易员都在哪些不同的城市工作过?"</span>);</span><br><span class="line">        List&lt;String&gt; collect1 = transactions.stream()</span><br><span class="line">                .map(transaction -&gt; transaction.getTrader().getCity())</span><br><span class="line">                .distinct()</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect1);</span><br><span class="line">        <span class="comment">// [Cambridge, Milan]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\n(3) 查找所有来自于剑桥的交易员，并按姓名排序。"</span>);</span><br><span class="line">        List&lt;Trader&gt; collect2 = transactions.stream()</span><br><span class="line">                .map(Transaction::getTrader)</span><br><span class="line">                .filter(trader -&gt; trader.getCity().equals(<span class="string">"Cambridge"</span>))</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted(Comparator.comparing(Trader::getName))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\n(4) 返回所有交易员的姓名字符串，按字母顺序排序。"</span>);</span><br><span class="line">        String reduce = transactions.stream()</span><br><span class="line">                .map(transaction -&gt; transaction.getTrader().getName())</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted()</span><br><span class="line">                .reduce(<span class="string">""</span>, (n1, n2) -&gt; n1 + n2);</span><br><span class="line">        System.out.println(reduce);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\n(5) 有没有交易员是在米兰工作的?"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> b = transactions.stream()</span><br><span class="line">                .anyMatch(transaction -&gt; transaction.getTrader().getCity().equals(<span class="string">"Milan"</span>));</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\n(6) 打印生活在剑桥的交易员的所有交易额。"</span>);</span><br><span class="line">        transactions.stream()</span><br><span class="line">                .filter(transaction -&gt; transaction.getTrader().getCity().equals(<span class="string">"Cambridge"</span>))</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\n(7) 所有交易中，最高的交易额是多少?"</span>);</span><br><span class="line">        transactions.stream()</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .reduce(Integer::max)</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\n(8) 找到交易额最小的交易。"</span>);</span><br><span class="line">        transactions.stream()</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .reduce(Integer::min)</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-数值流"><a href="#6-数值流" class="headerlink" title="6. 数值流"></a>6. 数值流</h1><h2 id="6-1-原始类型流特化"><a href="#6-1-原始类型流特化" class="headerlink" title="6.1 原始类型流特化"></a>6.1 原始类型流特化</h2><p>Java 8引入了三个原始类型特化流接口来解决这个问题:IntStream、DoubleStream和 LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。</p>
<h3 id="6-1-1-映射到数值流"><a href="#6-1-1-映射到数值流" class="headerlink" title="6.1.1 映射到数值流"></a>6.1.1 映射到数值流</h3><p>将流转换为特化版本的常用方法是mapToInt、mapToDouble和mapToLong。这些方法和前 面说的map方法的工作方式一样，只是它们返回的是一个特化流，而不是Stream<T>。例如，你 可以像下面这样用mapToInt对menu中的卡路里求和:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> calories = menu.stream()                        <span class="comment">// 返回一个 Stream&lt;Dish&gt;</span></span><br><span class="line">                    .mapToInt(Dish::getCalories)    <span class="comment">// 返回一个 IntStream</span></span><br><span class="line">                    .sum();</span><br></pre></td></tr></table></figure>
<p>请注意，如果流是空的，sum默认返回0。IntStream还支持其他的方便方法，如max、min、average等。</p>
<h3 id="6-1-2-转换回对象流"><a href="#6-1-2-转换回对象流" class="headerlink" title="6.1.2 转换回对象流"></a>6.1.2 转换回对象流</h3><p>要把原始流转换成一般流(每个int都会装箱成一个 Integer)，可以使用boxed方法，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream = menu.stream().mapToInt(Dish::getCalories); <span class="comment">//将Stream转换为数值流</span></span><br><span class="line">Stream&lt;Integer&gt; stream = intStream.boxed(); <span class="comment">// 将数值流转换为Stream</span></span><br></pre></td></tr></table></figure>

<h3 id="6-1-3-默认值OptionalInt"><a href="#6-1-3-默认值OptionalInt" class="headerlink" title="6.1.3 默认值OptionalInt"></a>6.1.3 默认值OptionalInt</h3><p>对于三种原始流特化，也分别有一个Optional原始类 型特化版本:OptionalInt、OptionalDouble和OptionalLong。例如，要找到IntStream中的最大元素，可以调用max方法，它会返回一个OptionalInt:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OptionalInt maxCalories = menu.stream().mapToInt(Dish::getCalories).max();</span><br></pre></td></tr></table></figure>

<h2 id="6-2-数值范围"><a href="#6-2-数值范围" class="headerlink" title="6.2 数值范围"></a>6.2 数值范围</h2><p>Java 8引入了两个可以用于IntStream和LongStream的静态方法，帮助生成这种范围: range和rangeClosed。这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但range是不包含结束值的，而rangeClosed则包含结束值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream evenNumbers = IntStream.range(<span class="number">1</span>, <span class="number">100</span>) .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">// 一个从1到100的偶数流   表示范围[1, 100)</span></span><br><span class="line">IntStream evenNumbers = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>) .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">// 一个从1到100的偶数流   表示范围[1, 100]</span></span><br></pre></td></tr></table></figure>

<h1 id="7-构建流"><a href="#7-构建流" class="headerlink" title="7. 构建流"></a>7. 构建流</h1><h2 id="7-1-由值创建流"><a href="#7-1-由值创建流" class="headerlink" title="7.1 由值创建流"></a>7.1 由值创建流</h2><p>你可以使用静态方法Stream.of，通过显式值创建一个流。它可以接受任意数量的参数。例如，以下代码直接使用Stream.of创建了一个字符串流。然后，你可以将字符串转换为大写，再一个个打印出来:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java 8 "</span>, <span class="string">"Lambdas "</span>, <span class="string">"In "</span>, <span class="string">"Action"</span>); </span><br><span class="line">stream.map(String::toUpperCase).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>你可以使用empty得到一个空流，如下所示: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; emptyStream = Stream.empty();</span><br></pre></td></tr></table></figure>

<h2 id="7-2-由数组创建流"><a href="#7-2-由数组创建流" class="headerlink" title="7.2 由数组创建流"></a>7.2 由数组创建流</h2><p>你可以使用静态方法Arrays.stream从数组创建一个流。它接受一个数组作为参数。例如，你可以将一个原始类型int的数组转换成一个IntStream，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> sum = Arrays.stream(numbers).sum();</span><br></pre></td></tr></table></figure>

<h2 id="7-3-由文件生成流"><a href="#7-3-由文件生成流" class="headerlink" title="7.3 由文件生成流"></a>7.3 由文件生成流</h2><p>Java中用于处理文件等I/O操作的NIO API(非阻塞 I/O)已更新，以便利用Stream API。 java.nio.file.Files中的很多静态方法都会返回一个流。例如，一个很有用的方法是 Files.lines，它会返回一个由指定文件中的各行构成的字符串流。</p>
<h2 id="7-4-由函数生成流-创建无限流"><a href="#7-4-由函数生成流-创建无限流" class="headerlink" title="7.4 由函数生成流:创建无限流"></a>7.4 由函数生成流:创建无限流</h2><p>Stream API提供了两个静态方法来从函数生成流:Stream.iterate和Stream.generate。 这两个操作可以创建所谓的无限流:不像从固定集合创建的流那样有固定大小的流。由iterate 2 和generate产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去!一般来说， 应该使用limit(n)来对这种流加以限制，以避免打印无穷多个值。</p>
<h3 id="7-4-1-迭代"><a href="#7-4-1-迭代" class="headerlink" title="7.4.1 迭代"></a>7.4.1 迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>)</span><br><span class="line">      .limit(<span class="number">10</span>)</span><br><span class="line">      .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>此操作将生成一个无限流——这个流没有结尾，因为值是按需计算的，可以永远计算下去。我们说这个流是无界的。正如我们前面所讨论的，这是流和集合之间的一个关键区别。我们使用limit方法来显式限制流的大小。这里只选择了前10个偶数。然后可以调用forEach终端操作来消费流，并分别打印每个元素。</p>
<h3 id="7-4-2-生成"><a href="#7-4-2-生成" class="headerlink" title="7.4.2 生成"></a>7.4.2 生成</h3><p>与iterate方法类似，generate方法也可让你按需生成一个无限流。但generate不是依次 对每个新生成的值应用函数的。它接受一个Supplier<T>类型的Lambda提供新的值。我们先来看一个简单的用法:这段代码将生成一个流，其中有五个0到1之间的随机双精度数。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random)</span><br><span class="line">          .limit(<span class="number">5</span>)</span><br><span class="line">          .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h1 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h1><p>这一章很长，但是很有收获!现在你可以更高效地处理集合了。事实上，流让你可以简洁地表达复杂的数据处理查询。此外，流可以透明地并行化。以下是你应从本章中学到的关键概念。</p>
<ul>
<li>Streams API可以表达复杂的数据处理查询。常用的流操作总结在表5-1中。</li>
<li>你可以使用filter、distinct、skip和limit对流做筛选和切片。</li>
<li>你可以使用map和flatMap提取或转换流中的元素。 </li>
<li>你可以使用findFirst和findAny方法查找流中的元素。你可以用allMatch、noneMatch和anyMatch方法让流匹配给定的谓词。</li>
<li>这些方法都利用了短路:找到结果就立即停止计算;没有必要处理整个流。</li>
<li>你可以利用reduce方法将流中所有的元素迭代合并成一个结果，例如求和或查找最大元素。</li>
<li>filter和map等操作是无状态的，它们并不存储任何状态。reduce等操作要存储状态才能计算出一个值。sorted和distinct等操作也要存储状态，因为它们需要把流中的所有元素缓存起来才能返回一个新的流。这种操作称为有状态操作。</li>
<li>流有三种基本的原始类型特化:IntStream、DoubleStream和LongStream。它们的操作也有相应的特化。</li>
<li>流不仅可以从集合创建，也可从值、数组、文件以及iterate与generate等特定方法创建。</li>
<li>无限流是没有固定大小的流。</li>
</ul>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我的公众号：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-08T03:34:52.000Z" title="2019-03-08T03:34:52.000Z">2019-03-08</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">11 分钟 读完 (大约 1649 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/08/%E3%80%8AJava%208%20in%20Action%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%204%EF%BC%9A%E5%BC%95%E5%85%A5%E6%B5%81/">《Java 8 in Action》Chapter 4：引入流</a></h1><div class="content"><h1 id="1-流简介"><a href="#1-流简介" class="headerlink" title="1. 流简介"></a>1. 流简介</h1><p>流是Java API的新成员，它允许你以声明性方式处理数据集合(通过查询语句来表达，而不是临时编写一个实现)。就现在来说，你可以把它们看成遍历数据集的高级迭代器。此外，流还可以透明地并行处理。让我们来看一个实例返回低热量(&lt;400)的菜肴名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Java7版本：</span><br><span class="line">List&lt;Dish&gt; lowCaloricDishes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 用累加器筛选元素</span></span><br><span class="line"><span class="keyword">for</span>(Dish d: menu)&#123;</span><br><span class="line">    <span class="keyword">if</span>(d.getCalories() &lt; <span class="number">400</span>)&#123;</span><br><span class="line">        lowCaloricDishes.add(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用匿名类对菜肴排序</span></span><br><span class="line">Collections.sort(lowCaloricDishes, <span class="keyword">new</span> Comparator&lt;Dish&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dish d1, Dish d2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(d1.getCalories(), d2.getCalories());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 处理排序后的菜名列表</span></span><br><span class="line">List&lt;String&gt; lowCaloricDishesName = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Dish d: lowCaloricDishes)&#123;</span><br><span class="line">    lowCaloricDishesName.add(d.getName());</span><br><span class="line">&#125;</span><br><span class="line">Java8版本：</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.comparing;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList;</span><br><span class="line">List&lt;String&gt; lowCaloricDishesName = menu.stream()</span><br><span class="line">                                        .filter(d -&gt; d.getCalories() &lt; <span class="number">400</span>)    <span class="comment">// 选出400卡路里以下的菜肴</span></span><br><span class="line">                                        .sorted(comparing(Dish::getCalories))    <span class="comment">// 按照卡路里排序</span></span><br><span class="line">                                        .map(Dish::getName)                    <span class="comment">// 提取菜肴名称</span></span><br><span class="line">                                        .collect(toList());                    <span class="comment">// 将所有的名称保存在List中</span></span><br><span class="line">利用多核架构并行执行，只需要把stream()换成parallelStream()</span><br></pre></td></tr></table></figure>

<p>Java 8中的Stream API特性：</p>
<ul>
<li>声明性——更简洁，更易读</li>
<li>可复合——更灵活 </li>
<li>可并行——性能更好</li>
</ul>
<p>流定义：</p>
<ul>
<li>元素序列——就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序 值。</li>
<li>源——流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集 合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</li>
<li>数据处理操作——流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。</li>
<li>流水线——很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。这让我们下一章中的一些优化成为可能，如延迟和短路。流水线的操作可以看作对数据源进行数据库式查询。</li>
<li>内部迭代——与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/04.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%204%EF%BC%9A%E5%BC%95%E5%85%A5%E6%B5%81/1.%E7%AD%9B%E9%80%89%E8%8F%9C%E8%82%B4.png" alt=""></p>
<h1 id="2-流与集合"><a href="#2-流与集合" class="headerlink" title="2. 流与集合"></a>2. 流与集合</h1><p>集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。相比之下，流则是在概念上固定的数据结构(你不能添加或删除元素)，其元素则是按需计算的。集合和流的另一个关键区别在于它们遍历数据的方式。</p>
<h2 id="2-1-只能遍历一次"><a href="#2-1-只能遍历一次" class="headerlink" title="2.1 只能遍历一次"></a>2.1 只能遍历一次</h2><p>和迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。以下代码会抛出一个异常，说流已被消费掉了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; title = Arrays.asList(“Java8”,”In”, “Action”);</span><br><span class="line">Stream&lt;String&gt; s = title.stream();</span><br><span class="line">s.forEach(System.out::println);</span><br><span class="line">s.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalStateException: stream has already been operated upon or closed</span><br><span class="line">	at java.util.stream.AbstractPipeline.sourceStageSpliterator(AbstractPipeline.java:<span class="number">279</span>)</span><br><span class="line">	at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:<span class="number">580</span>)</span><br><span class="line">	at com.lujiahao.learnjava8.chapter4.StreamAndCollection.main(StreamAndCollection.java:<span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<h2 id="2-2-外部迭代与内部迭代"><a href="#2-2-外部迭代与内部迭代" class="headerlink" title="2.2 外部迭代与内部迭代"></a>2.2 外部迭代与内部迭代</h2><p>使用Collection接口需要用户去做迭代(比如用for-each)，这称为外部迭代。相反,Streams库使用内部迭代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">集合:用<span class="keyword">for</span>-each循环外部迭代</span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Dish d: menu)&#123;</span><br><span class="line">    names.add(d.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">集合:用背后的迭代器做外部迭代</span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator = menu.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    Dish d = iterator.next();</span><br><span class="line">    names.add(d.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">流:内部迭代</span><br><span class="line">List&lt;String&gt; names = menu.stream()</span><br><span class="line">                        .map(Dish::getName)</span><br><span class="line">                        .collect(toList());</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/04.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%204%EF%BC%9A%E5%BC%95%E5%85%A5%E6%B5%81/2.%E5%86%85%E9%83%A8%E8%BF%AD%E4%BB%A3%E4%B8%8E%E5%A4%96%E9%83%A8%E8%BF%AD%E4%BB%A3.png" alt=""></p>
<h1 id="3-流操作"><a href="#3-流操作" class="headerlink" title="3. 流操作"></a>3. 流操作</h1><p>java.util.stream.Stream中的Stream接口定义了许多操作。它们可以分为两大类。可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作。<br>中间操作：除非流水线上触发一个终端操作，否则中间操作不会执行任何处理。<br>终端操作：会从流的流水线生成结果。其结果是任何不是流的值。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/04.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%204%EF%BC%9A%E5%BC%95%E5%85%A5%E6%B5%81/3.%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C.png" alt=""></p>
<p>流的使用一般包括三件事:</p>
<ul>
<li>一个数据源(如集合)来执行一个查询;</li>
<li>一个中间操作链，形成一条流的流水线;</li>
<li>一个终端操作，执行流水线，并能生成结果。</li>
</ul>
<blockquote>
<p>流的流水线背后的理念类似于构建器模式。</p>
</blockquote>
<p>常见流操作：<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/04.%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%204%EF%BC%9A%E5%BC%95%E5%85%A5%E6%B5%81/4.%E5%B8%B8%E8%A7%81%E6%B5%81%E6%93%8D%E4%BD%9C.png" alt=""></p>
<h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h1><p>以下是你应从本章中学到的一些关键概念。</p>
<ul>
<li>流是“从支持数据处理操作的源生成的一系列元素”。</li>
<li>流利用内部迭代:迭代通过filter、map、sorted等操作被抽象掉了。</li>
<li>流操作有两类:中间操作和终端操作。</li>
<li>filter和map等中间操作会返回一个流，并可以链接在一起。可以用它们来设置一条流水线，但并不会生成任何结果</li>
<li>forEach和count等终端操作会返回一个非流的值，并处理流水线以返回结果。</li>
<li>流中的元素是按需计算的。</li>
</ul>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我的公众号：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-07T14:34:52.000Z" title="2019-03-07T14:34:52.000Z">2019-03-07</time><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">23 分钟 读完 (大约 3429 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/07/%E3%80%8AJava%208%20in%20Action%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%203%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">《Java 8 in Action》Chapter 3：Lambda表达式</a></h1><div class="content"><h1 id="1-Lambda简介"><a href="#1-Lambda简介" class="headerlink" title="1. Lambda简介"></a>1. Lambda简介</h1><p>可以把Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。</p>
<ul>
<li>匿名——我们说匿名，是因为它不像普通的方法那样有一个明确的名称:写得少而想得多!</li>
<li>函数——我们说它是函数，是因为Lambda函数不像方法那样属于某个特定的类。但和方法一样，Lambda有参数列表、函数主体、返回类型，还可能有可以抛出的异常列表。</li>
<li>传递——Lambda表达式可以作为参数传递给方法或存储在变量中。</li>
<li>简洁——无需像匿名类那样写很多模板代码。</li>
</ul>
<h1 id="2-Lambda写法"><a href="#2-Lambda写法" class="headerlink" title="2. Lambda写法"></a>2. Lambda写法</h1><p><code>(parameters) -&gt; expression 或 (parameters) -&gt; { statements; }</code><br><code>eg：(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</code><br>Lambda表达式有三个部分:</p>
<ul>
<li>参数列表——这里它采用了Comparator中compare方法的参数，两个Apple。 </li>
<li>箭头——箭头-&gt;把参数列表与Lambda主体分隔开。</li>
<li>Lambda主体——比较两个Apple的重量。表达式就是Lambda的返回值了。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%203%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/1.lambda%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<h1 id="3-函数式接口和函数描述符"><a href="#3-函数式接口和函数描述符" class="headerlink" title="3. 函数式接口和函数描述符"></a>3. 函数式接口和函数描述符</h1><p>函数式接口就是只定义一个抽象方法的接口。接口上标有<code>@FunctionalInterface</code>表示该接口会设计成 一个函数式接口，如果你用<code>@FunctionalInterface</code>定义了一个接口，而它却不是函数式接口的话，编译器将返回一个提示原因的错误。接口现在还可以拥有默认方法(即在类没有对方法进行实现时， 其主体为方法提供默认实现的方法)。哪怕有很多默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。</p>
<p>函数式接口的抽象方法的签名就是Lambda表达式的签名。我们将这种抽象方法叫作：函数描述符。例如，Runnable接口可以看作一个什么也不接受什么也不返回(void)的函数的签名，因为它只有一个叫作run的抽象方法，这个方法什么也不接受，什么也不返回(void)。</p>
<h1 id="4-三种常用的函数式接口"><a href="#4-三种常用的函数式接口" class="headerlink" title="4. 三种常用的函数式接口"></a>4. 三种常用的函数式接口</h1><h2 id="4-1-Predicate"><a href="#4-1-Predicate" class="headerlink" title="4.1 Predicate"></a>4.1 Predicate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a predicate (boolean-valued function) of one argument.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #test(Object)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates this predicate on the given argument.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input argument matches the predicate,</span></span><br><span class="line"><span class="comment">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Predicate的英文示意是：谓词。<br>Predicate接口定义了一个名叫test的抽象方法，它接受泛型T对象，并返回一个boolean。</p>
<h2 id="4-2-Consumer"><a href="#4-2-Consumer" class="headerlink" title="4.2 Consumer"></a>4.2 Consumer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Represents an operation that accepts a single input argument and returns no</span></span><br><span class="line"><span class="comment">* result. Unlike most other functional interfaces, &#123;<span class="doctag">@code</span> Consumer&#125; is expected</span></span><br><span class="line"><span class="comment">* to operate via side-effects.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment">* whose functional method is &#123;<span class="doctag">@link</span> #accept(Object)&#125;.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; the type of the input to the operation</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Performs this operation on the given argument.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Consumer的英文示意是：消费者。<br>Consumer接口定义了一个名叫accept的抽象方法，它接受泛型T对象，并没有返回任何值。</p>
<h2 id="4-3-Function"><a href="#4-3-Function" class="headerlink" title="4.3 Function"></a>4.3 Function</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Represents a function that accepts one argument and produces a result.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment">* whose functional method is &#123;<span class="doctag">@link</span> #apply(Object)&#125;.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; the type of the input to the function</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &lt;R&gt; the type of the result of the function</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Function的英文示意是：功能。<br>Function接口定义了一个名叫apply的抽象方法，它接受泛型T对象，并返回一个泛型R的对象。</p>
<blockquote>
<p>Java还有一个自动装箱机制来帮助程序员执行这一任务:装箱和拆箱操作是自动完成的。但这在性能方面是要付出代价的。装箱后的值本质上就是把原始类型包裹起来，并保存在堆里。因此，装箱后的值需要更多的内存，并需要额外的内存搜索来获取被包裹的原始值。Java 8为我们前面所说的函数式接口带来了一个专门的版本，以便在输入和输出都是原始类型时避免自动装箱的操作。</p>
</blockquote>
<h2 id="4-4-Java-8中的常用函数式接口"><a href="#4-4-Java-8中的常用函数式接口" class="headerlink" title="4.4 Java 8中的常用函数式接口"></a>4.4 Java 8中的常用函数式接口</h2><p><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%203%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/2.Java%208%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png" alt=""></p>
<h1 id="5-类型检查、类型推断以及限制"><a href="#5-类型检查、类型推断以及限制" class="headerlink" title="5. 类型检查、类型推断以及限制"></a>5. 类型检查、类型推断以及限制</h1><h2 id="5-1-类型检查"><a href="#5-1-类型检查" class="headerlink" title="5.1 类型检查"></a>5.1 类型检查</h2><p>Lambda的类型是从使用Lambda的上下文推断出来的。上下文(比如，接受它传递的方法的参数，或接受它的值的局部变量)中Lambda表达式需要的类型称为目标类型。<br><img src="https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/%E3%80%8AJava%208%20in%20Action%E3%80%8BChapter%203%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/3.%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5.png" alt=""><br>类型检查过程可以分解为如下所示。</p>
<ul>
<li>首先，你要找出filter方法的声明。</li>
<li>第二，要求它是Predicate<Apple>(目标类型)对象的第二个正式参数。</li>
<li>第三，Predicate<Apple>是一个函数式接口，定义了一个叫作test的抽象方法。</li>
<li>第四，test方法描述了一个函数描述符，它可以接受一个Apple，并返回一个boolean.</li>
<li>最后，filter的任何实际参数都必须匹配这个要求。</li>
</ul>
<p>这段代码是有效的，因为我们所传递的Lambda表达式也同样接受Apple为参数，并返回一个 boolean。请注意，如果Lambda表达式抛出一个异常，那么抽象方法所声明的throws语句也必 须与之匹配。有了目标类型的概念，同一个Lambda表达式就可以与不同的函数式接口联系起来，只要它 们的抽象方法签名能够兼容。比如，前面提到的Callable和PrivilegedAction，这两个接口都代表着什么也不接受且返回一个泛型T的函数。 因此，下面两个赋值是有效的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; c = () -&gt; <span class="number">42</span>;</span><br><span class="line">PrivilegedAction&lt;Integer&gt; p = () -&gt; <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>特殊的void兼容规则<br>如果一个Lambda的主体是一个语句表达式， 它就和一个返回void的函数描述符兼容(当然需要参数列表也兼容)。<br>例如，以下两行都是合法的，尽管List的add方法返回了一个 boolean，而不是Consumer上下文(T -&gt; void)所要求的void:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Predicate返回了一个boolean </span></span><br><span class="line">Predicate&lt;String&gt; p = s -&gt; list.add(s); </span><br><span class="line"><span class="comment">// Consumer返回了一个void </span></span><br><span class="line">Consumer&lt;String&gt; b = s -&gt; list.add(s);</span><br></pre></td></tr></table></figure>

<h2 id="5-2-类型推断"><a href="#5-2-类型推断" class="headerlink" title="5.2 类型推断"></a>5.2 类型推断</h2><p>Java编译器会从上下文(目标类型)推断出用什么函数式接 口来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通过目标类型来得到。这样做的好处在于，编译器可以了解Lambda表达式的参数类型，这样就可以在Lambda语法中省去标注参数类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有类 型推断</span></span><br><span class="line">Comparator&lt;Apple&gt; c = (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()); </span><br><span class="line"><span class="comment">// 有类型推断</span></span><br><span class="line">Comparator&lt;Apple&gt; c = (a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</span><br></pre></td></tr></table></figure>

<h2 id="5-3-使用局部变量"><a href="#5-3-使用局部变量" class="headerlink" title="5.3 使用局部变量"></a>5.3 使用局部变量</h2><p>Lambda表达式 也允许使用自由变量(不是参数，而是在外层作用域中定义的变量)，就像匿名类一样。 它们被 称作捕获Lambda。<br>Lambda捕获的局部变量必须显式声明为final， 或事实上是final。换句话说，Lambda表达式只能捕获指派给它们的局部变量一次。</p>
<ul>
<li>第一，实例变量和局部变量背后的实现有一 个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。</li>
<li>第二，这一限制不鼓励你使用改变外部变量的典型命令式编程模式(我们会在以后的各章中 解释，这种模式会阻碍很容易做到的并行处理)。</li>
</ul>
<h1 id="6-方法引用"><a href="#6-方法引用" class="headerlink" title="6. 方法引用"></a>6. 方法引用</h1><p>方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷 写法，方法引用看作针对仅仅涉及单一方法的Lambda的语法糖。目标引用放在分隔符::前，方法的名称放在后面。方法引用主要有三类：</p>
<ul>
<li>(1) 指向静态方法的方法引用(例如Integer的parseInt方法，写作Integer::parseInt)。</li>
<li>(2) 指向任意类型实例方法的方法引用(例如String的length方法，写作 String::length)。</li>
<li>(3) 指向现有对象的实例方法的方法引用(假设你有一个局部变量expensiveTransaction 用于存放Transaction类型的对象，它支持实例方法getValue，那么你就可以写expensive- Transaction::getValue)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对于一个现有构造函数，你可以利用它的名称和关键字<span class="keyword">new</span>来创建它的一个引用: ClassName::<span class="keyword">new</span>。它的功能与指向静态方法的引用类似。</span><br><span class="line">Supplier&lt;Apple&gt; c1 = Apple::<span class="keyword">new</span>;</span><br><span class="line">Apple a1 = c1.get();</span><br><span class="line">     </span><br><span class="line">这就等价于:</span><br><span class="line">Supplier&lt;Apple&gt; c1 = () -&gt; <span class="keyword">new</span> Apple(); <span class="comment">// 利用默认构造函数创建 Apple的Lambda表达式</span></span><br><span class="line">Apple a1 = c1.get(); <span class="comment">// 调用Supplier的get方法 将产生一个新的Apple</span></span><br></pre></td></tr></table></figure>

<h1 id="7-复合Lambda表达式的有用方法"><a href="#7-复合Lambda表达式的有用方法" class="headerlink" title="7. 复合Lambda表达式的有用方法"></a>7. 复合Lambda表达式的有用方法</h1><h2 id="7-1-比较器复合"><a href="#7-1-比较器复合" class="headerlink" title="7.1 比较器复合"></a>7.1 比较器复合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Apple&gt; c = Comparator.comparing(Apple::getWeight);</span><br><span class="line"><span class="comment">// 逆序 按重量递 减排序</span></span><br><span class="line">inventory.sort(comparing(Apple::getWeight).reversed());</span><br><span class="line"><span class="comment">// 比较器链 按重量递减排序;两个苹果一样重时，进一步按国家排序</span></span><br><span class="line">inventory.sort(comparing(Apple::getWeight)</span><br><span class="line">         .reversed()</span><br><span class="line">         .thenComparing(Apple::getCountry));</span><br></pre></td></tr></table></figure>

<h2 id="7-2-谓词复合"><a href="#7-2-谓词复合" class="headerlink" title="7.2 谓词复合"></a>7.2 谓词复合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产生现有Predicate 对象redApple的非</span></span><br><span class="line">Predicate&lt;Apple&gt; notRedApple = redApple.negate();</span><br><span class="line"><span class="comment">// 链接两个谓词来生成另 一个Predicate对象  一个苹果既是红色又比较重</span></span><br><span class="line">Predicate&lt;Apple&gt; redAndHeavyApple = redApple.and(a -&gt; a.getWeight() &gt; <span class="number">150</span>);</span><br><span class="line"><span class="comment">// 链接Predicate的方法来构造更复杂Predicate对象 表达要么是重(150克以上)的红苹果，要么是绿苹果</span></span><br><span class="line">Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen = redApple.and(a -&gt; a.getWeight() &gt; <span class="number">150</span>) </span><br><span class="line">                                            .or(a -&gt; <span class="string">"green"</span>.equals(a.getColor()));</span><br><span class="line">请注意，and和or方法是按照在表达式链中的位置，从左向右确定优 先级的。因此，a.or(b).and(c)可以看作(a || b) &amp;&amp; c。</span><br></pre></td></tr></table></figure>

<h2 id="7-3-函数复合"><a href="#7-3-函数复合" class="headerlink" title="7.3 函数复合"></a>7.3 函数复合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">andThen方法会返回一个函数，它先对输入应用一个给定函数，再对输出应用另一个函数。 比如，</span><br><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; h = f.andThen(g);</span><br><span class="line"><span class="keyword">int</span> result = h.apply(<span class="number">1</span>);</span><br><span class="line">数学上会写作g(f(x))或(g o f)(x)</span><br><span class="line">这将返回<span class="number">4</span></span><br><span class="line"></span><br><span class="line">compose方法，先把给定的函数用作compose的参数里面给的那个函 数，然后再把函数本身用于结果。</span><br><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; h = f.compose(g);</span><br><span class="line"><span class="keyword">int</span> result = h.apply(<span class="number">1</span>);</span><br><span class="line">数学上会写作f(g(x))或(f o g)(x) </span><br><span class="line">这将返回<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h1 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h1><p>以下是你应从本章中学到的关键概念。</p>
<ul>
<li>Lambda表达式可以理解为一种匿名函数:它没有名称，但有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常的列表。</li>
<li>Lambda表达式让你可以简洁地传递代码。</li>
<li>函数式接口就是仅仅声明了一个抽象方法的接口。</li>
<li>只有在接受函数式接口的地方才可以使用Lambda表达式。</li>
<li>Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例。</li>
<li>Java 8自带一些常用的函数式接口，放在java.util.function包里，包括Predicate<T>、Function&lt;T,R&gt;、Supplier<T>、Consumer<T>和BinaryOperator<T>，如表3-2所述。</li>
<li>为了避免装箱操作，对Predicate<T>和Function&lt;T, R&gt;等通用函数式接口的原始类型特化:IntPredicate、IntToLongFunction等。</li>
<li>环绕执行模式(即在方法所必需的代码中间，你需要执行点儿什么操作，比如资源分配 和清理)可以配合Lambda提高灵活性和可重用性。</li>
<li>Lambda表达式所需要代表的类型称为目标类型。</li>
<li>方法引用让你重复使用现有的方法实现并直接传递它们。</li>
<li>Comparator、Predicate和Function等函数式接口都有几个可以用来结合Lambda表达式的默认方法。</li>
</ul>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><ul>
<li>公众号回复 : Java8 即可获取《Java 8 in Action》中英文版!</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>欢迎收藏和转发，感谢你的支持！(๑•̀ㅂ•́)و✧ </li>
<li>欢迎关注我的公众号：后端小哥，专注后端开发，希望和你一起进步！</li>
</ul>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/tags/Java8/page/0/">上一页</a></div><div class="pagination-next"><a href="/tags/Java8/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/tags/Java8/">1</a></li><li><a class="pagination-link" href="/tags/Java8/page/2/">2</a></li></ul></nav></div><!--!--><div class="column column-right is-3-tablet is-3-desktop is-3-widescreen  order-3"><!--!--><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="/img/avatar.png" alt="后端小哥"></figure><p class="title is-size-4 is-block line-height-inherit">后端小哥</p><p class="is-size-6 is-block">Coder</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shijiazhuang, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">107</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">20</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">65</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/lujiahao0708" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://juejin.im/user/59239002570c350069c5f0bb" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">掘金</span></span><span class="level-right"><span class="level-item tag">juejin.im</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://blog.csdn.net/xinruodingshui" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://space.bilibili.com/302086424/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">B站</span></span><span class="level-right"><span class="level-item tag">space.bilibili.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Chrome/"><span class="level-start"><span class="level-item">Chrome</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Flutter/"><span class="level-start"><span class="level-item">Flutter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Hexo/"><span class="level-start"><span class="level-item">Hexo</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JavaEE/"><span class="level-start"><span class="level-item">JavaEE</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Mac/"><span class="level-start"><span class="level-item">Mac</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"><span class="level-start"><span class="level-item">MySQL必知必会</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Shiro/"><span class="level-start"><span class="level-item">Shiro</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Simpleblog%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">Simpleblog博客系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/SpringCloud/"><span class="level-start"><span class="level-item">SpringCloud</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"><span class="level-start"><span class="level-item">工具教程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B9%B6%E5%8F%91/"><span class="level-start"><span class="level-item">并发</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"><span class="level-start"><span class="level-item">持续集成</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%97%A5%E5%BF%97/"><span class="level-start"><span class="level-item">日志</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-11T14:03:59.000Z">2020-04-11</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/GitHub%20Actions%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%20Hexo/">GitHub Actions 自动部署 Hexo</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Hexo/">Hexo</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-11T09:28:08.000Z">2020-04-11</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/11/Redis/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Redis学习笔记</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Redis/">Redis</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-11T09:25:40.000Z">2020-04-11</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/11/Redis/Redis%E5%AE%89%E8%A3%85-%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83-%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/">Redis安装&amp;搭建本地环境&amp;备份恢复</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Redis/">Redis</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2019-12-20T12:54:41.000Z">2019-12-20</time></p><p class="title is-6"><a class="link-muted" href="/2019/12/20/MySQL/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AC%AC6-7%E7%AB%A0%20%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/">《MySQL必知必会》第6-7章 过滤数据与数据过滤</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">MySQL必知必会</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2019-12-19T14:54:41.000Z">2019-12-19</time></p><p class="title is-6"><a class="link-muted" href="/2019/12/19/MySQL/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AC%AC4-5%E7%AB%A0%20SELECT%E6%A3%80%E7%B4%A2%E4%B8%8E%E6%8E%92%E5%BA%8F/">《MySQL必知必会》第4-5章 SELECT检索与排序</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">MySQL必知必会</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="后端小哥博客" height="28"></a><p class="size-small"><span>&copy; 2020 后端小哥</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/lujiahao0708"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://lujiahao0708.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: ''
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>