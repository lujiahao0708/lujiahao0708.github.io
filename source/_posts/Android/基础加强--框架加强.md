---
title: 基础加强--框架加强
categories: JavaEE
tags:
  - JavaEE
  - 后台
  - Java基础
description: 学习框架之前的Java基础加强
abbrlink: 643f0c57
date: 2016-07-29 15:12:30
---

## 新特性
Static Import : 静态导入，当前类中可以直接使用静态资源（字段|方法）

	格式：import static java.lang.Math.*;
Varargs ：可变参数

	public void demo(String... args){ 当成数组使用 }
Autoboxing/Unboxing 自动装箱、自动拆箱（基本类型 <--> 包装类）

	装箱：基本类型 --> 包装类。例如：Integer i = 10;  --> Integer m = new Integer(10);
	拆箱：包装类 --> 基本类型。例如：int j = i;  --> int n = m.intValue();
Enhanced for Loop 增强for循环

	for(类型 变量 : 容器){}   --> 容器：数组、Iterable接口（iterator方法）
Typesafe Enums 枚举

	public class Hello {}
	public enum Color {}


## 泛型

特点

	1.将运行时的问题提升到编译时
	2.方法级别的泛型定义主要是用在工具类中的
		public class TestGeneric2 {
			public void demo(){
				int m = 10;
				String s = init("abc");
				Integer i = init(123);
			}
			//方法级别的定义  MyBeanUtils
			public <T> T init(T obj){
				//算法
				System.out.println(obj);
				return obj;
			}
		}

泛型擦除

	以下两个方法不能同时存在
	public void init(List<String> list){}
	public void init(List<Integer> list){}
	类型擦除之后，两个方法是完全相同

反射中Class对象的三种获取方式:

	Class.forName("全限定类名");
	String.class
	obj.getClass

反射和泛型混合使用的例子:

	public class Dao<T> {
		private Session session;
		private Class beanClass;
		public Dao() {
			//1 在运行时，获得当前运行类 父类中泛型的实际参数
			//this.getClass().getSuperclass(); //jdk1.4之前，获得父类，不含泛型信息
			// * 获得被参数化的类型  ArrayList<Integer> ，含有泛型信息
			ParameterizedType type = (ParameterizedType) this.getClass().getGenericSuperclass();
			//2 获得所有的实际参数类型。类<A,B,C,D> ,返回数组，获得第一个实际参数
			Type firstType = type.getActualTypeArguments()[0];
			
			this.beanClass = (Class) firstType;
			
			/*
				//回顾 反射 api
				beanClass.getName(); //类名
				beanClass.getMethod(name, parameterTypes)  //方法
				beanClass.getConstructor(parameterTypes) //构造
				beanClass.getField(name)  //字段
			*/
			System.out.println(beanClass);
		}
		
		/* 泛型 ，将运行时问题 提升 编译时
		 * 泛型实参只有在运行时才可以确定，编译时 T 不能确定类型（User | Book） 只有在运行时才可以确定
		 * 思想：如何在运行时获得实际类型参数？
		 */
		public T findById(Integer id){
			return (T) session.get(beanClass, id);
		}
	}

## 注解
介绍

	注解就是类,用于修饰对象(类/构造/字段/方法等),常用语取代xml配置.
	但是,开发中常用注解+xml混合使用

JDK提供的常用注解

	@Override
		在jdk1.5表示子类覆写父类的方法
		在jdk1.6表示子类实现父接口的方法
	@Deprecated
		表示被修饰对象已经过期了,过期的方法依旧可以使用.
		以下情况被标记过期:1.安全问题 2.有新的API
	@SuppressWarnings
		抑制警告,如果有警告通过编辑器不进行警告
			deprecation:如果过期不警告
			rawtypes:没有泛型
			unused:未使用
			null:空指针
			serial:序列化
			all:所有
		建议:尽量不使用抑制
## 自定义注解
注解架构

	定义注解
	使用注解
	解析注解
基本语法
	
	定义注解使用关键字 : `@interface` ,和定义类class相似
		public @interface xxx{}
	成员格式: 修饰符 返回值 属性名() [default 默认值]
		eg: public String username();
		注意点:
			1.修饰符:默认值 public abstract,且只能是这两个
			2.返回值:只能是基本类型/字符串String/Class/注解/枚举,以及以上类型的一维数组.
使用注解---重点!!!
 

注解出现的目的就是用来代替xml的